/// Framework Core Low-Level Variants / TDocVariant process
// - this unit is a part of the Open Source Synopse mORMot framework 2,
// licensed under a MPL/GPL/LGPL three license - see LICENSE.md
unit mormot.core.variants;

{
  *****************************************************************************

  Variant / TDocVariant feature shared by all framework units
  - Low-Level Variant Wrappers
  - Custom Variant Types with JSON support
  - TDocVariant Object/Array Document Holder with JSON support
  - JSON Parsing into Variant

  *****************************************************************************
}

interface

{$I ..\mormot.defines.inc}

uses
  sysutils,
  variants,
  mormot.core.base,
  mormot.core.unicode,
  mormot.core.text,
  mormot.core.data, // already included in mormot.core.json
  mormot.core.rtti,
  mormot.core.json;

  
{ ************** Low-Level Variant Wrappers }

type
  /// exception class raised by this unit during raw Variant process
  ESynVariant = class(ESynException);

/// fastcheck if a variant hold a value
// - varEmpty, varNull or a '' string would be considered as void
// - varBoolean=false or varDate=0 would be considered as void
// - a TDocVariantData with Count=0 would be considered as void
// - any other value (e.g. integer) would be considered as not void
function VarIsVoid(const V: Variant): boolean;

/// returns a supplied string as variant, or null if v is void ('')
function VarStringOrNull(const v: RawUTF8): variant;

type
  /// a set of simple TVarData.VType, as specified to VarIs()
  TVarDataTypes = set of 0..255;

/// allow to check for a specific set of TVarData.VType
function VarIs(const V: Variant; const VTypes: TVarDataTypes): Boolean;
  {$ifdef HASINLINE} inline;{$endif}

/// same as Dest := Source, but copying by reference
// - i.e. VType is defined as varVariant or varByRef
// - for instance, it will be used for late binding of TDocVariant properties,
// to let following statements work as expected:
// ! V := _Json('{arr:[1,2]}');
// ! V.arr.Add(3);   // will work, since V.arr will be returned by reference
// ! writeln(V);     // will write '{"arr":[1,2,3]}'
procedure SetVariantByRef(const Source: Variant; var Dest: Variant);

/// same as Dest := Source, but copying by value
// - will unreference any varByRef content
// - will convert any string value into RawUTF8 (varString) for consistency
procedure SetVariantByValue(const Source: Variant; var Dest: Variant);

/// same as FillChar(Value^,SizeOf(TVarData),0)
// - so can be used for TVarData or Variant
// - it will set V.VType := varEmpty, so Value will be Unassigned
// - it won't call VarClear(variant(Value)): it should have been cleaned before
procedure ZeroFill(Value: PVarData);
  {$ifdef HASINLINE}inline;{$endif}

/// fill all bytes of the value's memory buffer with zeros, i.e. 'toto' -> #0#0#0#0
// - may be used to cleanup stack-allocated content
procedure FillZero(var value: variant); overload;

/// convert a FormatUTF8() UTF-8 encoded string into a variant RawUTF8 varString
procedure FormatUTF8ToVariant(const Fmt: RawUTF8; const Args: array of const; var Value: variant);

/// convert an UTF-8 encoded text buffer into a variant RawUTF8 varString
// - this overloaded version expects a destination variant type (e.g. varString
// varOleStr / varUString) - if the type is not handled, will raise an
// EVariantTypeCastError
procedure RawUTF8ToVariant(const Txt: RawUTF8; var Value: TVarData;
  ExpectedValueType: cardinal); overload;

/// convert an open array (const Args: array of const) argument to a variant
// - note that, due to a Delphi compiler limitation, cardinal values should be
// type-casted to Int64() (otherwise the integer mapped value will be converted)
// - vt*String or vtVariant arguments are returned as varByRef
procedure VarRecToVariant(const V: TVarRec; var result: variant); overload;

/// convert an open array (const Args: array of const) argument to a variant
// - note that, due to a Delphi compiler limitation, cardinal values should be
// type-casted to Int64() (otherwise the integer mapped value will be converted)
// - vt*String or vtVariant arguments are returned as varByRef
function VarRecToVariant(const V: TVarRec): variant; overload;
  {$ifdef HASINLINE}inline;{$endif}

/// convert a variant to an open array (const Args: array of const) argument
// - will always map to a vtVariant kind of argument
procedure VariantToVarRec(const V: variant; var result: TVarRec);
  {$ifdef HASINLINE}inline;{$endif}

/// convert any Variant into a VCL string type
// - expects any varString value to be stored as a RawUTF8
// - prior to Delphi 2009, use VariantToString(aVariant) instead of
// string(aVariant) to safely retrieve a string=AnsiString value from a variant
// generated by our framework units - otherwise, you may loose encoded characters
// - for Unicode versions of Delphi, there won't be any potential data loss,
// but this version may be slightly faster than a string(aVariant)
function VariantToString(const V: Variant): string;


type
  /// function prototype used internally for variant comparison
  // - used in mORMot.pas unit e.g. by TDocVariantData.SortByValue
  TVariantCompare = function(const V1, V2: variant): PtrInt;

/// TVariantCompare-compatible case-sensitive comparison function
// - just a wrapper around SortDynArrayVariantComp(caseInsensitive=false)
function VariantCompare(const V1, V2: variant): PtrInt;
  {$ifdef HASINLINE}inline;{$endif}

/// TVariantCompare-compatible case-insensitive comparison function
// - just a wrapper around SortDynArrayVariantComp(caseInsensitive=true)
function VariantCompareI(const V1, V2: variant): PtrInt;
  {$ifdef HASINLINE}inline;{$endif}

/// fast comparison of a Variant and UTF-8 encoded String (or number)
// - slightly faster than plain V=Str, which computes a temporary variant
// - here Str='' equals unassigned, null or false
// - if CaseSensitive is false, will use IdemPropNameU() for comparison
function VariantEquals(const V: Variant; const Str: RawUTF8;
  CaseSensitive: boolean = true): boolean; overload;


{ ************** Custom Variant Types with JSON support }

type
  /// custom variant handler with easier/faster access of variant properties,
  // and JSON serialization support
  // - default GetProperty/SetProperty methods are called via some protected
  // virtual IntGet/IntSet methods, with less overhead (to be overriden)
  // - these kind of custom variants will be faster than the default
  // TInvokeableVariantType for properties getter/setter, but you should
  // manually register each type by calling SynRegisterCustomVariantType()
  // - also feature custom JSON parsing, via TryJSONToVariant() protected method
  TSynInvokeableVariantType = class(TInvokeableVariantType)
  protected
    {$ifdef ISDELPHI}
    /// our custom call backs do not want the function names to be uppercased
    function FixupIdent(const AText: string): string; override;
    {$endif ISDELPHI}
    /// override those two abstract methods for fast getter/setter implementation
    function IntGet(var Dest: TVarData; const Instance: TVarData;
      Name: PAnsiChar; NameLen: PtrInt): boolean; virtual;
    function IntSet(const Instance, Value: TVarData;
      Name: PAnsiChar; NameLen: PtrInt): boolean; virtual;
  public
    /// search of a registered custom variant type from its low-level VarType
    // - will first compare with its own VarType for efficiency
    function FindSynVariantType(aVarType: Word; out CustomType: TSynInvokeableVariantType): boolean;
    /// customization of JSON parsing into variants
    // - will be called by e.g. by VariantLoadJSON() or GetVariantFromJSON()
    // with Options: PDocVariantOptions parameter not nil
    // - this default implementation will always returns FALSE,
    // meaning that the supplied JSON is not to be handled by this custom
    // (abstract) variant type
    // - this method could be overridden to identify any custom JSON content
    // and convert it into a dedicated variant instance, then return TRUE
    // - warning: should NOT modify JSON buffer in-place, unless it returns true
    function TryJSONToVariant(var JSON: PUTF8Char; var Value: variant;
      EndOfObject: PUTF8Char): boolean; virtual;
    /// customization of variant into JSON serialization
    procedure ToJSON(W: TTextWriter; const Value: variant; Escape: TTextWriterKind); overload; virtual;
    /// retrieve the field/column value
    // - this method will call protected IntGet abstract method
    function GetProperty(var Dest: TVarData; const V: TVarData;
      const Name: String): Boolean; override;
    /// set the field/column value
    // - this method will call protected IntSet abstract method
    {$ifdef FPC_VARIANTSETVAR} // see http://mantis.freepascal.org/view.php?id=26773
    function SetProperty(var V: TVarData; const Name: string;
      const Value: TVarData): Boolean; override;
    {$else}
    function SetProperty(const V: TVarData; const Name: string;
      const Value: TVarData): Boolean; override;
    {$endif}
    /// clear the content
    // - this default implementation will set VType := varEmpty
    // - override it if your custom type needs to manage its internal memory
    procedure Clear(var V: TVarData); override;
    /// copy two variant content
    // - this default implementation will copy the TVarData memory
    // - override it if your custom type needs to manage its internal structure
    procedure Copy(var Dest: TVarData; const Source: TVarData;
      const Indirect: Boolean); override;
    /// copy two variant content by value
    // - this default implementation will call the Copy() method
    // - override it if your custom types may use a by reference copy pattern
    procedure CopyByValue(var Dest: TVarData; const Source: TVarData); virtual;
    /// this method will allow to look for dotted name spaces, e.g. 'parent.child'
    // - should return Unassigned if the FullName does not match any value
    // - will identify TDocVariant storage, or resolve and call the generic
    // TSynInvokeableVariantType.IntGet() method until nested value match
    procedure Lookup(var Dest: TVarData; const Instance: TVarData; FullName: PUTF8Char);
    /// will check if the value is an array, and return the number of items
    // - if the document is an array, will return the items count (0 meaning
    // void array) - used e.g. by TSynMustacheContextVariant
    // - this default implementation will return -1 (meaning this is not an array)
    // - overridden method could implement it, e.g. for TDocVariant of kind dvArray
    function IterateCount(const V: TVarData): integer; virtual;
    /// allow to loop over an array document
    // - Index should be in 0..IterateCount-1 range
    // - this default implementation will do nothing
    procedure Iterate(var Dest: TVarData; const V: TVarData; Index: integer); virtual;
    /// returns TRUE if the supplied variant is of the exact custom type
    function IsOfType(const V: variant): boolean;
  end;

  /// class-reference type (metaclass) of custom variant type definition
  // - used by SynRegisterCustomVariantType() function
  TSynInvokeableVariantTypeClass = class of TSynInvokeableVariantType;

/// register a custom variant type to handle properties
// - this will implement an internal mechanism used to bypass the default
// _DispInvoke() implementation in Variant.pas, to use a faster version
// - is called in case of TSynTableVariant, TDocVariant, TBSONVariant or
// TSQLDBRowVariant
function SynRegisterCustomVariantType(aClass: TSynInvokeableVariantTypeClass): TSynInvokeableVariantType;

/// try to serialize a custom variant value into JSON
// - as used e.g. by TTextWriter.AddVariant
function CustomVariantToJSON(W: TTextWriter; const Value: variant;
  Escape: TTextWriterKind): boolean;


{ ************** TDocVariant Object/Array Document Holder with JSON support }

type
  /// exception class associated to TDocVariant JSON/BSON document
  EDocVariant = class(ESynException);

const
  /// some convenient TDocVariant options, as JSON_OPTIONS[CopiedByReference]
  // - JSON_OPTIONS[false] is e.g. _Json() and _JsonFmt() functions default
  // - JSON_OPTIONS[true] are used e.g. by _JsonFast() and _JsonFastFmt() functions
  JSON_OPTIONS: array[Boolean] of TDocVariantOptions = (
    [dvoReturnNullForUnknownProperty],
    [dvoReturnNullForUnknownProperty,dvoValueCopiedByReference]);

  /// same as JSON_OPTIONS[true], but can not be used as PDocVariantOptions
  JSON_OPTIONS_FAST =
    [dvoReturnNullForUnknownProperty,dvoValueCopiedByReference];

  /// TDocVariant options which may be used for plain JSON parsing
  // - this won't recognize any extended syntax
  JSON_OPTIONS_FAST_STRICTJSON: TDocVariantOptions =
    [dvoReturnNullForUnknownProperty,dvoValueCopiedByReference,
     dvoJSONParseDoNotTryCustomVariants];

  /// TDocVariant options to be used for case-sensitive TSynNameValue-like
  // storage, with optional extended JSON syntax serialization
  // - consider using JSON_OPTIONS_FAST_EXTENDED for case-insensitive objects
  JSON_OPTIONS_NAMEVALUE: array[boolean] of TDocVariantOptions = (
    [dvoReturnNullForUnknownProperty,dvoValueCopiedByReference,
     dvoNameCaseSensitive],
    [dvoReturnNullForUnknownProperty,dvoValueCopiedByReference,
     dvoNameCaseSensitive,dvoSerializeAsExtendedJson]);

  /// TDocVariant options to be used for case-sensitive TSynNameValue-like
  // storage, RawUTF8 interning and optional extended JSON syntax serialization
  // - consider using JSON_OPTIONS_FAST_EXTENDED for case-insensitive objects,
  // or JSON_OPTIONS_NAMEVALUE[] if you don't expect names and values interning
  JSON_OPTIONS_NAMEVALUEINTERN: array[boolean] of TDocVariantOptions = (
    [dvoReturnNullForUnknownProperty,dvoValueCopiedByReference,
     dvoNameCaseSensitive,dvoInternNames,dvoInternValues],
    [dvoReturnNullForUnknownProperty,dvoValueCopiedByReference,
     dvoNameCaseSensitive,dvoInternNames,dvoInternValues,
     dvoSerializeAsExtendedJson]);

  /// TDocVariant options to be used so that JSON serialization would
  // use the unquoted JSON syntax for field names
  // - you could use it e.g. on a TSQLRecord variant published field to
  // reduce the JSON escape process during storage in the database, by
  // customizing your TSQLModel instance:
  // !  (aModel.Props[TSQLMyRecord]['VariantProp'] as TSQLPropInfoRTTIVariant).
  // !    DocVariantOptions := JSON_OPTIONS_FAST_EXTENDED;
  // or - in a cleaner way - by overriding TSQLRecord.InternalDefineModel():
  // ! class procedure TSQLMyRecord.InternalDefineModel(Props: TSQLRecordProperties);
  // ! begin
  // !   (Props.Fields.ByName('VariantProp') as TSQLPropInfoRTTIVariant).
  // !     DocVariantOptions := JSON_OPTIONS_FAST_EXTENDED;
  // ! end;
  // or to set all variant fields at once:
  // ! class procedure TSQLMyRecord.InternalDefineModel(Props: TSQLRecordProperties);
  // ! begin
  // !   Props.SetVariantFieldsDocVariantOptions(JSON_OPTIONS_FAST_EXTENDED);
  // ! end;
  // - consider using JSON_OPTIONS_NAMEVALUE[true] for case-sensitive
  // TSynNameValue-like storage, or JSON_OPTIONS_FAST_EXTENDEDINTERN if you
  // expect RawUTF8 names and values interning
  JSON_OPTIONS_FAST_EXTENDED: TDocVariantOptions =
    [dvoReturnNullForUnknownProperty,dvoValueCopiedByReference,
     dvoSerializeAsExtendedJson];

  /// TDocVariant options for JSON serialization with efficient storage
  // - i.e. unquoted JSON syntax for field names and RawUTF8 interning
  // - may be used e.g. for efficient persistence of similar data
  // - consider using JSON_OPTIONS_FAST_EXTENDED if you don't expect
  // RawUTF8 names and values interning, or need BSON variants parsing
  JSON_OPTIONS_FAST_EXTENDEDINTERN: TDocVariantOptions =
    [dvoReturnNullForUnknownProperty,dvoValueCopiedByReference,
     dvoSerializeAsExtendedJson,dvoJSONParseDoNotTryCustomVariants,
     dvoInternNames,dvoInternValues];

type
  /// pointer to a TDocVariant storage
  // - since variants may be stored by reference (i.e. as varByRef), it may
  // be a good idea to use such a pointer via DocVariantData(aVariant)^ or
  // _Safe(aVariant)^ instead of TDocVariantData(aVariant),
  // if you are not sure how aVariant was allocated (may be not _Obj/_Json)
  PDocVariantData = ^TDocVariantData;

  /// a custom variant type used to store any JSON/BSON document-based content
  // - i.e. name/value pairs for objects, or an array of values (including
  // nested documents), stored in a TDocVariantData memory structure
  // - you can use _Obj()/_ObjFast() _Arr()/_ArrFast() _Json()/_JsonFast() or
  // _JsonFmt()/_JsonFastFmt() functions to create instances of such variants
  // - property access may be done via late-binding - with some restrictions
  // for older versions of FPC, e.g. allowing to write:
  // ! TDocVariant.NewFast(aVariant);
  // ! aVariant.Name := 'John';
  // ! aVariant.Age := 35;
  // ! writeln(aVariant.Name,' is ',aVariant.Age,' years old');
  // - it also supports a small set of pseudo-properties or pseudo-methods:
  // ! aVariant._Count = DocVariantData(aVariant).Count
  // ! aVariant._Kind = ord(DocVariantData(aVariant).Kind)
  // ! aVariant._JSON = DocVariantData(aVariant).JSON
  // ! aVariant._(i) = DocVariantData(aVariant).Value[i]
  // ! aVariant.Value(i) = DocVariantData(aVariant).Value[i]
  // ! aVariant.Value(aName) = DocVariantData(aVariant).Value[aName]
  // ! aVariant.Name(i) = DocVariantData(aVariant).Name[i]
  // ! aVariant.Add(aItem) = DocVariantData(aVariant).AddItem(aItem)
  // ! aVariant._ := aItem = DocVariantData(aVariant).AddItem(aItem)
  // ! aVariant.Add(aName,aValue) = DocVariantData(aVariant).AddValue(aName,aValue)
  // ! aVariant.Exists(aName) = DocVariantData(aVariant).GetValueIndex(aName)>=0
  // ! aVariant.Delete(i) = DocVariantData(aVariant).Delete(i)
  // ! aVariant.Delete(aName) = DocVariantData(aVariant).Delete(aName)
  // ! aVariant.NameIndex(aName) = DocVariantData(aVariant).GetValueIndex(aName)
  // - it features direct JSON serialization/unserialization, e.g.:
  // ! assert(_Json('["one",2,3]')._JSON='["one",2,3]');
  // - it features direct trans-typing into a string encoded as JSON, e.g.:
  // ! assert(_Json('["one",2,3]')='["one",2,3]');
  TDocVariant = class(TSynInvokeableVariantType)
  protected
    /// name and values interning are shared among all TDocVariantData instances
    fInternNames, fInternValues: TRawUTF8Interning;
    /// fast getter implementation
    function IntGet(var Dest: TVarData; const Instance: TVarData;
      Name: PAnsiChar; NameLen: PtrInt): boolean; override;
    /// fast setter implementation
    function IntSet(const Instance, Value: TVarData;
      Name: PAnsiChar; NameLen: PtrInt): boolean; override;
  public
    /// initialize a variant instance to store some document-based content
    // - by default, every internal value will be copied, so access of nested
    // properties can be slow - if you expect the data to be read-only or not
    // propagated into another place, set aOptions=[dvoValueCopiedByReference]
    // will increase the process speed a lot
    class procedure New(out aValue: variant; aOptions: TDocVariantOptions = []); overload;
      {$ifdef HASINLINE}inline;{$endif}
    /// initialize a variant instance to store per-reference document-based content
    // - same as New(aValue,JSON_OPTIONS[true]);
    // - to be used e.g. as
    // !var v: variant;
    // !begin
    // !  TDocVariant.NewFast(v);
    // !  ...
    class procedure NewFast(out aValue: variant); overload;
      {$ifdef HASINLINE}inline;{$endif}
    /// ensure a variant is a TDocVariant instance
    // - if aValue is not a TDocVariant, will create a new JSON_OPTIONS[true]
    class procedure IsOfTypeOrNewFast(var aValue: variant);
    /// initialize several variant instances to store document-based content
    // - replace several calls to TDocVariantData.InitFast
    // - to be used e.g. as
    // !var v1,v2,v3: TDocVariantData;
    // !begin
    // !  TDocVariant.NewFast([@v1,@v2,@v3]);
    // !  ...
    class procedure NewFast(const aValues: array of PDocVariantData); overload;
    /// initialize a variant instance to store some document-based content
    // - you can use this function to create a variant, which can be nested into
    // another document, e.g.:
    // ! aVariant := TDocVariant.New;
    // ! aVariant.id := 10;
    // - by default, every internal value will be copied, so access of nested
    // properties can be slow - if you expect the data to be read-only or not
    // propagated into another place, set Options=[dvoValueCopiedByReference]
    // will increase the process speed a lot
    // - in practice, you should better use _Obj()/_ObjFast() _Arr()/_ArrFast()
    // functions or TDocVariant.NewFast()
    class function New(Options: TDocVariantOptions = []): variant; overload;
      {$ifdef HASINLINE}inline;{$endif}
    /// initialize a variant instance to store some document-based object content
    // - object will be initialized with data supplied two by two, as Name,Value
    // pairs, e.g.
    // ! aVariant := TDocVariant.NewObject(['name','John','year',1972]);
    // which is the same as:
    // ! TDocVariant.New(aVariant);
    // ! TDocVariantData(aVariant).AddValue('name','John');
    // ! TDocVariantData(aVariant).AddValue('year',1972);
    // - by default, every internal value will be copied, so access of nested
    // properties can be slow - if you expect the data to be read-only or not
    // propagated into another place, set Options=[dvoValueCopiedByReference]
    // will increase the process speed a lot
    // - in practice, you should better use the function _Obj() which is a
    // wrapper around this class method
    class function NewObject(const NameValuePairs: array of const;
      Options: TDocVariantOptions = []): variant;
    /// initialize a variant instance to store some document-based array content
    // - array will be initialized with data supplied as parameters, e.g.
    // ! aVariant := TDocVariant.NewArray(['one',2,3.0]);
    // which is the same as:
    // ! TDocVariant.New(aVariant);
    // ! TDocVariantData(aVariant).AddItem('one');
    // ! TDocVariantData(aVariant).AddItem(2);
    // ! TDocVariantData(aVariant).AddItem(3.0);
    // - by default, every internal value will be copied, so access of nested
    // properties can be slow - if you expect the data to be read-only or not
    // propagated into another place, set aOptions=[dvoValueCopiedByReference]
    // will increase the process speed a lot
    // - in practice, you should better use the function _Arr() which is a
    // wrapper around this class method
    class function NewArray(const Items: array of const;
      Options: TDocVariantOptions = []): variant; overload;
    /// initialize a variant instance to store some document-based array content
    // - array will be initialized with data supplied dynamic array of variants
    class function NewArray(const Items: TVariantDynArray;
      Options: TDocVariantOptions = []): variant; overload;
    /// initialize a variant instance to store some document-based object content
    // from a supplied (extended) JSON content
    // - in addition to the JSON RFC specification strict mode, this method will
    // handle some BSON-like extensions, e.g. unquoted field names
    // - a private copy of the incoming JSON buffer will be used, then
    // it will call the TDocVariantData.InitJSONInPlace() method
    // - to be used e.g. as:
    // ! var V: variant;
    // ! begin
    // !   V := TDocVariant.NewJSON('{"id":10,"doc":{"name":"John","birthyear":1972}}');
    // !   assert(V.id=10);
    // !   assert(V.doc.name='John');
    // !   assert(V.doc.birthYear=1972);
    // !   // and also some pseudo-properties:
    // !   assert(V._count=2);
    // !   assert(V.doc._kind=ord(dvObject));
    // - or with a JSON array:
    // !   V := TDocVariant.NewJSON('["one",2,3]');
    // !   assert(V._kind=ord(dvArray));
    // !   for i := 0 to V._count-1 do
    // !     writeln(V._(i));
    // - by default, every internal value will be copied, so access of nested
    // properties can be slow - if you expect the data to be read-only or not
    // propagated into another place, add dvoValueCopiedByReference in Options
    // will increase the process speed a lot
    // - in practice, you should better use the function _Json()/_JsonFast()
    // which are handy wrappers around this class method
    class function NewJSON(const JSON: RawUTF8;
      Options: TDocVariantOptions = [dvoReturnNullForUnknownProperty]): variant;
      {$ifdef HASINLINE}inline;{$endif}
    /// initialize a variant instance to store some document-based object content
    // from a supplied existing TDocVariant instance
    // - use it on a value returned as varByRef (e.g. by _() pseudo-method),
    // to ensure the returned variant will behave as a stand-alone value
    // - for instance, the following:
    // !  oSeasons := TDocVariant.NewUnique(o.Seasons);
    // is the same as:
    // ! 	oSeasons := o.Seasons;
    // !  _Unique(oSeasons);
    // or even:
    // !  oSeasons := _Copy(o.Seasons);
    class function NewUnique(const SourceDocVariant: variant;
      Options: TDocVariantOptions = [dvoReturnNullForUnknownProperty]): variant;
      {$ifdef HASINLINE}inline;{$endif}
    /// will return the unique element of a TDocVariant array or a default
    // - if the value is a dvArray with one single item, it will this value
    // - if the value is not a TDocVariant nor a dvArray with one single item,
    // it wil return the default value
    class procedure GetSingleOrDefault(const docVariantArray, default: variant;
      var result: variant);

    /// finalize the stored information
    destructor Destroy; override;
    /// used by dvoInternNames for string interning of all Names[] values
    function InternNames: TRawUTF8Interning; {$ifdef HASINLINE}inline;{$endif}
    /// used by dvoInternValues for string interning of all RawUTF8 Values[]
    function InternValues: TRawUTF8Interning; {$ifdef HASINLINE}inline;{$endif}
    // this implementation will write the content as JSON object or array
    procedure ToJSON(W: TTextWriter; const Value: variant; Escape: TTextWriterKind); override;
    /// will check if the value is an array, and return the number of items
    // - if the document is an array, will return the items count (0 meaning
    // void array) - used e.g. by TSynMustacheContextVariant
    // - this overridden method will implement it for dvArray instance kind
    function IterateCount(const V: TVarData): integer; override;
    /// allow to loop over an array document
    // - Index should be in 0..IterateCount-1 range
    // - this default implementation will do handle dvArray instance kind
    procedure Iterate(var Dest: TVarData; const V: TVarData; Index: integer); override;
    /// low-level callback to access internal pseudo-methods
    // - mainly the _(Index: integer): variant method to retrieve an item
    // if the document is an array
    function DoFunction(var Dest: TVarData; const V: TVarData;
      const Name: string; const Arguments: TVarDataArray): Boolean; override;
    /// low-level callback to clear the content
    procedure Clear(var V: TVarData); override;
    /// low-level callback to copy two variant content
    // - such copy will by default be done by-value, for safety
    // - if you are sure you will use the variants as read-only, you can set
    // the dvoValueCopiedByReference Option to use faster by-reference copy
    procedure Copy(var Dest: TVarData; const Source: TVarData;
      const Indirect: Boolean); override;
    /// copy two variant content by value
    // - overridden method since instance may use a by-reference copy pattern
    procedure CopyByValue(var Dest: TVarData; const Source: TVarData); override;
    /// handle type conversion
    // - only types processed by now are string/OleStr/UnicodeString/date
    procedure Cast(var Dest: TVarData; const Source: TVarData); override;
    /// handle type conversion
    // - only types processed by now are string/OleStr/UnicodeString/date
    procedure CastTo(var Dest: TVarData; const Source: TVarData;
      const AVarType: TVarType); override;
    /// compare two variant values
    // - it uses case-sensitive text comparison of the JSON representation
    // of each variant (including TDocVariant instances)
    procedure Compare(const Left, Right: TVarData;
      var Relationship: TVarCompareResult); override;
  end;

  /// define the TDocVariant storage layout
  // - if it has one or more named properties, it is a dvObject
  // - if it has no name property, it is a dvArray
  TDocVariantKind = (dvUndefined, dvObject, dvArray);

  /// method used by TDocVariantData.ReduceAsArray to filter each object
  // - should return TRUE if the item match the expectations
  TOnReducePerItem = function(Item: PDocVariantData): boolean of object;

  /// method used by TDocVariantData.ReduceAsArray to filter each object
  // - should return TRUE if the item match the expectations
  TOnReducePerValue = function(const Value: variant): boolean of object;

  {$A-} { packet object not allowed since Delphi 2009 :( }
  /// memory structure used for TDocVariant storage of any JSON/BSON
  // document-based content as variant
  // - i.e. name/value pairs for objects, or an array of values (including
  // nested documents)
  // - you can use _Obj()/_ObjFast() _Arr()/_ArrFast() _Json()/_JsonFast() or
  // _JsonFmt()/_JsonFastFmt() functions to create instances of such variants
  // - you can transtype such an allocated variant into TDocVariantData
  // to access directly its internals (like Count or Values[]/Names[]):
  // ! aVariantObject := TDocVariant.NewObject(['name','John','year',1972]);
  // ! aVariantObject := _ObjFast(['name','John','year',1972]);
  // ! with _Safe(aVariantObject)^ do
  // !   for i := 0 to Count-1 do
  // !     writeln(Names[i],'=',Values[i]); // for an object
  // ! aVariantArray := TDocVariant.NewArray(['one',2,3.0]);
  // ! aVariantArray := _JsonFast('["one",2,3.0]');
  // ! with _Safe(aVariantArray)^ do
  // !   for i := 0 to Count-1 do
  // !     writeln(Values[i]); // for an array
  // - use "with _Safe(...)^ do"  and not "with TDocVariantData(...) do" as the
  // former will handle internal variant redirection (varByRef), e.g. from late
  // binding or assigned another TDocVariant
  // - Delphi "object" is buggy on stack -> also defined as record with methods
  {$ifdef USERECORDWITHMETHODS}
  TDocVariantData = record
  {$else}
  TDocVariantData = object
  {$endif USERECORDWITHMETHODS}
  private
    VType: TVarType;
    VOptions: TDocVariantOptions;
    (* this structure uses all TVarData available space: no filler needed!
    {$HINTS OFF} // does not complain if Filler is declared but never used
    Filler: array[1..SizeOf(TVarData)-SizeOf(TVarType)-SizeOf(TDocVariantOptions)-
      SizeOf(TDocVariantKind)-SizeOf(TRawUTF8DynArray)-SizeOf(TVariantDynArray)-
      SizeOf(integer)] of byte;
    {$HINTS ON} *)
    VName: TRawUTF8DynArray;
    VValue: TVariantDynArray;
    VCount: integer;
    // retrieve the value as varByRef
    function GetValueOrItem(const aNameOrIndex: variant): variant;
    procedure SetValueOrItem(const aNameOrIndex, aValue: variant);
    function GetKind: TDocVariantKind; {$ifdef HASINLINE}inline;{$endif}
    procedure SetOptions(const opt: TDocVariantOptions); // keep dvoIsObject/Array
      {$ifdef HASINLINE}inline;{$endif}
    procedure SetCapacity(aValue: integer);
    function GetCapacity: integer;
      {$ifdef HASINLINE}inline;{$endif}
    // implement U[] I[] B[] D[] O[] O_[] A[] A_[] _[] properties
    function GetOrAddIndexByName(const aName: RawUTF8): integer;
      {$ifdef HASINLINE}inline;{$endif}
    function GetOrAddPVariantByName(const aName: RawUTF8): PVariant;
      {$ifdef HASINLINE}inline;{$endif}
    function GetPVariantByName(const aName: RawUTF8): PVariant;
    function GetRawUTF8ByName(const aName: RawUTF8): RawUTF8;
    procedure SetRawUTF8ByName(const aName, aValue: RawUTF8);
    function GetStringByName(const aName: RawUTF8): string;
    procedure SetStringByName(const aName: RawUTF8; const aValue: string);
    function GetInt64ByName(const aName: RawUTF8): Int64;
    procedure SetInt64ByName(const aName: RawUTF8; const aValue: Int64);
    function GetBooleanByName(const aName: RawUTF8): Boolean;
    procedure SetBooleanByName(const aName: RawUTF8; aValue: Boolean);
    function GetDoubleByName(const aName: RawUTF8): Double;
    procedure SetDoubleByName(const aName: RawUTF8; const aValue: Double);
    function GetDocVariantExistingByName(const aName: RawUTF8;
      aNotMatchingKind: TDocVariantKind): PDocVariantData;
    function GetObjectExistingByName(const aName: RawUTF8): PDocVariantData;
    function GetDocVariantOrAddByName(const aName: RawUTF8;
      aKind: TDocVariantKind): PDocVariantData;
    function GetObjectOrAddByName(const aName: RawUTF8): PDocVariantData;
    function GetArrayExistingByName(const aName: RawUTF8): PDocVariantData;
    function GetArrayOrAddByName(const aName: RawUTF8): PDocVariantData;
    function GetAsDocVariantByIndex(aIndex: integer): PDocVariantData;
    procedure ClearFast;
  public
    /// initialize a TDocVariantData to store some document-based content
    // - can be used with a stack-allocated TDocVariantData variable:
    // !var Doc: TDocVariantData; // stack-allocated variable
    // !begin
    // !  Doc.Init;
    // !  Doc.AddValue('name','John');
    // !  assert(Doc.Value['name']='John');
    // !  assert(variant(Doc).name='John');
    // !end;
    // - if you call Init*() methods in a row, ensure you call Clear in-between
    procedure Init(aOptions: TDocVariantOptions = []; aKind: TDocVariantKind = dvUndefined);
    /// initialize a TDocVariantData to store per-reference document-based content
    // - same as Doc.Init(JSON_OPTIONS[true]);
    // - can be used with a stack-allocated TDocVariantData variable:
    // !var Doc: TDocVariantData; // stack-allocated variable
    // !begin
    // !  Doc.InitFast;
    // !  Doc.AddValue('name','John');
    // !  assert(Doc.Value['name']='John');
    // !  assert(variant(Doc).name='John');
    // !end;
    // - see also TDocVariant.NewFast() if you want to initialize several
    // TDocVariantData variable instances at once
    // - if you call Init*() methods in a row, ensure you call Clear in-between
    procedure InitFast; overload;
    /// initialize a TDocVariantData to store per-reference document-based content
    // - this overloaded method allows to specify an estimation of how many
    // properties or items this aKind document would contain
    procedure InitFast(InitialCapacity: integer; aKind: TDocVariantKind); overload;
    /// initialize a TDocVariantData to store document-based object content
    // - object will be initialized with data supplied two by two, as Name,Value
    // pairs, e.g.
    // !var Doc: TDocVariantData; // stack-allocated variable
    // !begin
    // !  Doc.InitObject(['name','John','year',1972]);
    // which is the same as:
    // ! var Doc: TDocVariantData;
    // !begin
    // !  Doc.Init;
    // !  Doc.AddValue('name','John');
    // !  Doc.AddValue('year',1972);
    // - this method is called e.g. by _Obj() and _ObjFast() global functions
    // - if you call Init*() methods in a row, ensure you call Clear in-between
    procedure InitObject(const NameValuePairs: array of const;
      aOptions: TDocVariantOptions = []);
    /// initialize a variant instance to store some document-based array content
    // - array will be initialized with data supplied as parameters, e.g.
    // !var Doc: TDocVariantData; // stack-allocated variable
    // !begin
    // !  Doc.InitArray(['one',2,3.0]);
    // !  assert(Doc.Count=3);
    // !end;
    // which is the same as:
    // ! var Doc: TDocVariantData;
    // !     i: integer;
    // !begin
    // !  Doc.Init;
    // !  Doc.AddItem('one');
    // !  Doc.AddItem(2);
    // !  Doc.AddItem(3.0);
    // !  assert(Doc.Count=3);
    // !  for i := 0 to Doc.Count-1 do
    // !    writeln(Doc.Value[i]);
    // !end;
    // - this method is called e.g. by _Arr() and _ArrFast() global functions
    // - if you call Init*() methods in a row, ensure you call Clear in-between
    procedure InitArray(const Items: array of const;
      aOptions: TDocVariantOptions = []);
    /// initialize a variant instance to store some document-based array content
    // - array will be initialized with data supplied as variant dynamic array
    // - if Items is [], the variant will be set as null
    // - will be almost immediate, since TVariantDynArray is reference-counted,
    // unless ItemsCopiedByReference is set to FALSE
    // - if you call Init*() methods in a row, ensure you call Clear in-between
    procedure InitArrayFromVariants(const Items: TVariantDynArray;
      aOptions: TDocVariantOptions = []; ItemsCopiedByReference: boolean = true);
    /// initialize a variant instance to store some RawUTF8 array content
    procedure InitArrayFrom(const Items: TRawUTF8DynArray; aOptions: TDocVariantOptions); overload;
    /// initialize a variant instance to store some 32-bit integer array content
    procedure InitArrayFrom(const Items: TIntegerDynArray; aOptions: TDocVariantOptions); overload;
    /// initialize a variant instance to store some 64-bit integer array content
    procedure InitArrayFrom(const Items: TInt64DynArray; aOptions: TDocVariantOptions); overload;
    /// initialize a variant instance to store a T*ObjArray content
    // - will call internally ObjectToVariant() to make the conversion
    procedure InitArrayFromObjArray(const ObjArray; aOptions: TDocVariantOptions;
      aWriterOptions: TTextWriterWriteObjectOptions = [woDontStoreDefault]);
    /// initialize a variant instance to store some document-based object content
    // - object will be initialized with names and values supplied as dynamic arrays
    // - if aNames and aValues are [] or do have matching sizes, the variant
    // will be set as null
    // - will be almost immediate, since Names and Values are reference-counted
    // - if you call Init*() methods in a row, ensure you call Clear in-between
    procedure InitObjectFromVariants(const aNames: TRawUTF8DynArray;
       const aValues: TVariantDynArray; aOptions: TDocVariantOptions = []);
    /// initialize a variant instance to store a document-based object with a
    // single property
    // - the supplied path could be 'Main.Second.Third', to create nested
    // objects, e.g. {"Main":{"Second":{"Third":value}}}
    // - if you call Init*() methods in a row, ensure you call Clear in-between
    procedure InitObjectFromPath(const aPath: RawUTF8; const aValue: variant;
      aOptions: TDocVariantOptions = []);
    /// initialize a variant instance to store some document-based object content
    // from a supplied JSON array or JSON object content
    // - warning: the incoming JSON buffer will be modified in-place: so you should
    // make a private copy before running this method, e.g. using TSynTempBuffer
    // - this method is called e.g. by _JsonFmt() _JsonFastFmt() global functions
    // with a temporary JSON buffer content created from a set of parameters
    // - if you call Init*() methods in a row, ensure you call Clear in-between
    function InitJSONInPlace(JSON: PUTF8Char;
      aOptions: TDocVariantOptions = []; aEndOfObject: PUTF8Char = nil): PUTF8Char;
    /// initialize a variant instance to store some document-based object content
    // from a supplied JSON array of JSON object content
    // - a private copy of the incoming JSON buffer will be used, then
    // it will call the other overloaded InitJSONInPlace() method
    // - this method is called e.g. by _Json() and _JsonFast() global functions
    // - if you call Init*() methods in a row, ensure you call Clear in-between
    function InitJSON(const JSON: RawUTF8; aOptions: TDocVariantOptions = []): boolean;
    /// ensure a document-based variant instance will have one unique options set
    // - this will create a copy of the supplied TDocVariant instance, forcing
    // all nested events to have the same set of Options
    // - you can use this function to ensure that all internal properties of this
    // variant will be copied e.g. per-reference (if you set JSON_OPTIONS[false])
    // or per-value (if you set JSON_OPTIONS[false]) whatever options the nested
    // objects or arrays were created with
    // - will raise an EDocVariant if the supplied variant is not a TDocVariant
    // - you may rather use _Unique() or _UniqueFast() wrappers if you want to
    // ensure that a TDocVariant instance is unique
    // - if you call Init*() methods in a row, ensure you call Clear in-between
    procedure InitCopy(const SourceDocVariant: variant; aOptions: TDocVariantOptions);
    /// initialize a variant instance to store some document-based object content
    // from a supplied CSV UTF-8 encoded text
    // - the supplied content may have been generated by ToTextPairs() method
    // - if ItemSep=#10, then any kind of line feed (CRLF or LF) will be handled
    // - if you call Init*() methods in a row, ensure you call Clear in-between
    procedure InitCSV(CSV: PUTF8Char; aOptions: TDocVariantOptions;
      NameValueSep: AnsiChar = '='; ItemSep: AnsiChar = #10; DoTrim: boolean = true); overload;
    /// initialize a variant instance to store some document-based object content
    // from a supplied CSV UTF-8 encoded text
    // - the supplied content may have been generated by ToTextPairs() method
    // - if ItemSep = #10, then any kind of line feed (CRLF or LF) will be handled
    // - if you call Init*() methods in a row, ensure you call Clear in-between
    procedure InitCSV(const CSV: RawUTF8; aOptions: TDocVariantOptions;
      NameValueSep: AnsiChar = '='; ItemSep: AnsiChar = #10; DoTrim: boolean = true); overload;
      {$ifdef HASINLINE}inline;{$endif}

    /// to be called before any Init*() method call, when a previous Init*()
    // has already be performed on the same instance, to avoid memory leaks
    // - for instance:
    // !var Doc: TDocVariantData; // stack-allocated variable
    // !begin
    // !  Doc.InitArray(['one',2,3.0]); // no need of any Doc.Clear here
    // !  assert(Doc.Count=3);
    // !  Doc.Clear; // to release memory before following InitObject()
    // !  Doc.InitObject(['name','John','year',1972]);
    // !end;
    // - will check the VType, and call ClearFast private method
    procedure Clear;
    /// delete all internal stored values
    // - like Clear + Init() with the same options
    // - will reset Kind to dvUndefined
    procedure Reset;
    /// fill all Values[] with #0, then delete all values
    // - could be used to specifically remove sensitive information from memory
    procedure FillZero;
    /// low-level method to force a number of items
    // - could be used to fast add items to the internal Values[]/Names[] arrays
    // - just set protected VCount field, do not resize the arrays: caller
    // should ensure that Capacity is big enough
    procedure SetCount(aCount: integer); {$ifdef HASINLINE}inline;{$endif}
    /// low-level method called internally to reserve place for new values
    // - returns the index of the newly created item in Values[]/Names[] arrays
    // - you should not have to use it, unless you want to add some items
    // directly within the Values[]/Names[] arrays, using e.g.
    // InitFast(InitialCapacity) to initialize the document
    // - if aName='', append a dvArray item, otherwise append a dvObject field
    // - warning: FPC optimizer is confused by Values[InternalAdd(name)] so
    // you should call InternalAdd() in an explicit previous step
    function InternalAdd(const aName: RawUTF8): integer;

    /// save a document as UTF-8 encoded JSON
    // - will write either a JSON object or array, depending of the internal
    // layout of this instance (i.e. Kind property value)
    // - will write  'null'  if Kind is dvUndefined
    // - implemented as just a wrapper around VariantSaveJSON()
    function ToJSON(const Prefix: RawUTF8 = ''; const Suffix: RawUTF8 = '';
      Format: TTextWriterJSONFormat = jsonCompact): RawUTF8;
    /// save an array of objects as UTF-8 encoded non expanded layout JSON
    // - returned content would be a JSON object in mORMot's TSQLTable non
    // expanded format, with reduced JSON size, i.e.
    // $ {"fieldCount":3,"values":["ID","FirstName","LastName",...']}
    // - will write '' if Kind is dvUndefined or dvObject
    // - will raise an exception if the array document is not an array of
    // objects with identical field names
    function ToNonExpandedJSON: RawUTF8;
    /// save a document as an array of UTF-8 encoded JSON
    // - will expect the document to be a dvArray - otherwise, will raise a
    // EDocVariant exception
    // - will use VariantToUTF8() to populate the result array: as a consequence,
    // any nested custom variant types (e.g. TDocVariant) will be stored as JSON
    procedure ToRawUTF8DynArray(out Result: TRawUTF8DynArray); overload;
    /// save a document as an array of UTF-8 encoded JSON
    // - will expect the document to be a dvArray - otherwise, will raise a
    // EDocVariant exception
    // - will use VariantToUTF8() to populate the result array: as a consequence,
    // any nested custom variant types (e.g. TDocVariant) will be stored as JSON
    function ToRawUTF8DynArray: TRawUTF8DynArray; overload;
      {$ifdef HASINLINE}inline;{$endif}
    /// save a document as an CSV of UTF-8 encoded JSON
    // - will expect the document to be a dvArray - otherwise, will raise a
    // EDocVariant exception
    // - will use VariantToUTF8() to populate the result array: as a consequence,
    // any nested custom variant types (e.g. TDocVariant) will be stored as JSON
    function ToCSV(const Separator: RawUTF8 = ','): RawUTF8;
    /// save a document as UTF-8 encoded Name=Value pairs
    // - will follow by default the .INI format, but you can specify your
    // own expected layout
    procedure ToTextPairsVar(out result: RawUTF8; const NameValueSep: RawUTF8 = '=';
      const ItemSep: RawUTF8 = #13#10; Escape: TTextWriterKind = twJSONEscape);
    /// save a document as UTF-8 encoded Name=Value pairs
    // - will follow by default the .INI format, but you can specify your
    // own expected layout
    function ToTextPairs(const NameValueSep: RawUTF8 = '=';
      const ItemSep: RawUTF8 = #13#10; Escape: TTextWriterKind = twJSONEscape): RawUTF8;
      {$ifdef HASINLINE}inline;{$endif}
    /// save an array document as an array of TVarRec, i.e. an array of const
    // - will expect the document to be a dvArray - otherwise, will raise a
    // EDocVariant exception
    // - would allow to write code as such:
    // !  Doc.InitArray(['one',2,3]);
    // !  Doc.ToArrayOfConst(vr);
    // !  s := FormatUTF8('[%,%,%]',vr,[],true);
    // !  // here s='[one,2,3]') since % would be replaced by Args[] parameters
    // !  s := FormatUTF8('[?,?,?]',[],vr,true);
    // !  // here s='["one",2,3]') since ? would be escaped by Params[] parameters
    procedure ToArrayOfConst(out Result: TTVarRecDynArray); overload;
    /// save an array document as an array of TVarRec, i.e. an array of const
    // - will expect the document to be a dvArray - otherwise, will raise a
    // EDocVariant exception
    // - would allow to write code as such:
    // !  Doc.InitArray(['one',2,3]);
    // !  s := FormatUTF8('[%,%,%]',Doc.ToArrayOfConst,[],true);
    // !  // here s='[one,2,3]') since % would be replaced by Args[] parameters
    // !  s := FormatUTF8('[?,?,?]',[],Doc.ToArrayOfConst,true);
    // !  // here s='["one",2,3]') since ? would be escaped by Params[] parameters
    function ToArrayOfConst: TTVarRecDynArray; overload;
      {$ifdef HASINLINE}inline;{$endif}
    /// save an object document as an URI-encoded list of parameters
    // - object field names should be plain ASCII-7 RFC compatible identifiers
    // (0..9a..zA..Z_.~), otherwise their values are skipped
    function ToUrlEncode(const UriRoot: RawUTF8): RawUTF8;

    /// find an item index in this document from its name
    // - search will follow dvoNameCaseSensitive option of this document
    // - lookup the value by name for an object document, or accept an integer
    // text as index for an array document
    // - returns -1 if not found
    function GetValueIndex(const aName: RawUTF8): integer; overload;
      {$ifdef HASINLINE}inline;{$endif}
    /// find an item index in this document from its name
    // - lookup the value by name for an object document, or accept an integer
    // text as index for an array document
    // - returns -1 if not found
    function GetValueIndex(aName: PUTF8Char; aNameLen: PtrInt; aCaseSensitive: boolean): integer; overload;
    /// find an item in this document, and returns its value
    // - raise an EDocVariant if not found and dvoReturnNullForUnknownProperty
    // is not set in Options (in this case, it will return Null)
    function GetValueOrRaiseException(const aName: RawUTF8): variant;
    /// find an item in this document, and returns its value
    // - return the supplied default if aName is not found, or if the instance
    // is not a TDocVariant
    function GetValueOrDefault(const aName: RawUTF8; const aDefault: variant): variant;
    /// find an item in this document, and returns its value
    // - return null if aName is not found, or if the instance is not a TDocVariant
    function GetValueOrNull(const aName: RawUTF8): variant;
    /// find an item in this document, and returns its value
    // - return a cleared variant if aName is not found, or if the instance is
    // not a TDocVariant
    function GetValueOrEmpty(const aName: RawUTF8): variant;
    /// find an item in this document, and returns its value as enumerate
    // - return false if aName is not found, if the instance is not a TDocVariant,
    // or if the value is not a string corresponding to the supplied enumerate
    // - return true if the name has been found, and aValue stores the value
    // - will call Delete() on the found entry, if aDeleteFoundEntry is true
    function GetValueEnumerate(const aName: RawUTF8; aTypeInfo: pointer;
      out aValue; aDeleteFoundEntry: boolean = false): Boolean;
    /// returns a TDocVariant object containing all properties matching the
    // first characters of the supplied property name
    // - returns null if the document is not a dvObject
    // - will use IdemPChar(), so search would be case-insensitive
    function GetValuesByStartName(const aStartName: RawUTF8;
      TrimLeftStartName: boolean = false): variant;
    /// returns a JSON object containing all properties matching the
    // first characters of the supplied property name
    // - returns null if the document is not a dvObject
    // - will use IdemPChar(), so search would be case-insensitive
    function GetJsonByStartName(const aStartName: RawUTF8): RawUTF8;
    /// find an item in this document, and returns its value as TVarData
    // - return false if aName is not found, or if the instance is not a TDocVariant
    // - return true and set aValue if the name has been found
    // - will use simple loop lookup to identify the name, unless aSortedCompare is
    // set, and would let use a faster O(log(n)) binary search after a SortByName()
    function GetVarData(const aName: RawUTF8; var aValue: TVarData;
      aSortedCompare: TUTF8Compare = nil): boolean; overload;
      {$ifdef HASINLINE}inline;{$endif}
    /// find an item in this document, and returns its value as TVarData pointer
    // - return nil if aName is not found, or if the instance is not a TDocVariant
    // - return a pointer to the value if the name has been found
    // - after a SortByName(aSortedCompare), could use faster binary search
    function GetVarData(const aName: RawUTF8;
      aSortedCompare: TUTF8Compare = nil): PVarData; overload;
    /// find an item in this document, and returns its value as boolean
    // - return false if aName is not found, or if the instance is not a TDocVariant
    // - return true if the name has been found, and aValue stores the value
    // - after a SortByName(aSortedCompare), could use faster binary search
    // - consider using B[] property if you want simple read/write typed access
    function GetAsBoolean(const aName: RawUTF8; out aValue: boolean;
      aSortedCompare: TUTF8Compare = nil): Boolean;
    /// find an item in this document, and returns its value as integer
    // - return false if aName is not found, or if the instance is not a TDocVariant
    // - return true if the name has been found, and aValue stores the value
    // - after a SortByName(aSortedCompare), could use faster binary search
    // - consider using I[] property if you want simple read/write typed access
    function GetAsInteger(const aName: RawUTF8; out aValue: integer;
      aSortedCompare: TUTF8Compare = nil): Boolean;
    /// find an item in this document, and returns its value as integer
    // - return false if aName is not found, or if the instance is not a TDocVariant
    // - return true if the name has been found, and aValue stores the value
    // - after a SortByName(aSortedCompare), could use faster binary search
    // - consider using I[] property if you want simple read/write typed access
    function GetAsInt64(const aName: RawUTF8; out aValue: Int64;
      aSortedCompare: TUTF8Compare = nil): Boolean;
    /// find an item in this document, and returns its value as floating point
    // - return false if aName is not found, or if the instance is not a TDocVariant
    // - return true if the name has been found, and aValue stores the value
    // - after a SortByName(aSortedCompare), could use faster binary search
    // - consider using D[] property if you want simple read/write typed access
    function GetAsDouble(const aName: RawUTF8; out aValue: double;
      aSortedCompare: TUTF8Compare = nil): Boolean;
    /// find an item in this document, and returns its value as RawUTF8
    // - return false if aName is not found, or if the instance is not a TDocVariant
    // - return true if the name has been found, and aValue stores the value
    // - after a SortByName(aSortedCompare), could use faster binary search
    // - consider using U[] property if you want simple read/write typed access
    function GetAsRawUTF8(const aName: RawUTF8; out aValue: RawUTF8;
      aSortedCompare: TUTF8Compare = nil): Boolean;
    /// find an item in this document, and returns its value as a TDocVariantData
    // - return false if aName is not found, or if the instance is not a TDocVariant
    // - return true if the name has been found and points to a TDocVariant:
    // then aValue stores a pointer to the value
    // - after a SortByName(aSortedCompare), could use faster binary search
    function GetAsDocVariant(const aName: RawUTF8; out aValue: PDocVariantData;
      aSortedCompare: TUTF8Compare = nil): boolean; overload;
    /// find an item in this document, and returns its value as a TDocVariantData
    // - returns a void TDocVariant if aName is not a document
    // - after a SortByName(aSortedCompare), could use faster binary search
    // - consider using O[] or A[] properties if you want simple read-only
    // access, or O_[] or A_[] properties if you want the ability to add
    // a missing object or array in the document
    function GetAsDocVariantSafe(const aName: RawUTF8;
      aSortedCompare: TUTF8Compare = nil): PDocVariantData;
    /// find an item in this document, and returns pointer to its value
    // - return false if aName is not found
    // - return true if the name has been found: then aValue stores a pointer
    // to the value
    // - after a SortByName(aSortedCompare), could use faster binary search
    function GetAsPVariant(const aName: RawUTF8; out aValue: PVariant;
      aSortedCompare: TUTF8Compare = nil): boolean; overload; {$ifdef HASINLINE}inline;{$endif}
    /// find an item in this document, and returns pointer to its value
    // - lookup the value by aName/aNameLen for an object document, or accept
    // an integer text as index for an array document
    // - return nil if aName is not found, or if the instance is not a TDocVariant
    // - return a pointer to the stored variant, if the name has been found
    function GetAsPVariant(aName: PUTF8Char; aNameLen: PtrInt): PVariant; overload;
      {$ifdef HASINLINE}inline;{$endif}
    /// retrieve a value, given its path
    // - path is defined as a dotted name-space, e.g. 'doc.glossary.title'
    // - it will return Unassigned if the path does match the supplied aPath
    function GetValueByPath(const aPath: RawUTF8): variant; overload;
    /// retrieve a value, given its path
    // - path is defined as a dotted name-space, e.g. 'doc.glossary.title'
    // - it will return FALSE if the path does not match the supplied aPath
    // - returns TRUE and set the found value in aValue
    function GetValueByPath(const aPath: RawUTF8; out aValue: variant): boolean; overload;
    /// retrieve a value, given its path
    // - path is defined as a list of names, e.g. ['doc','glossary','title']
    // - it will return Unassigned if the path does not match the data
    // - this method will only handle nested TDocVariant values: use the
    // slightly slower GetValueByPath() overloaded method, if any nested object
    // may be of another type (e.g. a TBSONVariant)
    function GetValueByPath(const aDocVariantPath: array of RawUTF8): variant; overload;
    /// retrieve a reference to a value, given its path
    // - path is defined as a dotted name-space, e.g. 'doc.glossary.title'
    // - if the supplied aPath does not match any object, it will return nil
    // - if aPath is found, returns a pointer to the corresponding value
    function GetPVariantByPath(const aPath: RawUTF8): PVariant;
    /// retrieve a reference to a TDocVariant, given its path
    // - path is defined as a dotted name-space, e.g. 'doc.glossary.title'
    // - if the supplied aPath does not match any object, it will return false
    // - if aPath stores a valid TDocVariant, returns true and a pointer to it
    function GetDocVariantByPath(const aPath: RawUTF8; out aValue: PDocVariantData): boolean;
    /// retrieve a dvObject in the dvArray, from a property value
    // - {aPropName:aPropValue} will be searched within the stored array,
    // and the corresponding item will be copied into Dest, on match
    // - returns FALSE if no match is found, TRUE if found and copied
    // - create a copy of the variant by default, unless DestByRef is TRUE
    // - will call VariantEquals() for value comparison
    function GetItemByProp(const aPropName,aPropValue: RawUTF8;
      aPropValueCaseSensitive: boolean; var Dest: variant; DestByRef: boolean = false): boolean;
    /// retrieve a reference to a dvObject in the dvArray, from a property value
    // - {aPropName:aPropValue} will be searched within the stored array,
    // and the corresponding item will be copied into Dest, on match
    // - returns FALSE if no match is found, TRUE if found and copied by reference
    function GetDocVariantByProp(const aPropName,aPropValue: RawUTF8;
      aPropValueCaseSensitive: boolean; out Dest: PDocVariantData): boolean;
    /// find an item in this document, and returns its value
    // - raise an EDocVariant if not found and dvoReturnNullForUnknownProperty
    // is not set in Options (in this case, it will return Null)
    // - create a copy of the variant by default, unless DestByRef is TRUE
    function RetrieveValueOrRaiseException(aName: PUTF8Char; aNameLen: integer;
      aCaseSensitive: boolean; var Dest: variant; DestByRef: boolean): boolean; overload;
    /// retrieve an item in this document from its index, and returns its value
    // - raise an EDocVariant if the supplied Index is not in the 0..Count-1
    // range and dvoReturnNullForUnknownProperty is set in Options
    // - create a copy of the variant by default, unless DestByRef is TRUE
    procedure RetrieveValueOrRaiseException(Index: integer;
     var Dest: variant; DestByRef: boolean); overload;
    /// retrieve an item in this document from its index, and returns its Name
    // - raise an EDocVariant if the supplied Index is not in the 0..Count-1
    // range and dvoReturnNullForUnknownProperty is set in Options
    procedure RetrieveNameOrRaiseException(Index: integer; var Dest: RawUTF8);
    /// set an item in this document from its index
    // - raise an EDocVariant if the supplied Index is not in 0..Count-1 range
    procedure SetValueOrRaiseException(Index: integer; const NewValue: variant);

    /// add a value in this document
    // - if aName is set, if dvoCheckForDuplicatedNames option is set, any
    // existing duplicated aName will raise an EDocVariant; if instance's
    // kind is dvArray and aName is defined, it will raise an EDocVariant
    // - aName may be '' e.g. if you want to store an array: in this case,
    // dvoCheckForDuplicatedNames option should not be set; if instance's Kind
    // is dvObject, it will raise an EDocVariant exception
    // - if aValueOwned is true, then the supplied aValue will be assigned to
    // the internal values - by default, it will use SetVariantByValue()
    // - you can therefore write e.g.:
    // ! TDocVariant.New(aVariant);
    // ! Assert(TDocVariantData(aVariant).Kind=dvUndefined);
    // ! TDocVariantData(aVariant).AddValue('name','John');
    // ! Assert(TDocVariantData(aVariant).Kind=dvObject);
    // - returns the index of the corresponding newly added value
    function AddValue(const aName: RawUTF8; const aValue: variant;
      aValueOwned: boolean = false): integer; overload;
    /// add a value in this document
    // - overloaded function accepting a UTF-8 encoded buffer for the name
    function AddValue(aName: PUTF8Char; aNameLen: integer; const aValue: variant;
      aValueOwned: boolean = false): integer; overload;
    /// add a value in this document, or update an existing entry
    // - if instance's Kind is dvArray, it will raise an EDocVariant exception
    // - any existing Name would be updated with the new Value, unless
    // OnlyAddMissing is set to TRUE, in which case existing values would remain
    // - returns the index of the corresponding value, which may be just added
    function AddOrUpdateValue(const aName: RawUTF8; const aValue: variant;
      wasAdded: PBoolean = nil; OnlyAddMissing: boolean = false): integer;
    /// add a value in this document, from its text representation
    // - this function expects a UTF-8 text for the value, which would be
    // converted to a variant number, if possible (as varInt/varInt64/varCurrency
    // and/or as varDouble is AllowVarDouble is set)
    // - if Update=TRUE, will set the property, even if it is existing
    function AddValueFromText(const aName,aValue: RawUTF8; Update: boolean = false;
      AllowVarDouble: boolean = false): integer;
    /// add some properties to a TDocVariantData dvObject
    // - data is supplied two by two, as Name,Value pairs
    // - caller should ensure that Kind=dvObject, otherwise it won't do anything
    // - any existing Name would be duplicated
    procedure AddNameValuesToObject(const NameValuePairs: array of const);
    /// merge some properties to a TDocVariantData dvObject
    // - data is supplied two by two, as Name,Value pairs
    // - caller should ensure that Kind=dvObject, otherwise it won't do anything
    // - any existing Name would be updated with the new Value
    procedure AddOrUpdateNameValuesToObject(const NameValuePairs: array of const);
    /// merge some TDocVariantData dvObject properties to a TDocVariantData dvObject
    // - data is supplied two by two, as Name,Value pairs
    // - caller should ensure that both variants have Kind=dvObject, otherwise
    // it won't do anything
    // - any existing Name would be updated with the new Value, unless
    // OnlyAddMissing is set to TRUE, in which case existing values would remain
    procedure AddOrUpdateObject(const NewValues: variant; OnlyAddMissing: boolean = false;
      RecursiveUpdate: boolean = false);
    /// add a value to this document, handled as array
    // - if instance's Kind is dvObject, it will raise an EDocVariant exception
    // - you can therefore write e.g.:
    // ! TDocVariant.New(aVariant);
    // ! Assert(TDocVariantData(aVariant).Kind=dvUndefined);
    // ! TDocVariantData(aVariant).AddItem('one');
    // ! Assert(TDocVariantData(aVariant).Kind=dvArray);
    // - returns the index of the corresponding newly added item
    function AddItem(const aValue: variant): integer;
    /// add a value to this document, handled as array, from its text representation
    // - this function expects a UTF-8 text for the value, which would be
    // converted to a variant number, if possible (as varInt/varInt64/varCurrency
    // unless AllowVarDouble is set)
    // - if instance's Kind is dvObject, it will raise an EDocVariant exception
    // - returns the index of the corresponding newly added item
    function AddItemFromText(const aValue: RawUTF8;
      AllowVarDouble: boolean = false): integer;
    /// add a RawUTF8 value to this document, handled as array
    // - if instance's Kind is dvObject, it will raise an EDocVariant exception
    // - returns the index of the corresponding newly added item
    function AddItemText(const aValue: RawUTF8): integer;
    /// add one or several values to this document, handled as array
    // - if instance's Kind is dvObject, it will raise an EDocVariant exception
    procedure AddItems(const aValue: array of const);
    /// add one or several values from another document
    // - supplied document should be of the same kind than the current one,
    // otherwise nothing is added
    procedure AddFrom(const aDocVariant: Variant);
    /// add or update or on several valeus from another object
    // - current document should be an object
    procedure AddOrUpdateFrom(const aDocVariant: Variant; aOnlyAddMissing: boolean = false);
    /// add one or several properties, specified by path, from another object
    // - path are defined as a dotted name-space, e.g. 'doc.glossary.title'
    // - matching values would be added as root values, with the path as name
    // - instance and supplied aSource should be a dvObject
    procedure AddByPath(const aSource: TDocVariantData; const aPaths: array of RawUTF8);
    /// delete a value/item in this document, from its index
    // - return TRUE on success, FALSE if the supplied index is not correct
    function Delete(Index: integer): boolean; overload;
    /// delete a value/item in this document, from its name
    // - return TRUE on success, FALSE if the supplied name does not exist
    function Delete(const aName: RawUTF8): boolean; overload;
    /// delete a value in this document, by property name match
    // - {aPropName:aPropValue} will be searched within the stored array or
    // object, and the corresponding item will be deleted, on match
    // - returns FALSE if no match is found, TRUE if found and deleted
    // - will call VariantEquals() for value comparison
    function DeleteByProp(const aPropName,aPropValue: RawUTF8;
      aPropValueCaseSensitive: boolean): boolean;
    /// delete one or several value/item in this document, from its value
    // - returns the number of deleted items
    // - returns 0 if the document is not a dvObject, or if no match was found
    // - if the value exists several times, all occurences would be removed
    // - is optimized for DeleteByValue(null) call
    function DeleteByValue(const aValue: Variant; CaseInsensitive: boolean = false): integer;
    /// delete all values matching the first characters of a property name
    // - returns the number of deleted items
    // - returns 0 if the document is not a dvObject, or if no match was found
    // - will use IdemPChar(), so search would be case-insensitive
    function DeleteByStartName(aStartName: PUTF8Char; aStartNameLen: integer): integer;
    /// search a property match in this document, handled as array or object
    // - {aPropName:aPropValue} will be searched within the stored array or
    // object, and the corresponding item index will be returned, on match
    // - returns -1 if no match is found
    // - will call VariantEquals() for value comparison
    function SearchItemByProp(const aPropName,aPropValue: RawUTF8;
      aPropValueCaseSensitive: boolean): integer; overload;
    /// search a property match in this document, handled as array or object
    // - {aPropName:aPropValue} will be searched within the stored array or
    // object, and the corresponding item index will be returned, on match
    // - returns -1 if no match is found
    // - will call VariantEquals() for value comparison
    function SearchItemByProp(const aPropNameFmt: RawUTF8; const aPropNameArgs: array of const;
      const aPropValue: RawUTF8; aPropValueCaseSensitive: boolean): integer; overload;
    /// search a value in this document, handled as array
    // - aValue will be searched within the stored array
    // and the corresponding item index will be returned, on match
    // - returns -1 if no match is found
    // - you could make several searches, using the StartIndex optional parameter
    function SearchItemByValue(const aValue: Variant;
      CaseInsensitive: boolean = false; StartIndex: PtrInt = 0): PtrInt;
    /// sort the document object values by name
    // - do nothing if the document is not a dvObject
    // - will follow case-insensitive order (@StrIComp) by default, but you
    // can specify @StrComp as comparer function for case-sensitive ordering
    // - once sorted, you can use GetVarData(..,Compare) or GetAs*(..,Compare)
    // methods for much faster O(log(n)) binary search
    procedure SortByName(Compare: TUTF8Compare = nil);
    /// sort the document object values by value
    // - work for both dvObject and dvArray documents
    // - will sort by UTF-8 text (VariantCompare) if no custom aCompare is supplied
    procedure SortByValue(Compare: TVariantCompare = nil);
    /// sort the document array values by a field of some stored objet values
    // - do nothing if the document is not a dvArray, or if the items are no dvObject
    // - will sort by UTF-8 text (VariantCompare) if no custom aValueCompare is supplied
    procedure SortArrayByField(const aItemPropName: RawUTF8;
      aValueCompare: TVariantCompare = nil; aValueCompareReverse: boolean = false;
      aNameSortedCompare: TUTF8Compare = nil);
    /// create a TDocVariant object, from a selection of properties of this
    // document, by property name
    // - if the document is a dvObject, to reduction will be applied to all
    // its properties
    // - if the document is a dvArray, the reduction will be applied to each
    // stored item, if it is a document
    procedure Reduce(const aPropNames: array of RawUTF8; aCaseSensitive: boolean;
      out result: TDocVariantData; aDoNotAddVoidProp: boolean = false); overload;
    /// create a TDocVariant object, from a selection of properties of this
    // document, by property name
    // - always returns a TDocVariantData, even if no property name did match
    // (in this case, it is dvUndefined)
    function Reduce(const aPropNames: array of RawUTF8; aCaseSensitive: boolean;
      aDoNotAddVoidProp: boolean = false): variant; overload;
    /// create a TDocVariant array, from the values of a single properties of
    // this document, specified by name
    // - you can optionally apply an additional filter to each reduced item
    procedure ReduceAsArray(const aPropName: RawUTF8; out result: TDocVariantData;
      OnReduce: TOnReducePerItem = nil); overload;
    /// create a TDocVariant array, from the values of a single properties of
    // this document, specified by name
    // - always returns a TDocVariantData, even if no property name did match
    // (in this case, it is dvUndefined)
    // - you can optionally apply an additional filter to each reduced item
    function ReduceAsArray(const aPropName: RawUTF8; OnReduce: TOnReducePerItem = nil): variant; overload;
    /// create a TDocVariant array, from the values of a single properties of
    // this document, specified by name
    // - this overloaded method accepts an additional filter to each reduced item
    procedure ReduceAsArray(const aPropName: RawUTF8; out result: TDocVariantData;
      OnReduce: TOnReducePerValue); overload;
    /// create a TDocVariant array, from the values of a single properties of
    // this document, specified by name
    // - always returns a TDocVariantData, even if no property name did match
    // (in this case, it is dvUndefined)
    // - this overloaded method accepts an additional filter to each reduced item
    function ReduceAsArray(const aPropName: RawUTF8; OnReduce: TOnReducePerValue): variant; overload;
    /// rename some properties of a TDocVariant object
    // - returns the number of property names modified
    function Rename(const aFromPropName, aToPropName: TRawUTF8DynArray): integer;
    /// map {"obj.prop1"..,"obj.prop2":..} into {"obj":{"prop1":..,"prop2":...}}
    // - the supplied aObjectPropName should match the incoming dotted value
    // of all properties (e.g. 'obj' for "obj.prop1")
    // - if any of the incoming property is not of "obj.prop#" form, the
    // whole process would be ignored
    // - return FALSE if the TDocVariant did not change
    // - return TRUE if the TDocVariant has been flattened
    function FlattenAsNestedObject(const aObjectPropName: RawUTF8): boolean;

    /// how this document will behave
    // - those options are set when creating the instance
    // - dvoArray and dvoObject are not options, but define the document Kind,
    // so those items are ignored when assigned to this property
    property Options: TDocVariantOptions read VOptions write SetOptions;
    /// returns the document internal layout
    // - just after initialization, it will return dvUndefined
    // - most of the time, you will add named values with AddValue() or by
    // setting the variant properties: it will return dvObject
    // - but is you use AddItem(), values will have no associated names: the
    // document will be a dvArray
    // - value computed from the dvoArray and dvoObject presence in Options
    property Kind: TDocVariantKind read GetKind;
    /// return the custom variant type identifier, i.e. DocVariantType.VarType
    property VarType: word read VType;
    /// number of items stored in this document
    // - is 0 if Kind=dvUndefined
    // - is the number of name/value pairs for Kind=dvObject
    // - is the number of items for Kind=dvArray
    property Count: integer read VCount;
    /// the current capacity of this document
    // - allow direct access to VValue[] length
    property Capacity: integer read GetCapacity write SetCapacity;
    /// direct acces to the low-level internal array of values
    // - transtyping a variant and direct access to TDocVariantData is the
    // fastest way of accessing all properties of a given dvObject:
    // ! with TDocVariantData(aVariantObject) do
    // !   for i := 0 to Count-1 do
    // !     writeln(Names[i],'=',Values[i]);
    // - or to access a dvArray items (e.g. a MongoDB collection):
    // ! with TDocVariantData(aVariantArray) do
    // !   for i := 0 to Count-1 do
    // !     writeln(Values[i]);
    property Values: TVariantDynArray read VValue;
    /// direct acces to the low-level internal array of names
    // - is void (nil) if Kind is not dvObject
    // - transtyping a variant and direct access to TDocVariantData is the
    // fastest way of accessing all properties of a given dvObject:
    // ! with TDocVariantData(aVariantObject) do
    // !   for i := 0 to Count-1 do
    // !     writeln(Names[i],'=',Values[i]);
    property Names: TRawUTF8DynArray read VName;
    /// find an item in this document, and returns its value
    // - raise an EDocVariant if aNameOrIndex is neither an integer nor a string
    // - raise an EDocVariant if Kind is dvArray and aNameOrIndex is a string
    // or if Kind is dvObject and aNameOrIndex is an integer
    // - raise an EDocVariant if Kind is dvObject and if aNameOrIndex is a
    // string, which is not found within the object property names and
    // dvoReturnNullForUnknownProperty is set in Options
    // - raise an EDocVariant if Kind is dvArray and if aNameOrIndex is a
    // integer, which is not within 0..Count-1 and dvoReturnNullForUnknownProperty
    // is set in Options
    // - so you can use directly:
    // ! // for an array document:
    // ! aVariant := TDocVariant.NewArray(['one',2,3.0]);
    // ! for i := 0 to TDocVariantData(aVariant).Count-1 do
    // !   aValue := TDocVariantData(aVariant).Value[i];
    // ! // for an object document:
    // ! aVariant := TDocVariant.NewObject(['name','John','year',1972]);
    // ! assert(aVariant.Name=TDocVariantData(aVariant)['name']);
    // ! assert(aVariant.year=TDocVariantData(aVariant)['year']);
    // - due to the internal implementation of variant execution (somewhat
    // slow _DispInvoke() function), it is a bit faster to execute:
    // ! aValue := TDocVariantData(aVariant).Value['name'];
    // instead of
    // ! aValue := aVariant.name;
    // but of course, if want to want to access the content by index (typically
    // for a dvArray), using Values[] - and Names[] - properties is much faster
    // than this variant-indexed pseudo-property:
    // ! with TDocVariantData(aVariant) do
    // !   for i := 0 to Count-1 do
    // !     Writeln(Values[i]);
    // is faster than:
    // ! with TDocVariantData(aVariant) do
    // !   for i := 0 to Count-1 do
    // !     Writeln(Value[i]);
    // which is faster than:
    // ! for i := 0 to aVariant.Count-1 do
    // !   Writeln(aVariant._(i));
    // - this property will return the value as varByRef (just like with
    // variant late binding of any TDocVariant instance), so you can write:
    // !var Doc: TDocVariantData; // stack-allocated variable
    // !begin
    // !  Doc.InitJSON('{arr:[1,2]}');
    // !  assert(Doc.Count=2);
    // !  Doc.Value['arr'].Add(3);  // works since Doc.Value['arr'] is varByRef
    // !  writeln(Doc.ToJSON);      // will write '{"arr":[1,2,3]}'
    // !end;
    // - if you want to access a property as a copy, i.e. to assign it to a
    // variant variable which will stay alive after this TDocVariant instance
    // is release, you should not use Value[] but rather
    // GetValueOrRaiseException or GetValueOrNull/GetValueOrEmpty
    // - see U[] I[] B[] D[] O[] O_[] A[] A_[] _[] properties for direct access
    // of strong typed values
    property Value[const aNameOrIndex: Variant]: Variant read GetValueOrItem
      write SetValueOrItem; default;

    /// direct access to a dvObject UTF-8 stored property value from its name
    // - slightly faster than the variant-based Value[] default property
    // - follows dvoNameCaseSensitive and dvoReturnNullForUnknownProperty options
    // - use GetAsRawUTF8() if you want to check the availability of the field
    // - U['prop'] := 'value' would add a new property, or overwrite an existing
    property U[const aName: RawUTF8]: RawUTF8 read GetRawUTF8ByName write SetRawUTF8ByName;
    /// direct string access to a dvObject UTF-8 stored property value from its name
    // - just a wrapper around U[] property, to avoid a compilation warning when
    // using plain string variables (internaly, RawUTF8 will be used for storage)
    // - slightly faster than the variant-based Value[] default property
    // - follows dvoNameCaseSensitive and dvoReturnNullForUnknownProperty options
    // - use GetAsRawUTF8() if you want to check the availability of the field
    // - S['prop'] := 'value' would add a new property, or overwrite an existing
    property S[const aName: RawUTF8]: string read GetStringByName write SetStringByName;
    /// direct access to a dvObject Integer stored property value from its name
    // - slightly faster than the variant-based Value[] default property
    // - follows dvoNameCaseSensitive and dvoReturnNullForUnknownProperty options
    // - use GetAsInt/GetAsInt64 if you want to check the availability of the field
    // - I['prop'] := 123 would add a new property, or overwrite an existing
    property I[const aName: RawUTF8]: Int64 read GetInt64ByName write SetInt64ByName;
    /// direct access to a dvObject Boolean stored property value from its name
    // - slightly faster than the variant-based Value[] default property
    // - follows dvoNameCaseSensitive and dvoReturnNullForUnknownProperty options
    // - use GetAsBoolean if you want to check the availability of the field
    // - B['prop'] := true would add a new property, or overwrite an existing
    property B[const aName: RawUTF8]: Boolean read GetBooleanByName write SetBooleanByName;
    /// direct access to a dvObject floating-point stored property value from its name
    // - slightly faster than the variant-based Value[] default property
    // - follows dvoNameCaseSensitive and dvoReturnNullForUnknownProperty options
    // - use GetAsDouble if you want to check the availability of the field
    // - D['prop'] := 1.23 would add a new property, or overwrite an existing
    property D[const aName: RawUTF8]: Double read GetDoubleByName write SetDoubleByName;
    /// direct access to a dvObject existing dvObject property from its name
    // - follows dvoNameCaseSensitive and dvoReturnNullForUnknownProperty options
    // - O['prop'] would return a fake void TDocVariant if the property is not
    // existing or not a dvObject, just like GetAsDocVariantSafe()
    // - use O_['prop'] to force adding any missing property
    property O[const aName: RawUTF8]: PDocVariantData read GetObjectExistingByName;
    /// direct access or add a dvObject's dvObject property from its name
    // - follows dvoNameCaseSensitive and dvoReturnNullForUnknownProperty options
    // - O_['prop'] would add a new property if there is none existing, or
    // overwrite an existing property which is not a dvObject
    property O_[const aName: RawUTF8]: PDocVariantData read GetObjectOrAddByName;
    /// direct access to a dvObject existing dvArray property from its name
    // - follows dvoNameCaseSensitive and dvoReturnNullForUnknownProperty options
    // - A['prop'] would return a fake void TDocVariant if the property is not
    // existing or not a dvArray, just like GetAsDocVariantSafe()
    // - use A_['prop'] to force adding any missing property
    property A[const aName: RawUTF8]: PDocVariantData read GetArrayExistingByName;
    /// direct access or add a dvObject's dvArray property from its name
    // - follows dvoNameCaseSensitive and dvoReturnNullForUnknownProperty options
    // - A_['prop'] would add a new property if there is none existing, or
    // overwrite an existing property which is not a dvArray
    property A_[const aName: RawUTF8]: PDocVariantData read GetArrayOrAddByName;
    /// direct access to a dvArray's TDocVariant property from its index
    // - simple values may directly use Values[] dynamic array, but to access
    // a TDocVariantData members, this property is safer
    // - follows dvoReturnNullForUnknownProperty option to raise an exception
    // - _[ndx] would return a fake void TDocVariant if aIndex is out of range,
    // if the property is not existing or not a TDocVariantData (just like
    // GetAsDocVariantSafe)
    property _[aIndex: integer]: PDocVariantData read GetAsDocVariantByIndex;
  end;
  {$A+} { packet object not allowed since Delphi 2009 :( }

var
  /// the internal custom variant type used to register TDocVariant
  DocVariantType: TDocVariant;

  /// copy of DocVariantType.VarType
  // - as used by inlined functions of TDocVariantData
  DocVariantVType: cardinal;

/// retrieve the text representation of a TDocVairnatKind
function ToText(kind: TDocVariantKind): PShortString; overload;

/// direct access to a TDocVariantData from a given variant instance
// - return a pointer to the TDocVariantData corresponding to the variant
// instance, which may be of kind varByRef (e.g. when retrieved by late binding)
// - raise an EDocVariant exception if the instance is not a TDocVariant
// - the following direct trans-typing may fail, e.g. for varByRef value:
// ! TDocVariantData(aVarDoc.ArrayProp).Add('new item');
// - so you can write the following:
// ! DocVariantData(aVarDoc.ArrayProp).AddItem('new item');
function DocVariantData(const DocVariant: variant): PDocVariantData;

const
  /// constant used e.g. by _Safe() overloaded functions
  // - will be in code section of the exe, so will be read-only by design
  // - would have Kind=dvUndefined and Count=0, so _Safe() would return
  // a valid, but void document
  // - its VType is varNull, so would be viewed as a null variant
  // - dvoReturnNullForUnknownProperty is defined, so that U[]/I[]... methods
  // won't raise any exception about unexpected field name
  DocVariantDataFake: TDocVariantData = (
    VType: 1; VOptions: [dvoReturnNullForUnknownProperty]{%H-});

/// direct access to a TDocVariantData from a given variant instance
// - return a pointer to the TDocVariantData corresponding to the variant
// instance, which may be of kind varByRef (e.g. when retrieved by late binding)
// - will return a read-only fake TDocVariantData with Kind=dvUndefined if the
// supplied variant is not a TDocVariant instance, so could be safely used
// in a with block (use "with" moderation, of course):
// ! with _Safe(aDocVariant)^ do
// !   for ndx := 0 to Count-1 do // here Count=0 for the "fake" result
// !     writeln(Names[ndx]);
// or excluding the "with" statement, as more readable code:
// ! var dv: PDocVariantData;
// !     ndx: PtrInt;
// ! begin
// !   dv := _Safe(aDocVariant);
// !   for ndx := 0 to dv.Count-1 do // here Count=0 for the "fake" result
// !     writeln(dv.Names[ndx]);
function _Safe(const DocVariant: variant): PDocVariantData; overload;
  {$ifdef FPC}inline;{$endif} // Delphi has problems inlining this :(

/// direct access to a TDocVariantData from a given variant instance
// - return a pointer to the TDocVariantData corresponding to the variant
// instance, which may be of kind varByRef (e.g. when retrieved by late binding)
// - will check the supplied document kind, i.e. either dvObject or dvArray and
// raise a EDocVariant exception if it does not match
function _Safe(const DocVariant: variant; ExpectedKind: TDocVariantKind): PDocVariantData; overload;

/// initialize a variant instance to store some document-based object content
// - object will be initialized with data supplied two by two, as Name,Value
// pairs, e.g.
// ! aVariant := _Obj(['name','John','year',1972]);
// or even with nested objects:
// ! aVariant := _Obj(['name','John','doc',_Obj(['one',1,'two',2.0])]);
// - this global function is an alias to TDocVariant.NewObject()
// - by default, every internal value will be copied, so access of nested
// properties can be slow - if you expect the data to be read-only or not
// propagated into another place, set Options=[dvoValueCopiedByReference]
// or using _ObjFast() will increase the process speed a lot
function _Obj(const NameValuePairs: array of const;
  Options: TDocVariantOptions = []): variant;

/// add some property values to a document-based object content
// - if Obj is a TDocVariant object, will add the Name/Value pairs
// - if Obj is not a TDocVariant, will create a new fast document,
// initialized with supplied the Name/Value pairs
// - this function will also ensure that ensure Obj is not stored by reference,
// but as a true TDocVariantData
procedure _ObjAddProps(const NameValuePairs: array of const; var Obj: variant); overload;

/// add the property values of a document to a document-based object content
// - if Document is not a TDocVariant object, will do nothing
// - if Obj is a TDocVariant object, will add Document fields to its content
// - if Obj is not a TDocVariant object, Document will be copied to Obj
procedure _ObjAddProps(const Document: variant; var Obj: variant); overload;

/// initialize a variant instance to store some document-based array content
// - array will be initialized with data supplied as parameters, e.g.
// ! aVariant := _Arr(['one',2,3.0]);
// - this global function is an alias to TDocVariant.NewArray()
// - by default, every internal value will be copied, so access of nested
// properties can be slow - if you expect the data to be read-only or not
// propagated into another place, set Options = [dvoValueCopiedByReference]
// or using _ArrFast() will increase the process speed a lot
function _Arr(const Items: array of const;
  Options: TDocVariantOptions = []): variant;

/// initialize a variant instance to store some document-based content
// from a supplied (extended) JSON content
// - this global function is an alias to TDocVariant.NewJSON(), and
// will return an Unassigned variant if JSON content was not correctly converted
// - object or array will be initialized from the supplied JSON content, e.g.
// ! aVariant := _Json('{"id":10,"doc":{"name":"John","birthyear":1972}}');
// ! // now you can access to the properties via late binding
// ! assert(aVariant.id=10);
// ! assert(aVariant.doc.name='John');
// ! assert(aVariant.doc.birthYear=1972);
// ! // and also some pseudo-properties:
// ! assert(aVariant._count=2);
// ! assert(aVariant.doc._kind=ord(dvObject));
// ! // or with a JSON array:
// ! aVariant := _Json('["one",2,3]');
// ! assert(aVariant._kind=ord(dvArray));
// ! for i := 0 to aVariant._count-1 do
// !   writeln(aVariant._(i));
// - in addition to the JSON RFC specification strict mode, this method will
// handle some BSON-like extensions, e.g. unquoted field names:
// ! aVariant := _Json('{id:10,doc:{name:"John",birthyear:1972}}');
// - if the mormot.db.nosql.bson unit is used in the application, the MongoDB
// Shell syntax will also be recognized to create TBSONVariant, like
// ! new Date()   ObjectId()   MinKey   MaxKey  /<jRegex>/<jOptions>
// see @http://docs.mongodb.org/manual/reference/mongodb-extended-json
// - by default, every internal value will be copied, so access of nested
// properties can be slow - if you expect the data to be read-only or not
// propagated into another place, add dvoValueCopiedByReference in Options
// will increase the process speed a lot, or use _JsonFast()
function _Json(const JSON: RawUTF8;
  Options: TDocVariantOptions = [dvoReturnNullForUnknownProperty]): variant; overload;
  {$ifdef HASINLINE}inline;{$endif}

/// initialize a variant instance to store some document-based content
// from a supplied (extended) JSON content, with parameters formating
// - wrapper around the _Json(FormatUTF8(...,JSONFormat=true)) function,
// i.e. every Args[] will be inserted for each % and Params[] for each ?,
// with proper JSON escaping of string values, and writing nested _Obj() /
// _Arr() instances as expected JSON objects / arrays
// - typical use (in the context of mormot.db.nosql.bson unit) could be:
// ! aVariant := _JSONFmt('{%:{$in:[?,?]}}',['type'],['food','snack']);
// ! aVariant := _JSONFmt('{type:{$in:?}}',[],[_Arr(['food','snack'])]);
// ! // which are the same as:
// ! aVariant := _JSONFmt('{type:{$in:["food","snack"]}}');
// ! // in this context:
// ! u := VariantSaveJSON(aVariant);
// ! assert(u='{"type":{"$in":["food","snack"]}}');
// ! u := VariantSaveMongoJSON(aVariant,modMongoShell);
// ! assert(u='{type:{$in:["food","snack"]}}');
// - by default, every internal value will be copied, so access of nested
// properties can be slow - if you expect the data to be read-only or not
// propagated into another place, add dvoValueCopiedByReference in Options
// will increase the process speed a lot, or use _JsonFast()
function _JsonFmt(const Format: RawUTF8; const Args, Params: array of const;
  Options: TDocVariantOptions = [dvoReturnNullForUnknownProperty]): variant; overload;

/// initialize a variant instance to store some document-based content
// from a supplied (extended) JSON content, with parameters formating
// - this overload function will set directly a local variant variable,
// and would be used by inlined _JsonFmt/_JsonFastFmt functions
procedure _JsonFmt(const Format: RawUTF8; const Args, Params: array of const;
  Options: TDocVariantOptions; out result: variant); overload;

/// initialize a variant instance to store some document-based content
// from a supplied (extended) JSON content
// - this global function is an alias to TDocVariant.NewJSON(), and
// will return TRUE if JSON content was correctly converted into a variant
// - in addition to the JSON RFC specification strict mode, this method will
// handle some BSON-like extensions, e.g. unquoted field names or ObjectID()
// - by default, every internal value will be copied, so access of nested
// properties can be slow - if you expect the data to be read-only or not
// propagated into another place, add dvoValueCopiedByReference in Options
// will increase the process speed a lot, or use _JsonFast()
function _Json(const JSON: RawUTF8; var Value: variant;
  Options: TDocVariantOptions = [dvoReturnNullForUnknownProperty]): boolean; overload;
  {$ifdef HASINLINE}inline;{$endif}

/// initialize a variant instance to store some document-based object content
// - this global function is an handy alias to:
// ! Obj(NameValuePairs,JSON_OPTIONS[true]);
// - so all created objects and arrays will be handled by reference, for best
// speed - but you should better write on the resulting variant tree with caution
function _ObjFast(const NameValuePairs: array of const): variant; overload;

/// initialize a variant instance to store any object as a TDocVariant
// - is a wrapper around ObjectToVariant(aObject,result,aOptions)
function _ObjFast(aObject: TObject;
   aOptions: TTextWriterWriteObjectOptions = [woDontStoreDefault]): variant; overload;
  {$ifdef HASINLINE}inline;{$endif}

/// initialize a variant instance to store some document-based array content
// - this global function is an handy alias to:
// ! _Array(Items,JSON_OPTIONS[true]);
// - so all created objects and arrays will be handled by reference, for best
// speed - but you should better write on the resulting variant tree with caution
function _ArrFast(const Items: array of const): variant; overload;

/// initialize a variant instance to store some document-based content
// from a supplied (extended) JSON content
// - this global function is an handy alias to:
// ! _Json(JSON,JSON_OPTIONS[true]);
// so it will return an Unassigned variant if JSON content was not correct
// - so all created objects and arrays will be handled by reference, for best
// speed - but you should better write on the resulting variant tree with caution
// - in addition to the JSON RFC specification strict mode, this method will
// handle some BSON-like extensions, e.g. unquoted field names or ObjectID()
function _JsonFast(const JSON: RawUTF8): variant;
  {$ifdef HASINLINE}inline;{$endif}

/// initialize a variant instance to store some extended document-based content
// - this global function is an handy alias to:
// ! _Json(JSON,JSON_OPTIONS_FAST_EXTENDED);
function _JsonFastExt(const JSON: RawUTF8): variant;
  {$ifdef HASINLINE}inline;{$endif}

/// initialize a variant instance to store some document-based content
// from a supplied (extended) JSON content, with parameters formating
// - this global function is an handy alias e.g. to:
// ! aVariant := _JSONFmt('{%:{$in:[?,?]}}',['type'],['food','snack'],JSON_OPTIONS[true]);
// - so all created objects and arrays will be handled by reference, for best
// speed - but you should better write on the resulting variant tree with caution
// - in addition to the JSON RFC specification strict mode, this method will
// handle some BSON-like extensions, e.g. unquoted field names or ObjectID():
function _JsonFastFmt(const Format: RawUTF8; const Args, Params: array of const): variant;

/// ensure a document-based variant instance will have only per-value nested
// objects or array documents
// - is just a wrapper around:
// ! TDocVariantData(DocVariant).InitCopy(DocVariant,JSON_OPTIONS[false])
// - you can use this function to ensure that all internal properties of this
// variant will be copied per-value whatever options the nested objects or
// arrays were created with
// - for huge document with a big depth of nested objects or arrays, a full
// per-value copy may be time and resource consuming, but will be also safe
// - will raise an EDocVariant if the supplied variant is not a TDocVariant or
// a varByRef pointing to a TDocVariant
procedure _Unique(var DocVariant: variant);

/// ensure a document-based variant instance will have only per-value nested
// objects or array documents
// - is just a wrapper around:
// ! TDocVariantData(DocVariant).InitCopy(DocVariant,JSON_OPTIONS[true])
// - you can use this function to ensure that all internal properties of this
// variant will be copied per-reference whatever options the nested objects or
// arrays were created with
// - for huge document with a big depth of nested objects or arrays, it will
// first create a whole copy of the document nodes, but further assignments
// of the resulting value will be per-reference, so will be almost instant
// - will raise an EDocVariant if the supplied variant is not a TDocVariant or
// a varByRef pointing to a TDocVariant
procedure _UniqueFast(var DocVariant: variant);

/// return a full nested copy of a document-based variant instance
// - is just a wrapper around:
// ! TDocVariant.NewUnique(DocVariant,JSON_OPTIONS[false])
// - you can use this function to ensure that all internal properties of this
// variant will be copied per-value whatever options the nested objects or
// arrays were created with: to be used on a value returned as varByRef
// (e.g. by _() pseudo-method)
// - for huge document with a big depth of nested objects or arrays, a full
// per-value copy may be time and resource consuming, but will be also safe -
// consider using _ByRef() instead if a fast copy-by-reference is enough
// - will raise an EDocVariant if the supplied variant is not a TDocVariant or
// a varByRef pointing to a TDocVariant
function _Copy(const DocVariant: variant): variant;
  {$ifdef HASINLINE}inline;{$endif}

/// return a full nested copy of a document-based variant instance
// - is just a wrapper around:
// ! TDocVariant.NewUnique(DocVariant,JSON_OPTIONS[true])
// - you can use this function to ensure that all internal properties of this
// variant will be copied per-value whatever options the nested objects or
// arrays were created with: to be used on a value returned as varByRef
// (e.g. by _() pseudo-method)
// - for huge document with a big depth of nested objects or arrays, a full
// per-value copy may be time and resource consuming, but will be also safe -
// consider using _ByRef() instead if a fast copy-by-reference is enough
// - will raise an EDocVariant if the supplied variant is not a TDocVariant or
// a varByRef pointing to a TDocVariant
function _CopyFast(const DocVariant: variant): variant;
  {$ifdef HASINLINE}inline;{$endif}

/// copy a TDocVariant to another variable, changing the options on the fly
// - note that the content (items or properties) is copied by reference,
// so consider using _Copy() instead if you expect to safely modify its content
// - will return null if the supplied variant is not a TDocVariant
function _ByRef(const DocVariant: variant; Options: TDocVariantOptions): variant; overload;

/// copy a TDocVariant to another variable, changing the options on the fly
// - note that the content (items or properties) is copied by reference,
// so consider using _Copy() instead if you expect to safely modify its content
// - will return null if the supplied variant is not a TDocVariant
procedure _ByRef(const DocVariant: variant; out Dest: variant;
  Options: TDocVariantOptions); overload;

/// convert a TDocVariantData array or a string value into a CSV
// - will call either TDocVariantData.ToCSV, or return the string
// - returns '' if the supplied value is neither a TDocVariant or a string
// - could be used e.g. to store either a JSON CSV string or a JSON array of
// strings in a settings property
function _CSV(const DocVariantOrString: variant): RawUTF8;

/// will convert any TObject into a TDocVariant document instance
// - fast processing function as used by _ObjFast(Value)
// - note that the result variable should already be cleared: no VarClear()
// is done by this function
// - would be used e.g. by VarRecToVariant() function
// - if you expect lazy-loading of a TObject, see TObjectVariant.New()
procedure ObjectToVariant(Value: TObject; var result: variant;
  Options: TTextWriterWriteObjectOptions = [woDontStoreDefault]); overload;

/// will convert any TObject into a TDocVariant document instance
// - convenient overloaded function to include woEnumSetsAsText option
function ObjectToVariant(Value: TObject; EnumSetsAsText: boolean): variant; overload;

/// get the enumeration names corresponding to a set value, as a JSON array
function SetNameToVariant(Value: cardinal; Info: TRttiCustom;
  FullSetsAsStar: boolean = false): variant;

/// fill a class instance from a TDocVariant object document properties
// - returns FALSE if the variant is not a dvObject, TRUE otherwise
function DocVariantToObject(var doc: TDocVariantData; obj: TObject): boolean;

/// fill a T*ObjArray variable from a TDocVariant array document values
// - will always erase the T*ObjArray instance, and fill it from arr values
procedure DocVariantToObjArray(var arr: TDocVariantData; var objArray;
  objClass: TClass);

/// will convert a blank TObject into a TDocVariant document instance
function ObjectDefaultToVariant(aClass: TClass;
  aOptions: TDocVariantOptions): variant; overload;


type
  /// ref-counted interface for thread-safe access to a TDocVariant document
  // - is implemented e.g. by TLockedDocVariant, for IoC/DI resolution
  // - fast and safe storage of any JSON-like object, as property/value pairs,
  // or a JSON-like array, as values
  ILockedDocVariant = interface
    ['{CADC2C20-3F5D-4539-9D23-275E833A86F3}']
    function GetValue(const Name: RawUTF8): Variant;
    procedure SetValue(const Name: RawUTF8; const Value: Variant);
    /// check and return a given property by name
    // - returns TRUE and fill Value with the value associated with the supplied
    // Name, using an internal lock for thread-safety
    // - returns FALSE if the Name was not found, releasing the internal lock:
    // use ExistsOrLock() if you want to add the missing value
    function Exists(const Name: RawUTF8; out Value: Variant): boolean;
    /// check and return a given property by name
    // - returns TRUE and fill Value with the value associated with the supplied
    // Name, using an internal lock for thread-safety
    // - returns FALSE and set the internal lock if Name does not exist:
    // caller should then release the lock via ReplaceAndUnlock()
    function ExistsOrLock(const Name: RawUTF8; out Value: Variant): boolean;
    /// set a value by property name, and set a local copy
    // - could be used as such, for implementing a thread-safe cache:
    // ! if not cache.ExistsOrLock('prop',local) then
    // !   cache.ReplaceAndUnlock('prop',newValue,local);
    // - call of this method should have been precedeed by ExistsOrLock()
    // returning false, i.e. be executed on a locked instance
    procedure ReplaceAndUnlock(const Name: RawUTF8; const Value: Variant;
      out LocalValue: Variant);
    /// add an existing property value to the given TDocVariant document object
    // - returns TRUE and add the Name/Value pair to Obj if Name is existing,
    // using an internal lock for thread-safety
    // - returns FALSE if Name is not existing in the stored document, and
    // lock the internal storage: caller should eventually release the lock
    // via AddNewPropAndUnlock()
    // - could be used as such, for implementing a thread-safe cache:
    // ! if not cache.AddExistingPropOrLock('Articles',Scope) then
    // !   cache.AddNewPropAndUnlock('Articles',GetArticlesFromDB,Scope);
    // here GetArticlesFromDB would occur inside the main lock
    function AddExistingPropOrLock(const Name: RawUTF8; var Obj: variant): boolean;
    /// add a property value to the given TDocVariant document object and
    // to the internal stored document, then release a previous lock
    // - call of this method should have been precedeed by AddExistingPropOrLock()
    // returning false, i.e. be executed on a locked instance
    procedure AddNewPropAndUnlock(const Name: RawUTF8; const Value: variant;
      var Obj: variant);
    /// add an existing property value to the given TDocVariant document object
    // - returns TRUE and add the Name/Value pair to Obj if Name is existing
    // - returns FALSE if Name is not existing in the stored document
    // - this method would use a lock during the Name lookup, but would always
    // release the lock, even if returning FALSE (see AddExistingPropOrLock)
    function AddExistingProp(const Name: RawUTF8; var Obj: variant): boolean;
    /// add a property value to the given TDocVariant document object
    // - this method would not expect the resource to be locked when called,
    // as with AddNewPropAndUnlock
    // - will use the internal lock for thread-safety
    // - if the Name is already existing, would update/change the existing value
    // - could be used as such, for implementing a thread-safe cache:
    // ! if not cache.AddExistingProp('Articles',Scope) then
    // !   cache.AddNewProp('Articles',GetArticlesFromDB,Scope);
    // here GetArticlesFromDB would occur outside the main lock
    procedure AddNewProp(const Name: RawUTF8; const Value: variant;
      var Obj: variant);
    /// append a value to the internal TDocVariant document array
    // - you should not use this method in conjunction with other document-based
    // alternatives, like Exists/AddExistingPropOrLock or AddExistingProp
    procedure AddItem(const Value: variant);
    /// makes a thread-safe copy of the internal TDocVariant document object or array
    function Copy: variant;
    /// delete all stored properties
    procedure Clear;
    /// save the stored values as UTF-8 encoded JSON Object
    function ToJSON(HumanReadable: boolean = false): RawUTF8;
    /// the document fields would be safely accessed via this property
    // - this is the main entry point of this storage
    // - will raise an EDocVariant exception if Name does not exist at reading
    // - implementation class would make a thread-safe copy of the variant value
    property Value[const Name: RawUTF8]: Variant
      read GetValue write SetValue; default;
  end;

  /// allows thread-safe access to a TDocVariant document
  // - this class inherits from TInterfacedObjectWithCustomCreate so you
  // could define one published property of a mORMot.pas' TInjectableObject
  // as ILockedDocVariant so that this class may be automatically injected
  TLockedDocVariant = class(TInterfacedObjectWithCustomCreate, ILockedDocVariant)
  protected
    fValue: TDocVariantData;
    fLock: TAutoLocker;
    function GetValue(const Name: RawUTF8): Variant;
    procedure SetValue(const Name: RawUTF8; const Value: Variant);
  public
    /// initialize the thread-safe document with a fast TDocVariant
    // - i.e. call Create(true) aka Create(JSON_OPTIONS[true])
    // - will be the TInterfacedObjectWithCustomCreate default constructor,
    // called e.g. during IoC/DI resolution
    constructor Create; overload; override;
    /// initialize the thread-safe document storage
    constructor Create(FastStorage: boolean); reintroduce; overload;
    /// initialize the thread-safe document storage with the corresponding options
    constructor Create(options: TDocVariantOptions); reintroduce; overload;
    /// finalize the storage
    destructor Destroy; override;
    /// check and return a given property by name
    function Exists(const Name: RawUTF8; out Value: Variant): boolean;
    /// check and return a given property by name
    // - this version
    function ExistsOrLock(const Name: RawUTF8; out Value: Variant): boolean;
    /// set a value by property name, and set a local copy
    procedure ReplaceAndUnlock(const Name: RawUTF8; const Value: Variant;
      out LocalValue: Variant);
    /// add an existing property value to the given TDocVariant document object
    // - returns TRUE and add the Name/Value pair to Obj if Name is existing
    // - returns FALSE if Name is not existing in the stored document
    function AddExistingPropOrLock(const Name: RawUTF8; var Obj: variant): boolean;
    /// add a property value to the given TDocVariant document object and
    // to the internal stored document
    procedure AddNewPropAndUnlock(const Name: RawUTF8; const Value: variant;
      var Obj: variant);
    /// add an existing property value to the given TDocVariant document object
    // - returns TRUE and add the Name/Value pair to Obj if Name is existing
    // - returns FALSE if Name is not existing in the stored document
    // - this method would use a lock during the Name lookup, but would always
    // release the lock, even if returning FALSE (see AddExistingPropOrLock)
    function AddExistingProp(const Name: RawUTF8; var Obj: variant): boolean;
    /// add a property value to the given TDocVariant document object
    // - this method would not expect the resource to be locked when called,
    // as with AddNewPropAndUnlock
    // - will use the internal lock for thread-safety
    // - if the Name is already existing, would update/change the existing value
    procedure AddNewProp(const Name: RawUTF8; const Value: variant; var Obj: variant);
    /// append a value to the internal TDocVariant document array
    procedure AddItem(const Value: variant);
    /// makes a thread-safe copy of the internal TDocVariant document object or array
    function Copy: variant;
    /// delete all stored properties
    procedure Clear;
    /// save the stored value as UTF-8 encoded JSON Object
    // - implemented as just a wrapper around VariantSaveJSON()
    function ToJSON(HumanReadable: boolean = false): RawUTF8;
    /// the document fields would be safely accessed via this property
    // - will raise an EDocVariant exception if Name does not exist
    // - result variant is returned as a copy, not as varByRef, since a copy
    // will definitively be more thread safe
    property Value[const Name: RawUTF8]: variant
      read GetValue write SetValue; default;
  end;



{ ************** JSON Parsing into Variant }

/// low-level function to set a variant from an unescaped JSON number or string
// - expect the JSON input buffer to be already unescaped, e.g. by GetJSONField()
// - is called e.g. by function VariantLoadJSON()
// - will instantiate either a null, boolean, Integer, Int64, currency, double
// (if AllowDouble is true or dvoAllowDoubleValue is in TryCustomVariants^) or
// string value (as RawUTF8), guessing the best numeric type according to the textual content,
// and string in all other cases, except if TryCustomVariants points to some
// options (e.g. @JSON_OPTIONS[true] for fast instance) and input is a known
// object or array, either encoded as strict-JSON (i.e. {..} or [..]),
// or with some extended (e.g. BSON) syntax
procedure GetVariantFromJSON(JSON: PUTF8Char; wasString: Boolean; var Value: variant;
  TryCustomVariants: PDocVariantOptions = nil; AllowDouble: boolean = false);

/// low-level function to set a variant from an unescaped JSON non string
// - expect the JSON input buffer to be already unescaped, e.g. by GetJSONField(),
// and having returned wasString=TRUE (i.e. not surrounded by double quotes)
// - is called e.g. by function GetVariantFromJSON()
// - will recognize null, boolean, Integer, Int64, currency, double
// (if AllowDouble is true) input, then set Value and return TRUE
// - returns FALSE if the supplied input has no expected JSON format
function GetVariantFromNotStringJSON(JSON: PUTF8Char; var Value: TVarData;
  AllowDouble: boolean): boolean;

/// identify either varInt64, varDouble, varCurrency types following JSON format
// - any non valid number is returned as varString
// - is used e.g. by GetVariantFromJSON() to guess the destination variant type
// - warning: supplied JSON is expected to be not nil
function TextToVariantNumberType(JSON: PUTF8Char): cardinal;

/// identify either varInt64 or varCurrency types following JSON format
// - this version won't return varDouble, i.e. won't handle more than 4 exact
// decimals (as varCurrency), nor scientific notation with exponent (1.314e10)
// - this will ensure that any incoming JSON will converted back with its exact
// textual representation, without digit truncation due to limited precision
// - any non valid number is returned as varString
// - is used e.g. by GetVariantFromJSON() to guess the destination variant type
// - warning: supplied JSON is expected to be not nil
function TextToVariantNumberTypeNoDouble(JSON: PUTF8Char): cardinal;

/// low-level function to set a numerical variant from an unescaped JSON number
// - returns TRUE if TextToVariantNumberType/TextToVariantNumberTypeNoDouble(JSON)
// identified it as a number and set Value to the corresponding content
// - returns FALSE if JSON is a string, or null/true/false
function GetNumericVariantFromJSON(JSON: PUTF8Char; var Value: TVarData;
  AllowVarDouble: boolean): boolean;

 /// return a variant, may be containing a RawUTF8 stored within this class
// - similar to TextToVariant(), but with string interning
// - first try with GetNumericVariantFromJSON(), then fallback to
// RawUTF8ToVariant() with string variable interning
procedure UniqueVariant(Interning: TRawUTF8Interning; var aResult: variant;
  aText: PUTF8Char; aTextLen: PtrInt; aAllowVarDouble: boolean = false); overload;

/// convert the next CSV item from an UTF-8 encoded text buffer
// into a variant number or RawUTF8 varString
// - first try with GetNumericVariantFromJSON(), then fallback to RawUTF8ToVariant
// - is a wrapper around GetNextItem() + TextToVariant()
function GetNextItemToVariant(var P: PUTF8Char; out Value: Variant;
  Sep: AnsiChar = ','; AllowDouble: boolean = true): boolean;

/// retrieve a variant value from a JSON buffer as per RFC 8259, RFC 7159, RFC 7158
// - follows TTextWriter.AddVariant() format (calls GetVariantFromJSON)
// - will instantiate either an Integer, Int64, currency, double or string value
// (as RawUTF8), guessing the best numeric type according to the textual content,
// and string in all other cases, except TryCustomVariants points to some options
// (e.g. @JSON_OPTIONS[true] for fast instance) and input is a known object or
// array, either encoded as strict-JSON (i.e. {..} or [..]), or with some
// extended (e.g. BSON) syntax
// - warning: the JSON buffer will be modified in-place during process - use
// a temporary copy or the overloaded functions with RawUTF8 parameter
// if you need to access it later
procedure JSONToVariantInPlace(var Value: Variant; JSON: PUTF8Char;
  Options: TDocVariantOptions = [dvoReturnNullForUnknownProperty];
  AllowDouble: boolean = false);

/// retrieve a variant value from a JSON UTF-8 text as per RFC 8259, RFC 7159, RFC 7158
// - follows TTextWriter.AddVariant() format (calls GetVariantFromJSON)
// - will instantiate either an Integer, Int64, currency, double or string value
// (as RawUTF8), guessing the best numeric type according to the textual content,
// and string in all other cases, except TryCustomVariants points to some options
// (e.g. @JSON_OPTIONS[true] for fast instance) and input is a known object or
// array, either encoded as strict-JSON (i.e. {..} or [..]), or with some
// extended (e.g. BSON) syntax
// - this overloaded procedure will make a temporary copy before JSON parsing
// and return the variant as result
function JSONToVariant(const JSON: RawUTF8;
  Options: TDocVariantOptions = [dvoReturnNullForUnknownProperty];
  AllowDouble: boolean = false): variant;

/// retrieve a variant value from a JSON number or string
// - follows TTextWriter.AddVariant() format (calls GetVariantFromJSON)
// - will instantiate either an Integer, Int64, currency, double or string value
// (as RawUTF8), guessing the best numeric type according to the textual content,
// and string in all other cases, except TryCustomVariants points to some options
// (e.g. @JSON_OPTIONS[true] for fast instance) and input is a known object or
// array, either encoded as strict-JSON (i.e. {..} or [..]), or with some
// extended (e.g. BSON) syntax
// - warning: the JSON buffer will be modified in-place during process - use
// a temporary copy or the overloaded functions with RawUTF8 parameter
// if you need to access it later
function VariantLoadJSON(var Value: variant; JSON: PUTF8Char;
  EndOfObject: PUTF8Char = nil; TryCustomVariants: PDocVariantOptions = nil;
  AllowDouble: boolean = false): PUTF8Char; overload;

/// retrieve a variant value from a JSON number or string
// - follows TTextWriter.AddVariant() format (calls GetVariantFromJSON)
// - will instantiate either an Integer, Int64, currency, double or string value
// (as RawUTF8), guessing the best numeric type according to the textual content,
// and string in all other cases, except TryCustomVariants points to some options
// (e.g. @JSON_OPTIONS[true] for fast instance) and input is a known object or
// array, either encoded as strict-JSON (i.e. {..} or [..]), or with some
// extended (e.g. BSON) syntax
// - this overloaded procedure will make a temporary copy before JSON parsing
// and return the variant as result
procedure VariantLoadJSON(var Value: Variant; const JSON: RawUTF8;
  TryCustomVariants: PDocVariantOptions = nil; AllowDouble: boolean = false); overload;

/// retrieve a variant value from a JSON number or string
// - follows TTextWriter.AddVariant() format (calls GetVariantFromJSON)
// - will instantiate either an Integer, Int64, currency, double or string value
// (as RawUTF8), guessing the best numeric type according to the textual content,
// and string in all other cases, except TryCustomVariants points to some options
// (e.g. @JSON_OPTIONS[true] for fast instance) and input is a known object or
// array, either encoded as strict-JSON (i.e. {..} or [..]), or with some
// extended (e.g. BSON) syntax
// - this overloaded procedure will make a temporary copy before JSON parsing
// and return the variant as result
function VariantLoadJSON(const JSON: RawUTF8; TryCustomVariants: PDocVariantOptions = nil;
  AllowDouble: boolean = false): variant; overload;


implementation


{ ************** Low-Level Variant Wrappers }

function VarIs(const V: Variant; const VTypes: TVarDataTypes): Boolean;
var
  vd: PVarData;
  vt: cardinal;
begin
  vd := @V;
  repeat
    vt := vd^.VType;
    if vt <> varVariant or varByRef then
      break;
    vd := vd^.VPointer;
    if vd = nil then
    begin
      result := false;
      exit;
    end;
  until false;
  result := vt in VTypes;
end;

function VarIsVoid(const V: Variant): boolean;
var
  vt: cardinal;
begin
  vt := TVarData(V).VType;
  with TVarData(V) do
    case vt of
      varEmpty, varNull:
        result := true;
      varBoolean:
        result := not VBoolean;
      varString, varOleStr {$ifdef HASVARUSTRING}, varUString{$endif}:
        result := VAny = nil;
      varDate:
        result := VInt64 = 0;
    else
      if vt = varVariant or varByRef then
        result := VarIsVoid(PVariant(VPointer)^)
      else if (vt = varByRef or varString) or (vt = varByRef or varOleStr)
      {$ifdef HASVARUSTRING} or (vt = varByRef or varUString) {$endif} then
        result := PPointer(VAny)^ = nil
      else if vt = DocVariantVType then
        result := TDocVariantData(V).Count = 0
      else
        result := false;
    end;
end;

function VarStringOrNull(const v: RawUTF8): variant;
begin
  if v = '' then
    SetVariantNull(result{%H-})
  else
    RawUTF8ToVariant(v, result);
end;

procedure SetVariantByRef(const Source: Variant; var Dest: Variant);
var
  vt: cardinal;
begin
  VarClear(Dest);
  vt := TVarData(Source).VType;
  if ((vt and varByRef) <> 0) or (vt in VTYPE_SIMPLE) then
    TVarData(Dest) := TVarData(Source)
  else if not SetVariantUnRefSimpleValue(Source, TVarData(Dest)) then
  begin
    TVarData(Dest).VType := varVariant or varByRef;
    TVarData(Dest).VPointer := @Source;
  end;
end;

procedure SetVariantByValue(const Source: Variant; var Dest: Variant);
var
  s: PVarData;
  d: TVarData absolute Dest;
  vt: cardinal;
begin
  s := @Source;
  VarClear(Dest);
  vt := s^.VType;
  if vt = varVariant or varByRef then
  begin
    s := s^.VPointer;
    vt := s^.VType;
  end;
  case vt of
    varEmpty..varDate, varBoolean, varShortInt..varWord64:
      begin
        d.VType := vt;
        d.VInt64 := s^.VInt64;
      end;
    varString:
      begin
        d.VType := varString;
        d.VAny := nil;
        RawByteString(d.VAny) := RawByteString(s^.VAny);
      end;
    varByRef or varString:
      begin
        d.VType := varString;
        d.VAny := nil;
        RawByteString(d.VAny) := PRawByteString(s^.VAny)^;
      end;
    {$ifdef HASVARUSTRING} varUString, varByRef or varUString, {$endif}
    varOleStr, varByRef or varOleStr:
      begin
        d.VType := varString;
        d.VAny := nil;
        VariantToUTF8(PVariant(s)^, RawUTF8(d.VAny)); // store a RawUTF8 instance
      end;
  else
    if not SetVariantUnRefSimpleValue(PVariant(s)^, d) then
      if vt = DocVariantVType then
        DocVariantType.CopyByValue(d, s^)
      else
        Dest := PVariant(s)^;
  end;
end;

procedure ZeroFill(Value: PVarData);
begin // slightly faster than FillChar(Value,SizeOf(Value),0);
  PInt64Array(Value)^[0] := 0;
  PInt64Array(Value)^[1] := 0;
  {$ifdef CPU64}
  PInt64Array(Value)^[2] := 0;
  {$endif}
end;

procedure FillZero(var value: variant);
begin
  if TVarData(value).VType = varString then
    FillZero(RawByteString(TVarData(value).VAny));
  VarClear(value);
end;

procedure _VariantClearSeveral(V: PVarData; n: integer);
var
  vt, docv: cardinal;
  handler: TCustomVariantType;
  clearproc: procedure(V: PVarData);
label
  clr, hdr;
begin
  handler := nil;
  docv := DocVariantVType;
  clearproc := @VarClearProc;
  repeat
    vt := V^.VType;
    if vt <= varWord64 then
    begin
      if (vt >= varOleStr) and (vt <= varError) then
        if vt = varOleStr then
          WideString(V^.VAny) := ''
        else
          goto clr; // varError, varDispatch
    end
    else if vt = varString then
      {$ifdef FPC}
      Finalize(RawUTF8(V^.VAny))
      {$else}
      RawUTF8(V^.VAny) := ''
      {$endif}
    else if vt < varByRef then // varByRef has no refcount -> nothing to clear
      if vt = docv then
        PDocVariantData(V)^.ClearFast
      {$ifdef HASVARUSTRING}
      else if vt = varUString then
        UnicodeString(V^.VAny) := ''
      {$endif HASVARUSTRING}
      else if vt >= varArray then // custom types are below varArray
clr:    clearproc(V)
      else if handler = nil then
        if FindCustomVariantType(vt, handler) then
hdr:      handler.Clear(V^)
        else
          goto clr
      else if vt = handler.VarType then
        goto hdr
      else
        goto clr;
    PInteger(V)^ := 0; // set VType=varEmpty
    inc(V);
    dec(n);
  until n = 0;
end;

procedure FormatUTF8ToVariant(const Fmt: RawUTF8; const Args: array of const; var Value: variant);
begin
  RawUTF8ToVariant(FormatUTF8(Fmt, Args), Value);
end;

procedure RawUTF8ToVariant(const Txt: RawUTF8; var Value: TVarData; ExpectedValueType: cardinal);
begin
  if ExpectedValueType = varString then
  begin
    RawUTF8ToVariant(Txt,variant(Value));
    exit;
  end;
  VarClear(variant(Value));
  Value.VType := ExpectedValueType;
  Value.VAny := nil; // avoid GPF below
  if Txt <> '' then
    case ExpectedValueType of
      varOleStr:
        UTF8ToWideString(Txt, WideString(Value.VAny));
      {$ifdef HASVARUSTRING}
      varUString:
        UTF8DecodeToUnicodeString(pointer(Txt), length(Txt), UnicodeString(Value.VAny));
      {$endif}
    else
      raise ESynVariant.CreateUTF8('RawUTF8ToVariant(%)?', [ExpectedValueType]);
    end;
end;

function VariantToString(const V: Variant): string;
var
  wasString: boolean;
  tmp: RawUTF8;
  vt: cardinal;
begin
  vt := TVarData(V).VType;
  with TVarData(V) do
    case vt of
      varEmpty, varNull:
        result := ''; // default VariantToUTF8(null)='null'
      {$ifdef UNICODE} // not HASVARUSTRING: here we handle string=UnicodeString
      varUString:
        result := UnicodeString(VAny);
      else
        if vt = varByRef or varUString then
          result := PUnicodeString(VAny)^
      {$endif}
      else
      begin
        VariantToUTF8(V, tmp, wasString);
        if tmp = '' then
          result := ''
        else
          UTF8DecodeToString(pointer(tmp), length(tmp), result);
      end;
    end;
end;

procedure VariantToVarRec(const V: variant; var result: TVarRec);
begin
  result.VType := vtVariant;
  if TVarData(V).VType = varByRef or varVariant then
    result.VVariant := TVarData(V).VPointer
  else
    result.VVariant := @V;
end;

function VarRecToVariant(const V: TVarRec): variant;
begin
  VarRecToVariant(V, result);
end;

procedure VarRecToVariant(const V: TVarRec; var result: variant);
begin
  VarClear(result{%H-});
  with TVarData(result) do
    case V.VType of
      vtPointer:
        VType := varNull;
      vtBoolean:
        begin
          VType := varBoolean;
          VBoolean := V.VBoolean;
        end;
      vtInteger:
        begin
          VType := varInteger;
          VInteger := V.VInteger;
        end;
      vtInt64:
        begin
          VType := varInt64;
          VInt64 := V.VInt64^;
        end;
      {$ifdef FPC}
      vtQWord:
        begin
          VType := varWord64;
          VQWord := V.VQWord^;
        end;
      {$endif}
      vtCurrency:
        begin
          VType := varCurrency;
          VInt64 := PInt64(@V.VCurrency)^;
        end;
      vtExtended:
        begin
          VType := varDouble;
          VDouble := V.VExtended^;
        end;
      vtVariant:
        begin
          VType := varVariant or varByRef;
          VAny := V.VVariant;
        end;
      vtAnsiString:
        begin
          VType := varString or varByRef;
          VString := V.VAnsiString;
        end;
      vtWideString:
        begin
          VType := varOleStr or varByRef;
          VString := V.VWideString;
        end;
      {$ifdef HASVARUSTRING}
      vtUnicodeString:
        begin
          VType := varUString or varByRef;
          VString := V.VUnicodeString;
        end;
      {$endif}
      vtString, vtPChar, vtChar, vtWideChar, vtClass:
        begin
          VType := varString;
          VString := nil; // avoid GPF on next line
          VarRecToUTF8(V, RawUTF8(VString)); // return as new RawUTF8 instance
        end;
      vtObject: // class instance will be serialized as a TDocVariant
        ObjectToVariant(V.VObject, result, [woDontStoreDefault]);
    else
      raise ESynVariant.CreateUTF8('Unhandled TVarRec.VType=%', [V.VType]);
    end;
end;

function SortDynArrayVariantCompareAsString(const A, B: variant): integer;
var
  UA, UB: RawUTF8;
  wasString: boolean;
begin
  VariantToUTF8(A, UA, wasString);
  VariantToUTF8(B, UB, wasString);
  result := StrComp(pointer(UA), pointer(UB));
end;

function SortDynArrayVariantCompareAsStringI(const A, B: variant): integer;
var
  UA, UB: RawUTF8;
  wasString: boolean;
begin
  VariantToUTF8(A, UA, wasString);
  VariantToUTF8(B, UB, wasString);
  result := StrIComp(pointer(UA), pointer(UB));
end;

function SortDynArrayZero(const A, B): integer;
begin
  result := 0;
end;

function _SortDynArrayVariantComp(const A, B: TVarData; caseInsensitive: boolean): integer;
type
  TSortDynArrayVariantComp = function(const A, B: variant): integer;
const
  CMP: array[boolean] of TSortDynArrayVariantComp = (
    SortDynArrayVariantCompareAsString, SortDynArrayVariantCompareAsStringI);
  ICMP: array[TVariantRelationship] of integer = (0, -1, 1, 1);
  SORT1: array[varEmpty..varDate] of TDynArraySortCompare = (
    SortDynArrayZero, SortDynArrayZero, SortDynArraySmallInt, SortDynArrayInteger,
    SortDynArraySingle, SortDynArrayDouble, SortDynArrayInt64, SortDynArrayDouble);
  SORT2: array[varShortInt..varWord64] of TDynArraySortCompare = (
    SortDynArrayShortInt, SortDynArrayByte, SortDynArrayWord, SortDynArrayCardinal,
    SortDynArrayInt64, SortDynArrayQWord);
var
  at, bt: cardinal;
begin
  at := cardinal(A.VType);
  bt := cardinal(B.VType);
  if at = varVariant or varByRef then
    result := SortDynArrayVariantComp(PVarData(A.VPointer)^, B, caseInsensitive)
  else if bt = varVariant or varByRef then
    result := SortDynArrayVariantComp(A, PVarData(B.VPointer)^, caseInsensitive)
  else if at = bt then
    case at of // optimized comparison if A and B share the same type
      low(SORT1)..high(SORT1):
        result := SORT1[at](A.VAny, B.VAny);
      low(SORT2)..high(SORT2):
        result := SORT2[at](A.VAny, B.VAny);
      varString: // RawUTF8 most of the time (e.g. from TDocVariant)
        if caseInsensitive then
          result := StrIComp(A.VAny, B.VAny)
        else
          result := StrComp(A.VAny, B.VAny);
      varBoolean:
        if A.VBoolean then // normalize
          if B.VBoolean then
            result := 0
          else
            result := 1
        else if B.VBoolean then
          result := -1
        else
          result := 0;
      varOleStr{$ifdef HASVARUSTRING}, varUString{$endif}:
        if caseInsensitive then
          result := AnsiICompW(A.VAny, B.VAny)
        else
          result := StrCompW(A.VAny, B.VAny);
    else
      if at < varString then
        result := ICMP[VarCompareValue(variant(A), variant(B))]
      else
        result := CMP[caseInsensitive](variant(A), variant(B));
    end
  else if (at <= varNull) or (bt <= varNull) then
    result := ord(at > varNull) - ord(bt > varNull)
  else if (at < varString) and (bt < varString) then
    result := ICMP[VarCompareValue(variant(A), variant(B))]
  else
    result := CMP[caseInsensitive](variant(A), variant(B));
end;

function VariantCompare(const V1, V2: variant): PtrInt;
begin
  result := SortDynArrayVariantComp(TVarData(V1), TVarData(V2), {caseins=}false);
end;

function VariantCompareI(const V1, V2: variant): PtrInt;
begin
  result := SortDynArrayVariantComp(TVarData(V1), TVarData(V2), {caseins=}true);
end;

function VariantEquals(const V: Variant; const Str: RawUTF8;
  CaseSensitive: boolean): boolean;

  function Complex: boolean;
  var
    wasString: boolean;
    tmp: RawUTF8;
  begin
    VariantToUTF8(V, tmp, wasString);
    if CaseSensitive then
      result := (tmp = Str)
    else
      result := IdemPropNameU(tmp, Str);
  end;

var
  v1, v2: Int64;
  vt: cardinal;
begin
  vt := TVarData(V).VType;
  with TVarData(V) do
    case vt of
      varEmpty, varNull:
        result := Str = '';
      varBoolean:
        result := VBoolean = (Str <> '');
      varString:
        if CaseSensitive then
          result := RawUTF8(VString) = Str
        else
          result := IdemPropNameU(RawUTF8(VString), Str);
    else
      if VariantToInt64(V, v1) then
      begin
        SetInt64(pointer(Str), v2);
        result := v1 = v2;
      end
      else
        result := Complex;
    end;
end;


{ ************** Custom Variant Types with JSON support }

procedure GetJSONToAnyVariant(var Value: variant; var JSON: PUTF8Char;
  EndOfObject: PUTF8Char; Options: PDocVariantOptions; AllowDouble: boolean); forward;


var // owned by Variants.pas as TInvokeableVariantType/TCustomVariantType
  SynVariantTypes: array of TSynInvokeableVariantType;

function FindSynVariantTypeFromVType(aVarType: word): TSynInvokeableVariantType;
  {$ifdef HASINLINE} inline;{$endif}
var
  n: integer;
  t: ^TSynInvokeableVariantType;
begin
  if (cardinal(aVarType) > varNativeString) and (cardinal(aVarType) < varArray) then
  begin
    t := pointer(SynVariantTypes);
    if t <> nil then
    begin
      n := PDALen(PAnsiChar(t) - _DALEN)^ + _DAOFF;
      repeat
        result := t^;
        if result.VarType = aVarType then
          exit;
        inc(t);
        dec(n);
      until n = 0;
    end;
  end;
  result := nil;
end;

function SynRegisterCustomVariantType(aClass: TSynInvokeableVariantTypeClass): TSynInvokeableVariantType;
var
  i: PtrInt;
begin
  for i := 0 to length(SynVariantTypes) - 1 do
  begin
    result := SynVariantTypes[i]; // returns already registered instance
    if PPointer(result)^ = pointer(aClass) then
      exit;
  end;
  result := aClass.Create; // register variant type
  ObjArrayAdd(SynVariantTypes, result);
end;


{ TSynInvokeableVariantType }

function TSynInvokeableVariantType.IterateCount(const V: TVarData): integer;
begin
  result := -1; // this is not an array
end;

procedure TSynInvokeableVariantType.Iterate(var Dest: TVarData; const V: TVarData; Index: integer);
begin // do nothing
end;

{$ifdef ISDELPHI}
function TSynInvokeableVariantType.FixupIdent(const AText: string): string;
begin
  result := AText; // NO uppercased identifier for our custom types!
end;
{$endif ISDELPHI}

function TSynInvokeableVariantType.{%H-}IntGet(var Dest: TVarData; const Instance: TVarData; Name: PAnsiChar; NameLen: PtrInt): boolean;
begin
  raise ESynVariant.CreateUTF8('Unexpected %.IntGet(%): this kind of ' +
    'custom variant does not support sub-fields', [self, Name]);
end;

function TSynInvokeableVariantType.{%H-}IntSet(const Instance, Value: TVarData; Name: PAnsiChar; NameLen: PtrInt): boolean;
begin
  raise ESynVariant.CreateUTF8('Unexpected %.IntSet(%): this kind of ' +
    'custom variant is read-only', [self, Name]);
end;

function TSynInvokeableVariantType.GetProperty(var Dest: TVarData; const V: TVarData; const Name: string): Boolean;
{$ifdef UNICODE}
var
  Buf: array[byte] of AnsiChar;
{$endif}
begin
  {$ifdef UNICODE}
  IntGet(Dest, V, Buf, RawUnicodeToUtf8(Buf, SizeOf(Buf), pointer(Name), length(Name), []));
  {$else}
  IntGet(Dest, V, pointer(Name), length(Name));
  {$endif UNICODE}
  result := true; // IntGet=false+Dest=null e.g. if dvoReturnNullForUnknownProperty
end;

{$ifdef FPC_VARIANTSETVAR} // see http://mantis.freepascal.org/view.php?id=26773
function TSynInvokeableVariantType.SetProperty(var V: TVarData; const Name: string;
  const Value: TVarData): Boolean;
{$else}
function TSynInvokeableVariantType.SetProperty(const V: TVarData;
  const Name: string; const Value: TVarData): Boolean;
{$endif FPC_VARIANTSETVAR}
var
  ValueSet: TVarData;
  PropName: PAnsiChar;
  Unicode: pointer;
  PropNameLen, UnicodeLen: PtrInt;
  vt: cardinal;
{$ifdef UNICODE}
  Buf: array[byte] of AnsiChar; // to avoid heap allocation
{$endif}
begin
{$ifdef UNICODE}
  PropNameLen := RawUnicodeToUtf8(Buf, SizeOf(Buf), pointer(Name), length(Name), []);
  PropName := @Buf[0];
{$else}
  PropName := pointer(Name);
  PropNameLen := length(Name);
{$endif UNICODE}
  vt := Value.VType;
  if vt = varByRef or varOleStr then
  begin
    Unicode := PPointer(Value.VAny)^;
    UnicodeLen := length(WideString(Unicode));
  end
  else if vt = varOleStr then
  begin
    Unicode := Value.VAny;
    UnicodeLen := length(WideString(Unicode));
  end
  else
  {$ifdef HASVARUSTRING}
  if vt = varByRef or varUString then
  begin
    Unicode := PPointer(Value.VAny)^;
    UnicodeLen := length(UnicodeString(Unicode));
  end
  else if vt = varUString then
  begin
    Unicode := Value.VAny;
    UnicodeLen := length(UnicodeString(Unicode));
  end
  else
  {$endif HASVARUSTRING}
  if SetVariantUnRefSimpleValue(variant(Value), ValueSet) then
  begin
    result := IntSet(V, ValueSet, PropName, PropNameLen);
    exit;
  end
  else
  begin
    result := IntSet(V, Value, PropName, PropNameLen);
    exit;
  end;
  try // unpatched RTL does not like Unicode values :( -> use a temp RawUTF8
    ValueSet.VType := varString;
    ValueSet.VString := nil; // to avoid GPF in next line
    RawUnicodeToUtf8(Unicode, UnicodeLen, RawUTF8(ValueSet.VString));
    result := IntSet(V, ValueSet, PropName, PropNameLen);
  finally
    RawUTF8(ValueSet.VString) := ''; // avoid memory leak
  end;
end;

procedure TSynInvokeableVariantType.Clear(var V: TVarData);
begin
  ZeroFill(@V); // will set V.VType := varEmpty
end;

procedure TSynInvokeableVariantType.Copy(var Dest: TVarData; const Source: TVarData;
  const Indirect: Boolean);
begin
  if Indirect then
    SimplisticCopy(Dest, Source, true)
  else
  begin
    VarClear(variant(Dest)); // Dest may be a complex type
    Dest := Source;
  end;
end;

procedure TSynInvokeableVariantType.CopyByValue(var Dest: TVarData; const Source: TVarData);
begin
  Copy(Dest, Source, false);
end;

function TSynInvokeableVariantType.TryJSONToVariant(var JSON: PUTF8Char;
  var Value: variant; EndOfObject: PUTF8Char): boolean;
begin
  result := false;
end;

procedure TSynInvokeableVariantType.ToJSON(W: TTextWriter; const Value: variant;
  Escape: TTextWriterKind);
begin
  raise ESynVariant.CreateUTF8('%.ToJSON is not implemented', [self]);
end;

function TSynInvokeableVariantType.IsOfType(const V: variant): boolean;
var
  vt: cardinal;
  vd: PVarData;
{%H-}begin
  if self <> nil then
  begin
    vd := @V;
    repeat
      vt := vd^.VType;
      if vt <> varByRef or varVariant then
        break;
      vd := vd^.VPointer;
    until false;
    result := vt = VarType;
  end
  else
    result := false;
end;

function TSynInvokeableVariantType.FindSynVariantType(aVarType: Word;
  out CustomType: TSynInvokeableVariantType): boolean;
begin
  if aVarType = VarType then
    CustomType := self
  else
    CustomType := FindSynVariantTypeFromVType(VarType);
  result := CustomType <> nil;
end;

procedure TSynInvokeableVariantType.Lookup(var Dest: TVarData;
  const Instance: TVarData; FullName: PUTF8Char);
var
  handler: TSynInvokeableVariantType;
  v, tmp: TVarData; // PVarData wouldn't store e.g. RowID/count
  vt: cardinal;
  itemName: ShortString;
begin
  PInteger(@Dest)^ := varEmpty; // left to Unassigned if not found
  v := Instance;
  repeat
    vt := v.VType;
    if vt <> varByRef or varVariant then
      break;
    v := PVarData(v.VPointer)^;
  until false;
  repeat
    if vt <= varNativeString then
      exit; // we need a complex type to lookup
    GetNextItemShortString(FullName, itemName, '.');
    if itemName[0] in [#0, #255] then
      exit;
    itemName[ord(itemName[0]) + 1] := #0; // ensure is ASCIIZ
    if vt = VarType then
      handler := self
    else
    begin
      handler := FindSynVariantTypeFromVType(vt);
      if handler = nil then
        exit;
    end;
    tmp := v; // v will be modified in-place
    PInteger(@v)^ := varEmpty; // IntGet() would clear it otherwise!
    if not handler.IntGet(v, tmp, @itemName[1], ord(itemName[0])) then
      exit; // property not found
    repeat
      vt := v.VType;
      if vt <> varByRef or varVariant then
        break;
      v := PVarData(v.VPointer)^;
    until false;
    if (vt = DocVariantVType) and (TDocVariantData(v).VCount=0) then
      v.VType := varNull; // recognize void TDocVariant as null
  until FullName = nil;
  Dest := v;
end;

function CustomVariantToJSON(W: TTextWriter; const Value: variant;
  Escape: TTextWriterKind): boolean;
var
  v: TCustomVariantType;
  tmp: variant;
begin
  result := true;
  if FindCustomVariantType(TVarData(Value).VType, v) then
    if v.InheritsFrom(TSynInvokeableVariantType) then
      TSynInvokeableVariantType(v).ToJSON(W, Value, Escape)
    else
      try
        v.CastTo(TVarData(tmp), TVarData(Value), varNativeString);
        W.AddVariant(tmp, Escape);
      except
        result := false;
      end
  else
    result := false;
    //GlobalJSONCustomParsers.VariantWrite(CustomVariantType, W, Value, Escape)
end;



{ TDocVariant }

destructor TDocVariant.Destroy;
begin
  inherited Destroy;
  fInternNames.Free;
  fInternValues.Free;
end;

function IntGetPseudoProp(ndx: integer; const source: TDocVariantData;
  var Dest: variant): boolean;
begin // sub-function to avoid temporary RawUTF8
  result := true;
  case ndx of
    0:
      Dest := source.Count;
    1:
      Dest := ord(source.Kind);
    2:
      RawUTF8ToVariant(source.ToJSON, Dest);
  else
    result := false;
  end;
end;

function TDocVariant.IntGet(var Dest: TVarData; const Instance: TVarData;
  Name: PAnsiChar; NameLen: PtrInt): boolean;
var
  dv: TDocVariantData absolute Instance;
begin
  if Name = nil then
    result := false
  else if (NameLen > 4) and (Name[0] = '_') and IntGetPseudoProp(
      IdemPCharArray(@Name[1], ['COUNT', 'KIND', 'JSON']), dv, variant(Dest)) then
    result := true
  else
    result := dv.RetrieveValueOrRaiseException(pointer(Name), NameLen,
      dvoNameCaseSensitive in dv.VOptions, PVariant(@Dest)^, {byref=}true);
end;

function TDocVariant.IntSet(const Instance, Value: TVarData;
  Name: PAnsiChar; NameLen: PtrInt): boolean;
var
  ndx: Integer;
  aName: RawUTF8;
  dv: TDocVariantData absolute Instance;
begin
  result := true;
  if (dvoIsArray in dv.VOptions) and (PWord(Name)^ = ord('_')) then
  begin
    dv.AddItem(variant(Value));
    exit;
  end;
  ndx := dv.GetValueIndex(pointer(Name), NameLen, dvoNameCaseSensitive in dv.VOptions);
  if ndx < 0 then
  begin
    FastSetString(aName, Name, NameLen);
    ndx := dv.InternalAdd(aName);
  end;
  SetVariantByValue(variant(Value), dv.VValue[ndx]);
  if dvoInternValues in dv.VOptions then
    DocVariantType.InternValues.UniqueVariant(dv.VValue[ndx]);
end;

function TDocVariant.IterateCount(const V: TVarData): integer;
var
  Data: TDocVariantData absolute V;
begin
  if dvoIsArray in Data.VOptions then
    result := Data.VCount
  else
    result := -1;
end;

procedure TDocVariant.Iterate(var Dest: TVarData; const V: TVarData; Index: integer);
var
  Data: TDocVariantData absolute V;
begin
  if (dvoIsArray in Data.VOptions) and (cardinal(Index) < cardinal(Data.VCount)) then
    Dest := TVarData(Data.VValue[Index])
  else
    Dest.VType := varEmpty;
end;

function TDocVariant.DoFunction(var Dest: TVarData; const V: TVarData;
  const Name: string; const Arguments: TVarDataArray): boolean;
var
  ndx: integer;
  Data: PDocVariantData;
  temp: RawUTF8;

  procedure SetTempFromFirstArgument;
  var
    wasString: boolean;
  begin
    VariantToUTF8(variant(Arguments[0]), temp, wasString);
  end;

begin
  result := true;
  Data := @V; // Data=@V is const so should not be modified - works on Delphi
  case length(Arguments) of
    {$ifndef FPC} // Data=@V is read-only on FPC - to avoid random GPF
    0:
      if SameText(Name, 'Clear') then
      begin
        Data^.VCount := 0;
        Data^.VOptions := Data^.VOptions - [dvoIsObject, dvoIsArray];
        exit;
      end;
    {$endif FPC}
    1:
    {$ifndef FPC}
      if SameText(Name, 'Add') then
      begin
        Data^.AddItem(variant(Arguments[0]));
        exit;
      end
      else if SameText(Name, 'Delete') then
      begin
        SetTempFromFirstArgument;
        Data^.Delete(Data^.GetValueIndex(temp{%H-}));
        exit;
      end
      else
    {$endif FPC}
      if SameText(Name, 'Exists') then
      begin
        SetTempFromFirstArgument;
        variant(Dest) := Data^.GetValueIndex(temp{%H-}) >= 0;
        exit;
      end
      else if SameText(Name, 'NameIndex') then
      begin
        SetTempFromFirstArgument;
        variant(Dest) := Data^.GetValueIndex(temp);
        exit;
      end
      else if VariantToInteger(variant(Arguments[0]), ndx) then
      begin
        if (Name = '_') or SameText(Name, 'Value') then
        begin
          Data^.RetrieveValueOrRaiseException(ndx, variant(Dest), true);
          exit;
        end
        else if SameText(Name, 'Name') then
        begin
          Data^.RetrieveNameOrRaiseException(ndx, temp);
          RawUTF8ToVariant(temp, variant(Dest));
          exit;
        end;
      end
      else if (Name = '_') or SameText(Name, 'Value') then
      begin
        SetTempFromFirstArgument;
        Data^.RetrieveValueOrRaiseException(pointer(temp), length(temp),
          dvoNameCaseSensitive in Data^.VOptions, variant(Dest), true);
        exit;
      end;
    {$ifndef FPC}
    2:
      if SameText(Name, 'Add') then
      begin
        SetTempFromFirstArgument;
        Data^.AddValue(temp, variant(Arguments[1]));
        exit;
      end;
    {$endif FPC}
  end;
  result := false;
end;

procedure TDocVariant.ToJSON(W: TTextWriter; const Value: variant;
  escape: TTextWriterKind);
var
  ndx: PtrInt;
  vt: cardinal;
  forced: TTextWriterOptions;
  checkExtendedPropName: boolean;
begin
  vt := TDocVariantData(Value).VType;
  if vt > varNull then
    if vt = DocVariantVType then
      with TDocVariantData(Value) do
        if [dvoIsArray, dvoIsObject] * VOptions = [] then
          W.AddNull
        else
        begin
          forced := [];
          if [twoForceJSONExtended, twoForceJSONStandard] * W.CustomOptions = [] then
          begin
            if dvoSerializeAsExtendedJson in VOptions then
              forced := [twoForceJSONExtended]
            else
              forced := [twoForceJSONStandard];
            W.CustomOptions := W.CustomOptions + forced;
          end;
          if dvoIsObject in VOptions then
          begin
            checkExtendedPropName := twoForceJSONExtended in W.CustomOptions;
            W.Add('{');
            for ndx := 0 to VCount - 1 do
            begin
              if checkExtendedPropName and JsonPropNameValid(pointer(VName[ndx])) then
              begin
                W.AddNoJSONEscape(pointer(VName[ndx]), Length(VName[ndx]));
              end
              else
              begin
                W.Add('"');
                W.AddJSONEscape(pointer(VName[ndx]));
                W.Add('"');
              end;
              W.Add(':');
              W.AddVariant(VValue[ndx], twJSONEscape);
              W.Add(',');
            end;
            W.CancelLastComma;
            W.Add('}');
          end
          else
          begin
            W.Add('[');
            for ndx := 0 to VCount - 1 do
            begin
              W.AddVariant(VValue[ndx], twJSONEscape);
              W.Add(',');
            end;
            W.CancelLastComma;
            W.Add(']');
          end;
          if forced <> [] then
            W.CustomOptions := W.CustomOptions - forced;
        end
    else
      raise EDocVariant.CreateUTF8('Unexpected variant type %', [vt])
  else
    W.AddNull;
end;

procedure TDocVariant.Clear(var V: TVarData);
begin
  //Assert(V.VType=DocVariantVType);
  TDocVariantData(V).ClearFast;
end;

procedure TDocVariant.Copy(var Dest: TVarData; const Source: TVarData;
  const Indirect: Boolean);
begin
  //Assert(Source.VType=DocVariantVType);
  if Indirect then
    SimplisticCopy(Dest, Source, true)
  else if dvoValueCopiedByReference in TDocVariantData(Source).Options then
  begin
    VarClear(variant(Dest)); // Dest may be a complex type
    pointer(TDocVariantData(Dest).VName) := nil;      // avoid GPF
    pointer(TDocVariantData(Dest).VValue) := nil;
    TDocVariantData(Dest) := TDocVariantData(Source); // copy whole record
  end
  else
    CopyByValue(Dest, Source);
end;

procedure TDocVariant.CopyByValue(var Dest: TVarData; const Source: TVarData);
var
  S: TDocVariantData absolute Source;
  D: TDocVariantData absolute Dest;
  i: integer;
begin
  //Assert(Source.VType=DocVariantVType);
  VarClear(variant(Dest)); // Dest may be a complex type
  D.VType := S.VType;
  D.VOptions := S.VOptions; // copies also Kind
  D.VCount := S.VCount;
  pointer(D.VName) := nil; // avoid GPF
  pointer(D.VValue) := nil;
  if S.VCount = 0 then
    exit; // no data to copy
  D.VName := S.VName; // names can always be safely copied
  // slower but safe by-value copy
  SetLength(D.VValue, S.VCount);
  for i := 0 to S.VCount - 1 do
    D.VValue[i] := S.VValue[i];
end;

procedure TDocVariant.Cast(var Dest: TVarData; const Source: TVarData);
begin
  CastTo(Dest, Source, VarType);
end;

procedure TDocVariant.CastTo(var Dest: TVarData; const Source: TVarData;
  const AVarType: TVarType);
var
  Tmp: RawUTF8;
  wasString: boolean;
begin
  if AVarType = VarType then
  begin
    VariantToUTF8(Variant(Source), Tmp, wasString);
    if wasString then
    begin
      VarClear(variant(Dest));
      variant(Dest) := _JSONFast(Tmp); // convert from JSON text
      exit;
    end;
    RaiseCastError;
  end
  else
  begin
    if Source.VType <> VarType then
      RaiseCastError;
    VariantSaveJSON(variant(Source), twJSONEscape, Tmp);
    RawUTF8ToVariant(Tmp, Dest, AVarType); // convert to JSON text
  end;
end;

procedure TDocVariant.Compare(const Left, Right: TVarData;
  var Relationship: TVarCompareResult);
var
  res: integer;
  LeftU, RightU: RawUTF8;
begin
  VariantSaveJSON(variant(Left), twJSONEscape, LeftU);
  VariantSaveJSON(variant(Right), twJSONEscape, RightU);
  if LeftU = RightU then
    Relationship := crEqual
  else
  begin
    res := StrComp(pointer(LeftU), pointer(RightU));
    if res < 0 then
      Relationship := crLessThan
    else if res > 0 then
      Relationship := crGreaterThan
    else
      Relationship := crEqual;
  end;
end;

class procedure TDocVariant.New(out aValue: variant; aOptions: TDocVariantOptions);
begin
  TDocVariantData(aValue).Init(aOptions);
end;

class procedure TDocVariant.NewFast(out aValue: variant);
begin
  TDocVariantData(aValue).InitFast;
end;

class procedure TDocVariant.IsOfTypeOrNewFast(var aValue: variant);
begin
  if DocVariantType.IsOfType(aValue) then
    exit;
  VarClear(aValue);
  TDocVariantData(aValue).InitFast;
end;

class procedure TDocVariant.NewFast(const aValues: array of PDocVariantData);
var
  i: integer;
begin
  for i := 0 to high(aValues) do
    aValues[i]^.InitFast;
end;

class function TDocVariant.New(Options: TDocVariantOptions): Variant;
begin
  VarClear(result{%H-});
  TDocVariantData(result).Init(Options);
end;

class function TDocVariant.NewObject(const NameValuePairs: array of const;
  Options: TDocVariantOptions): variant;
begin
  VarClear(result{%H-});
  TDocVariantData(result).InitObject(NameValuePairs, Options);
end;

class function TDocVariant.NewArray(const Items: array of const;
  Options: TDocVariantOptions): variant;
begin
  VarClear(result{%H-});
  TDocVariantData(result).InitArray(Items, Options);
end;

class function TDocVariant.NewArray(const Items: TVariantDynArray;
  Options: TDocVariantOptions): variant;
begin
  VarClear(result{%H-});
  TDocVariantData(result).InitArrayFromVariants(Items, Options);
end;

class function TDocVariant.NewJSON(const JSON: RawUTF8;
  Options: TDocVariantOptions): variant;
begin
  _Json(JSON, result, Options);
end;

class function TDocVariant.NewUnique(const SourceDocVariant: variant;
  Options: TDocVariantOptions): variant;
begin
  VarClear(result{%H-});
  TDocVariantData(result).InitCopy(SourceDocVariant, Options);
end;

class procedure TDocVariant.GetSingleOrDefault(const docVariantArray,
  default: variant; var result: variant);
var
  vt: cardinal;
begin
  vt := TVarData(docVariantArray).VType;
  if vt = varByRef or varVariant then
    GetSingleOrDefault(
      PVariant(TVarData(docVariantArray).VPointer)^, default, result)
  else if (vt <> DocVariantVType) or
          (TDocVariantData(docVariantArray).Count <> 1) or
          not (dvoIsArray in TDocVariantData(docVariantArray).VOptions) then
    result := default
  else
    result := TDocVariantData(docVariantArray).Values[0];
end;

function DocVariantData(const DocVariant: variant): PDocVariantData;
var
  docv, vt: cardinal;
begin
  result := @DocVariant;
  docv := DocVariantVType;
  vt := result^.VType;
  if vt = docv then
    exit
  else if vt = varByRef or varVariant then
  begin
    result := PVarData(result)^.VPointer;
    if cardinal(result^.VType) = docv then
      exit;
  end;
  raise EDocVariant.CreateUTF8('DocVariantType.Data(%<>TDocVariant)',
    [ord(result^.VType)]);
end;

{$ifdef FPC_OR_UNICODE} // Delphi has problems inlining this :(
function _Safe(const DocVariant: variant): PDocVariantData;
var
  docv, vt: cardinal;
begin
  result := @DocVariant;
  docv := DocVariantVType;
  vt := result^.VType;
  if vt = docv then
    exit
  else if vt = varByRef or varVariant then
  begin
    result := PVarData(result)^.VPointer;
    if cardinal(result^.VType) = docv then
      exit;
  end;
  result := @DocVariantDataFake;
end;
{$else} // fallback for Delphi 7/2007
function _Safe(const DocVariant: variant): PDocVariantData;
asm
        mov     ecx, DocVariantVType
        movzx   edx, word ptr[eax].TVarData.VType
        cmp     edx, ecx
        jne     @by
        ret
@ptr:   mov     eax, [eax].TVarData.VPointer
        movzx   edx, word ptr[eax].TVarData.VType
        cmp     edx, ecx
        je      @ok
@by:    cmp     edx, varByRef OR varVariant
        je      @ptr
        lea     eax, [DocVariantDataFake]
@ok:
end;
{$endif FPC_OR_UNICODE}

function _Safe(const DocVariant: variant;
  ExpectedKind: TDocVariantKind): PDocVariantData;
var
  o: TDocVariantOptions;
begin
  result := _Safe(DocVariant);
  o := result^.VOptions;
  if dvoIsArray in o then
  begin
    if ExpectedKind = dvArray then
      exit;
  end
  else if (dvoIsObject in o) and (ExpectedKind = dvObject) then
    exit;
  raise EDocVariant.CreateUTF8('_Safe(%)?', [ToText(ExpectedKind)^]);
end;

function _CSV(const DocVariantOrString: variant): RawUTF8;
begin
  with _Safe(DocVariantOrString)^ do
    if dvoIsArray in VOptions then
      result := ToCSV
    else if (dvoIsObject in VOptions) or
       (TDocVariantData(DocVariantOrString).VType <= varNull) or
       not VariantToUTF8(DocVariantOrString, result) then
      result := ''; // VariantToUTF8() returns 'null' for empty/null
end;

function ObjectToVariant(Value: TObject; EnumSetsAsText: boolean): variant;
const
  OPTIONS: array[boolean] of TTextWriterWriteObjectOptions = (
     [woDontStoreDefault], [woDontStoreDefault, woEnumSetsAsText]);
begin
  ObjectToVariant(Value, result, OPTIONS[EnumSetsAsText]);
end;

procedure ObjectToVariant(Value: TObject; var result: variant;
  Options: TTextWriterWriteObjectOptions);
var
  json: RawUTF8;
begin
  VarClear(result{%H-});
  json := ObjectToJSON(Value, Options);
  if PDocVariantData(@result)^.InitJSONInPlace(
      pointer(json), JSON_OPTIONS_FAST) = nil then
    VarClear(result);
end;

function SetNameToVariant(Value: cardinal; Info: TRttiCustom;
  FullSetsAsStar: boolean): variant;
var
  j: integer;
  PS: PShortString;
  arr: TDocVariantData;
begin
  arr.InitFast;
  if FullSetsAsStar and GetAllBits(Value, Info.Cache.EnumMax + 1) then
    arr.AddItem('*')
  else
    with Info.Cache do
    begin
      PS := @EnumList;
      for j := EnumInfo.MinValue to EnumMax do begin
        if GetBitPtr(@Value, j) then
          arr.AddItem(PS^);
        inc(PByte(PS), ord(PS^[0]) + 1); // next item
      end;
    end;
  result := variant(arr);
end;

function DocVariantToObject(var doc: TDocVariantData; obj: TObject): boolean;
var
  p: integer;
  props: PRttiCustomProps;
  prop: PRttiCustomProp;
begin
  if (doc.Kind = dvObject) and (doc.Count > 0) and (obj <> nil) then
  begin
    props := @Rtti.RegisterClass(PClass(obj)^).Props;
    for p := 0 to doc.Count - 1 do
    begin
      prop := props.Find(pointer(doc.Names[p]),length(doc.Names[p]));
      if prop <> nil then
        prop^.Prop.SetValue(obj, doc.Values[p]);
    end;
    result := true;
  end
  else
    result := false;
end;

procedure DocVariantToObjArray(var arr: TDocVariantData; var objArray;
  objClass: TClass);
var
  info: TRttiCustom;
  i: integer;
  obj: TObjectDynArray absolute objArray;
begin
  if objClass = nil then
    exit;
  ObjArrayClear(obj);
  if not (dvoIsArray in arr.Options) or (arr.Count = 0) then
    exit;
  info := Rtti.RegisterClass(objClass);
  SetLength(obj, arr.Count);
  for i := 0 to arr.Count - 1 do
  begin
    obj[i] := info.ClassNewInstance;
    DocVariantToObject(_Safe(arr.Values[i])^, obj[i]);
  end;
end;

function ObjectDefaultToVariant(aClass: TClass; aOptions: TDocVariantOptions): variant;
var
  tempvoid: TObject;
  json: RawUTF8;
begin
  VarClear(result);
  tempvoid := Rtti.RegisterClass(aClass).ClassNewInstance;
  try
    json := ObjectToJSON(tempvoid, [woDontStoreDefault]);
    PDocVariantData(@result)^.InitJSONInPlace(pointer(json), aOptions);
  finally
    tempvoid.Free;
  end;
end;


{ TDocVariantData }

function TDocVariantData.GetKind: TDocVariantKind;
var
  opt: TDocVariantOptions;
begin
  opt := VOptions;
  if dvoIsArray in opt then
    result := dvArray
  else if dvoIsObject in opt then
    result := dvObject
  else
    result := dvUndefined;
end;

function TDocVariantData.GetValueIndex(const aName: RawUTF8): integer;
begin
  result := GetValueIndex(Pointer(aName), Length(aName),
    dvoNameCaseSensitive in VOptions);
end;

function TDocVariantData.GetCapacity: integer;
begin
  result := length(VValue);
end;

function TDocVariant.InternNames: TRawUTF8Interning;
begin
  if fInternNames = nil then
    fInternNames := TRawUTF8Interning.Create;
  result := fInternNames;
end;

function TDocVariant.InternValues: TRawUTF8Interning;
begin
  if fInternValues = nil then
    fInternValues := TRawUTF8Interning.Create;
  result := fInternValues;
end;

procedure TDocVariantData.SetOptions(const opt: TDocVariantOptions);
begin
  VOptions := (opt - [dvoIsArray, dvoIsObject]) +
              (VOptions * [dvoIsArray, dvoIsObject]);
end;

procedure TDocVariantData.Init(aOptions: TDocVariantOptions;
  aKind: TDocVariantKind);
begin
  aOptions := aOptions - [dvoIsArray, dvoIsObject];
  case aKind of
    dvArray:
      include(aOptions, dvoIsArray);
    dvObject:
      include(aOptions, dvoIsObject);
  end;
  ZeroFill(@self);
  VType := DocVariantVType;
  VOptions := aOptions;
end;

procedure TDocVariantData.InitFast;
begin
  ZeroFill(@self);
  VType := DocVariantVType;
  VOptions := JSON_OPTIONS_FAST;
end;

procedure TDocVariantData.InitFast(InitialCapacity: integer;
  aKind: TDocVariantKind);
begin
  InitFast;
  case aKind of
    dvArray:
      include(VOptions, dvoIsArray);
    dvObject:
      include(VOptions, dvoIsObject);
  end;
  if aKind = dvObject then
    SetLength(VName, InitialCapacity);
  SetLength(VValue, InitialCapacity);
end;

procedure TDocVariantData.InitObject(const NameValuePairs: array of const;
  aOptions: TDocVariantOptions = []);
begin
  Init(aOptions, dvObject);
  AddNameValuesToObject(NameValuePairs);
end;

procedure TDocVariantData.AddNameValuesToObject(const NameValuePairs: array of const);
var
  n, arg: PtrInt;
  tmp: variant;
begin
  n := length(NameValuePairs);
  if (n = 0) or (n and 1 = 1) or (dvoIsArray in VOptions) then
    exit; // nothing to add
  include(VOptions, dvoIsObject);
  n := n shr 1;
  if length(VValue) < VCount + n then
  begin
    SetLength(VValue, VCount + n);
    SetLength(VName, VCount + n);
  end;
  for arg := 0 to n - 1 do
  begin
    VarRecToUTF8(NameValuePairs[arg * 2], VName[arg + VCount]);
    if dvoInternNames in VOptions then
      DocVariantType.InternNames.UniqueText(VName[arg + VCount]);
    if dvoValueCopiedByReference in VOptions then
      VarRecToVariant(NameValuePairs[arg * 2 + 1], VValue[arg + VCount])
    else
    begin
      VarRecToVariant(NameValuePairs[arg * 2 + 1], tmp);
      SetVariantByValue(tmp, VValue[arg + VCount]);
    end;
    if dvoInternValues in VOptions then
      DocVariantType.InternValues.UniqueVariant(VValue[arg + VCount]);
  end;
  inc(VCount, n);
end;

procedure TDocVariantData.AddOrUpdateNameValuesToObject(const NameValuePairs: array of const);
var
  n, arg: PtrInt;
  n2: RawUTF8;
  v: Variant;
begin
  n := length(NameValuePairs) shr 1;
  if (n = 0) or (dvoIsArray in VOptions) then
    exit; // nothing to add
  for arg := 0 to n - 1 do
  begin
    VarRecToUTF8(NameValuePairs[arg * 2], n2);
    VarRecToVariant(NameValuePairs[arg * 2 + 1], v);
    AddOrUpdateValue(n2, v)
  end;
end;

procedure TDocVariantData.AddOrUpdateObject(const NewValues: variant;
  OnlyAddMissing: boolean; RecursiveUpdate: boolean);
var
  n, idx: PtrInt;
  new: PDocVariantData;
  wasAdded: boolean;
begin
  new := _Safe(NewValues);
  if not (dvoIsArray in VOptions) and not (dvoIsArray in new^.VOptions) then
    for n := 0 to new^.Count - 1 do
    begin
      idx := AddOrUpdateValue(new^.names[n], new^.Values[n], @wasAdded, OnlyAddMissing);
      if RecursiveUpdate and not wasAdded then
        TDocVariantData(Values[idx]).AddOrUpdateObject(new^.Values[n], OnlyAddMissing, true);
    end;
end;

procedure TDocVariantData.InitArray(const Items: array of const;
  aOptions: TDocVariantOptions);
var
  arg: PtrInt;
  tmp: variant;
begin
  Init(aOptions, dvArray);
  if high(Items) >= 0 then
  begin
    VCount := length(Items);
    SetLength(VValue, VCount);
    if dvoValueCopiedByReference in VOptions then
      for arg := 0 to high(Items) do
        VarRecToVariant(Items[arg], VValue[arg])
    else
      for arg := 0 to high(Items) do
      begin
        VarRecToVariant(Items[arg], tmp);
        SetVariantByValue(tmp, VValue[arg]);
      end;
  end;
end;

procedure TDocVariantData.InitArrayFromVariants(const Items: TVariantDynArray;
  aOptions: TDocVariantOptions; ItemsCopiedByReference: boolean);
begin
  if Items = nil then
    VType := varNull
  else
  begin
    Init(aOptions, dvArray);
    VCount := length(Items);
    VValue := Items; // fast by-reference copy of VValue[]
    if not ItemsCopiedByReference then
      InitCopy(variant(self), aOptions);
  end;
end;

procedure TDocVariantData.InitArrayFromObjArray(const ObjArray;
  aOptions: TDocVariantOptions; aWriterOptions: TTextWriterWriteObjectOptions);
var
  ndx: PtrInt;
  Items: TObjectDynArray absolute ObjArray;
begin
  if Items = nil then
    VType := varNull
  else
  begin
    Init(aOptions, dvArray);
    VCount := length(Items);
    SetLength(VValue, VCount);
    for ndx := 0 to VCount - 1 do
      ObjectToVariant(Items[ndx], VValue[ndx], aWriterOptions);
  end;
end;

procedure TDocVariantData.InitArrayFrom(const Items: TRawUTF8DynArray;
  aOptions: TDocVariantOptions);
var
  ndx: PtrInt;
begin
  if Items = nil then
    VType := varNull
  else
  begin
    Init(aOptions, dvArray);
    VCount := length(Items);
    SetLength(VValue, VCount);
    for ndx := 0 to VCount - 1 do
      RawUTF8ToVariant(Items[ndx], VValue[ndx]);
  end;
end;

procedure TDocVariantData.InitArrayFrom(const Items: TIntegerDynArray;
  aOptions: TDocVariantOptions);
var
  ndx: PtrInt;
begin
  if Items = nil then
    VType := varNull
  else
  begin
    Init(aOptions, dvArray);
    VCount := length(Items);
    SetLength(VValue, VCount);
    for ndx := 0 to VCount - 1 do
      VValue[ndx] := Items[ndx];
  end;
end;

procedure TDocVariantData.InitArrayFrom(const Items: TInt64DynArray;
  aOptions: TDocVariantOptions);
var
  ndx: PtrInt;
begin
  if Items = nil then
    VType := varNull
  else
  begin
    Init(aOptions, dvArray);
    VCount := length(Items);
    SetLength(VValue, VCount);
    for ndx := 0 to VCount - 1 do
      VValue[ndx] := Items[ndx];
  end;
end;

procedure TDocVariantData.InitObjectFromVariants(const aNames: TRawUTF8DynArray;
  const aValues: TVariantDynArray; aOptions: TDocVariantOptions);
begin
  if (aNames = nil) or (aValues = nil) or (length(aNames) <> length(aValues)) then
    VType := varNull
  else
  begin
    Init(aOptions, dvObject);
    VCount := length(aNames);
    VName := aNames; // fast by-reference copy of VName[] and VValue[]
    VValue := aValues;
  end;
end;

procedure TDocVariantData.InitObjectFromPath(const aPath: RawUTF8;
  const aValue: variant; aOptions: TDocVariantOptions);
var
  right: RawUTF8;
begin
  if aPath = '' then
    VType := varNull
  else
  begin
    Init(aOptions, dvObject);
    VCount := 1;
    SetLength(VName, 1);
    SetLength(VValue, 1);
    split(aPath, '.', VName[0], right);
    if right = '' then
      VValue[0] := aValue
    else
      PDocVariantData(@VValue[0])^.InitObjectFromPath(right, aValue, aOptions);
  end;
end;

function TDocVariantData.InitJSONInPlace(JSON: PUTF8Char;
  aOptions: TDocVariantOptions; aEndOfObject: PUTF8Char): PUTF8Char;
var
  EndOfObject: AnsiChar;
  Name: PUTF8Char;
  NameLen, cap: integer;
  intnames, intvalues: TRawUTF8Interning;
begin
  Init(aOptions);
  result := nil;
  if JSON = nil then
    exit;
  if dvoInternValues in VOptions then
    intvalues := DocVariantType.InternValues
  else
    intvalues := nil;
  while (JSON^ <= ' ') and (JSON^ <> #0) do
    inc(JSON);
  case JSON^ of
    '[':
      begin
        repeat
          inc(JSON);
          if JSON^ = #0 then
            exit;
        until JSON^ > ' ';
        if JSON^ = ']' then // void but valid input array
          repeat
            inc(JSON)
          until (JSON^ = #0) or (JSON^ > ' ')
        else
        begin
          cap := abs(JSONArrayCount(JSON, JSON + 256 shl 10)); // initial guess
          include(VOptions, dvoIsArray);
          repeat
            if (VCount = 0) or (VCount = cap) then
            begin
              if (VCount <> 0) or (cap = 0) then
                cap := NextGrow(cap);
              SetLength(VValue, cap);
            end;
            GetJSONToAnyVariant(VValue[VCount], JSON, @EndOfObject, @VOptions, false);
            if JSON = nil then
            begin
              VCount := 0;
              exit; // invalid input
            end;
            if intvalues <> nil then
              intvalues.UniqueVariant(VValue[VCount]);
            inc(VCount);
          until EndOfObject = ']';
          if VCount <> cap then
            SetLength(VValue, VCount);
        end;
      end;
    '{':
      begin
        repeat
          inc(JSON);
          if JSON^ = #0 then
            exit;
        until JSON^ > ' ';
        cap := JSONObjectPropCount(JSON); // slow if object is huge (uncommon)
        if cap < 0 then
          exit; // invalid content
        include(VOptions, dvoIsObject);
        if dvoInternNames in VOptions then
          intnames := DocVariantType.InternNames
        else
          intnames := nil;
        if cap > 0 then
        begin
          SetLength(VValue, cap);
          SetLength(VName, cap);
          repeat
            if VCount >= cap then
              exit; // unexpected object size means invalid JSON
            // see http://docs.mongodb.org/manual/reference/mongodb-extended-json
            Name := GetJSONPropName(JSON, @NameLen);
            if Name = nil then
              exit;
            FastSetString(VName[VCount], Name, NameLen);
            if intnames <> nil then
              intnames.UniqueText(VName[VCount]);
            GetJSONToAnyVariant(VValue[VCount], JSON, @EndOfObject, @VOptions, false);
            if JSON = nil then
              if EndOfObject = '}' then // valid object end
                JSON := @NULCHAR
              else
                exit; // invalid input
            if intvalues <> nil then
              intvalues.UniqueVariant(VValue[VCount]);
            inc(VCount);
          until EndOfObject = '}';
        end
        else if JSON^ = '}' then // cap=0
          repeat
            inc(JSON)
          until (JSON^ = #0) or (JSON^ > ' ')
        else
          exit;
      end;
    'n', 'N':
      begin
        if IdemPChar(JSON + 1, 'ULL') then
        begin
          include(VOptions, dvoIsObject);
          result := GotoNextNotSpace(JSON + 4);
        end;
        exit;
      end;
  else
    exit;
  end;
  while (JSON^ <= ' ') and (JSON^ <> #0) do
    inc(JSON);
  if aEndOfObject <> nil then
    aEndOfObject^ := JSON^;
  if JSON^ <> #0 then
    repeat
      inc(JSON)
    until (JSON^ = #0) or (JSON^ > ' ');
  result := JSON; // indicates successfully parsed
end;

function TDocVariantData.InitJSON(const JSON: RawUTF8;
  aOptions: TDocVariantOptions): boolean;
var
  tmp: TSynTempBuffer;
begin
  if JSON = '' then
    result := false
  else
  begin
    tmp.Init(JSON);
    try
      result := InitJSONInPlace(tmp.buf, aOptions) <> nil;
    finally
      tmp.Done;
    end;
  end;
end;

procedure TDocVariantData.InitCSV(CSV: PUTF8Char; aOptions: TDocVariantOptions;
  NameValueSep, ItemSep: AnsiChar; DoTrim: boolean);
var
  n, v: RawUTF8;
  val: variant;
begin
  Init(aOptions, dvObject);
  while CSV <> nil do
  begin
    GetNextItem(CSV, NameValueSep, n);
    if ItemSep = #10 then
      GetNextItemTrimedCRLF(CSV, v)
    else
      GetNextItem(CSV, ItemSep, v);
    if DoTrim then
      v := trim(v);
    if n = '' then
      break;
    RawUTF8ToVariant(v, val);
    AddValue(n, val);
  end;
end;

procedure TDocVariantData.InitCSV(const CSV: RawUTF8; aOptions: TDocVariantOptions;
  NameValueSep, ItemSep: AnsiChar; DoTrim: boolean);
begin
  InitCSV(pointer(CSV), aOptions, NameValueSep, ItemSep, DoTrim);
end;

procedure TDocVariantData.InitCopy(const SourceDocVariant: variant;
  aOptions: TDocVariantOptions);
var
  ndx: PtrInt;
  vt: cardinal;
  Source: PDocVariantData;
  SourceVValue: TVariantDynArray;
  Handler: TCustomVariantType;
  v: PVarData;
begin
  with TVarData(SourceDocVariant) do
    if cardinal(VType) = varByRef or varVariant then
      Source := VPointer
    else
      Source := @SourceDocVariant;
  if cardinal(Source^.VType) <> DocVariantVType then
    raise EDocVariant.CreateUTF8('No TDocVariant for InitCopy(%)', [ord(Source.VType)]);
  SourceVValue := Source^.VValue; // local fast per-reference copy
  if Source <> @self then
  begin
    VType := Source^.VType;
    VCount := Source^.VCount;
    pointer(VName) := nil;  // avoid GPF
    pointer(VValue) := nil;
    aOptions := aOptions - [dvoIsArray, dvoIsObject]; // may not be same as Source
    if dvoIsArray in Source^.VOptions then
      include(aOptions, dvoIsArray)
    else if dvoIsObject in Source^.VOptions then
    begin
      include(aOptions, dvoIsObject);
      SetLength(VName, VCount);
      for ndx := 0 to VCount - 1 do
        VName[ndx] := Source^.VName[ndx]; // manual copy is needed
      if dvoInternNames in aOptions then
        with DocVariantType.InternNames do
          for ndx := 0 to VCount - 1 do
            UniqueText(VName[ndx]);
    end;
    VOptions := aOptions;
  end
  else
  begin
    SetOptions(aOptions);
    VariantDynArrayClear(VValue); // full copy of all values
  end;
  if VCount > 0 then
  begin
    SetLength(VValue, VCount);
    for ndx := 0 to VCount - 1 do
    begin
      v := @SourceVValue[ndx];
      repeat
        vt := v^.VType;
        if vt <> varByRef or varVariant then
          break;
        v := v^.VPointer;
      until false;
      if vt <= varNativeString then // simple string/number types copy
        VValue[ndx] := variant(v^)
      else if vt = DocVariantVType then // direct recursive copy for TDocVariant
        TDocVariantData(VValue[ndx]).InitCopy(variant(v^), VOptions)
      else if FindCustomVariantType(vt, Handler) then
        if Handler.InheritsFrom(TSynInvokeableVariantType) then
          TSynInvokeableVariantType(Handler).CopyByValue(TVarData(VValue[ndx]), v^)
        else
          Handler.Copy(TVarData(VValue[ndx]), v^, false)
      else
        VValue[ndx] := variant(v^); // default copy
    end;
    if dvoInternValues in VOptions then
      with DocVariantType.InternValues do
        for ndx := 0 to VCount - 1 do
          UniqueVariant(VValue[ndx]);
  end;
  VariantDynArrayClear(SourceVValue);
end;

procedure TDocVariantData.ClearFast;
begin
  PInteger(@VType)^ := 0;
  RawUTF8DynArrayClear(VName);
  VariantDynArrayClear(VValue);
  VCount := 0;
end;

procedure TDocVariantData.Clear;
begin
  if cardinal(VType) = DocVariantVType then
    ClearFast
  else
    VarClear(variant(self));
end;

procedure TDocVariantData.Reset;
var
  backup: TDocVariantOptions;
begin
  if VCount = 0 then
    exit;
  backup := VOptions - [dvoIsArray, dvoIsObject];
  ClearFast;
  VType := DocVariantVType;
  VOptions := backup;
end;

procedure TDocVariantData.FillZero;
var
  ndx: PtrInt;
begin
  for ndx := 0 to VCount - 1 do
    mormot.core.variants.FillZero(VValue[ndx]);
  Reset;
end;

procedure TDocVariantData.SetCount(aCount: integer);
begin
  VCount := aCount;
end;

function TDocVariantData.InternalAdd(const aName: RawUTF8): integer;
var
  len: integer;
begin
  if aName <> '' then
  begin
    if dvoIsArray in VOptions then
      raise EDocVariant.CreateUTF8('Add: Unexpected [%] object property in an array', [aName]);
    if not (dvoIsObject in VOptions) then
    begin
      VType := DocVariantVType; // may not be set yet
      include(VOptions, dvoIsObject);
    end;
  end
  else
  begin
    if dvoIsObject in VOptions then
      raise EDocVariant.Create('Add: Unexpected array item in an object');
    if not (dvoIsArray in VOptions) then
    begin
      VType := DocVariantVType; // may not be set yet
      include(VOptions, dvoIsArray);
    end;
  end;
  len := length(VValue);
  if VCount >= len then
  begin
    len := NextGrow(VCount);
    SetLength(VValue, len);
  end;
  if aName <> '' then
  begin
    if Length(VName) <> len then
      SetLength(VName, len);
    if dvoInternNames in VOptions then
      DocVariantType.InternNames.Unique(VName[VCount], aName)
    else
      VName[VCount] := aName;
  end;
  result := VCount;
  inc(VCount);
end;

procedure TDocVariantData.SetCapacity(aValue: integer);
begin
  if dvoIsObject in VOptions then
    SetLength(VName, aValue);
  SetLength(VValue, aValue);
end;

function TDocVariantData.AddValue(const aName: RawUTF8; const aValue: variant;
  aValueOwned: boolean): integer;
begin
  if dvoCheckForDuplicatedNames in VOptions then
  begin
    result := GetValueIndex(aName);
    if result >= 0 then
      raise EDocVariant.CreateUTF8('AddValue: Duplicated [%] name', [aName]);
  end;
  result := InternalAdd(aName);
  if aValueOwned then
    VValue[result] := aValue
  else
    SetVariantByValue(aValue, VValue[result]);
  if dvoInternValues in VOptions then
    DocVariantType.InternValues.UniqueVariant(VValue[result]);
end;

function TDocVariantData.AddValue(aName: PUTF8Char; aNameLen: integer;
  const aValue: variant; aValueOwned: boolean): integer;
var
  tmp: RawUTF8;
begin
  FastSetString(tmp, aName, aNameLen);
  result := AddValue(tmp, aValue, aValueOwned);
end;

function TDocVariantData.AddValueFromText(const aName, aValue: RawUTF8;
  Update, AllowVarDouble: boolean): integer;
begin
  if aName = '' then
  begin
    result := -1;
    exit;
  end;
  result := GetValueIndex(aName);
  if not Update and (dvoCheckForDuplicatedNames in VOptions) and (result >= 0) then
    raise EDocVariant.CreateUTF8('AddValueFromText: Duplicated [%] name', [aName]);
  if result < 0 then
    result := InternalAdd(aName);
  VarClear(VValue[result]);
  if not GetNumericVariantFromJSON(pointer(aValue),
          TVarData(VValue[result]), AllowVarDouble) then
    if dvoInternValues in VOptions then
      DocVariantType.InternValues.UniqueVariant(VValue[result], aValue)
    else
      RawUTF8ToVariant(aValue, VValue[result]);
end;

procedure TDocVariantData.AddByPath(const aSource: TDocVariantData;
  const aPaths: array of RawUTF8);
var
  p, added: PtrInt;
  v: TVarData;
begin
  if (aSource.Count = 0) or not (dvoIsObject in aSource.VOptions) or
     (dvoIsArray in VOptions) then
    exit;
  for p := 0 to High(aPaths) do
  begin
    DocVariantType.Lookup(v, TVarData(aSource), pointer(aPaths[p]));
    if cardinal(v.VType) < varNull then
      continue; // path not found
    added := InternalAdd(aPaths[p]);
    PVarData(@VValue[added])^ := v;
    if dvoInternValues in VOptions then
      DocVariantType.InternValues.UniqueVariant(VValue[added]);
  end;
end;

procedure TDocVariantData.AddFrom(const aDocVariant: Variant);
var
  src: PDocVariantData;
  ndx: PtrInt;
begin
  src := _Safe(aDocVariant);
  if src^.Count = 0 then
    exit; // nothing to add
  if dvoIsArray in src^.VOptions then
    // add array items
    if dvoIsObject in VOptions then // types should match
      exit
    else
      for ndx := 0 to src^.Count - 1 do
        AddItem(src^.VValue[ndx])
  else    // add object items
if dvoIsArray in VOptions then // types should match
    exit
  else
    for ndx := 0 to src^.Count - 1 do
      AddValue(src^.VName[ndx], src^.VValue[ndx]);
end;

procedure TDocVariantData.AddOrUpdateFrom(const aDocVariant: Variant;
  aOnlyAddMissing: boolean);
var
  src: PDocVariantData;
  ndx: PtrInt;
begin
  src := _Safe(aDocVariant, dvObject);
  for ndx := 0 to src^.Count - 1 do
    AddOrUpdateValue(src^.VName[ndx], src^.VValue[ndx], nil, aOnlyAddMissing);
end;

function TDocVariantData.AddItem(const aValue: variant): integer;
begin
  result := InternalAdd('');
  SetVariantByValue(aValue, VValue[result]);
  if dvoInternValues in VOptions then
    DocVariantType.InternValues.UniqueVariant(VValue[result]);
end;

function TDocVariantData.AddItemFromText(const aValue: RawUTF8;
  AllowVarDouble: boolean): integer;
begin
  result := InternalAdd('');
  if not GetNumericVariantFromJSON(pointer(aValue),
           TVarData(VValue[result]), AllowVarDouble) then
    if dvoInternValues in VOptions then
      DocVariantType.InternValues.UniqueVariant(VValue[result], aValue)
    else
      RawUTF8ToVariant(aValue, VValue[result]);
end;

function TDocVariantData.AddItemText(const aValue: RawUTF8): integer;
begin
  result := InternalAdd('');
  if dvoInternValues in VOptions then
    DocVariantType.InternValues.UniqueVariant(VValue[result], aValue)
  else
    RawUTF8ToVariant(aValue, VValue[result]);
end;

procedure TDocVariantData.AddItems(const aValue: array of const);
var
  ndx, added: PtrInt;
begin
  for ndx := 0 to high(aValue) do
  begin
    added := InternalAdd('');
    VarRecToVariant(aValue[ndx], VValue[added]);
    if dvoInternValues in VOptions then
      DocVariantType.InternValues.UniqueVariant(VValue[added]);
  end;
end;

function TDocVariantData.SearchItemByProp(const aPropName, aPropValue: RawUTF8;
  aPropValueCaseSensitive: boolean): integer;
var
  ndx: PtrInt;
begin
  if dvoIsObject in VOptions then
  begin
    result := GetValueIndex(aPropName);
    if (result >= 0) and
       VariantEquals(VValue[result], aPropValue, aPropValueCaseSensitive) then
      exit;
  end
  else if dvoIsArray in VOptions then
    for result := 0 to VCount - 1 do
      with _Safe(VValue[result])^ do
        if dvoIsObject in VOptions then
        begin
          ndx := GetValueIndex(aPropName);
          if (ndx >= 0) and
             VariantEquals(VValue[ndx], aPropValue, aPropValueCaseSensitive) then
            exit;
        end;
  result := -1;
end;

function TDocVariantData.SearchItemByProp(const aPropNameFmt: RawUTF8;
  const aPropNameArgs: array of const; const aPropValue: RawUTF8;
  aPropValueCaseSensitive: boolean): integer;
var
  name: RawUTF8;
begin
  FormatUTF8(aPropNameFmt, aPropNameArgs, name);
  result := SearchItemByProp(name, aPropValue, aPropValueCaseSensitive);
end;

function TDocVariantData.SearchItemByValue(const aValue: Variant;
  CaseInsensitive: boolean; StartIndex: PtrInt): PtrInt;
begin
  for result := StartIndex to VCount - 1 do
    if _SortDynArrayVariantComp(
      TVarData(VValue[result]), TVarData(aValue), CaseInsensitive) = 0 then
      exit;
  result := -1;
end;

type
  TQuickSortDocVariant = object
    names: PPointerArray;
    values: PVariantArray;
    nameCompare: TUTF8Compare;
    valueCompare: TVariantCompare;
    procedure SortByName(L, R: PtrInt);
    procedure SortByValue(L, R: PtrInt);
  end;

procedure TQuickSortDocVariant.SortByName(L, R: PtrInt);
var
  I, J, P: PtrInt;
  pivot: pointer;
begin
  if L < R then
    repeat
      I := L;
      J := R;
      P := (L + R) shr 1;
      repeat
        pivot := names[P];
        while nameCompare(names[I], pivot) < 0 do
          Inc(I);
        while nameCompare(names[J], pivot) > 0 do
          Dec(J);
        if I <= J then
        begin
          if I <> J then
          begin
            ExchgPointer(@names[I], @names[J]);
            ExchgVariant(@values[I], @values[J]);
          end;
          if P = I then
            P := J
          else if P = J then
            P := I;
          inc(I);
          dec(J);
        end;
      until I > J;
      if J - L < R - I then
      begin // use recursion only for smaller range
        if L < J then
          SortByName(L, J);
        L := I;
      end
      else
      begin
        if I < R then
          SortByName(I, R);
        R := J;
      end;
    until L >= R;
end;

procedure TQuickSortDocVariant.SortByValue(L, R: PtrInt);
var
  I, J, P: PtrInt;
  pivot: PVariant;
begin
  if L < R then
    repeat
      I := L;
      J := R;
      P := (L + R) shr 1;
      repeat
        pivot := @values[P];
        while valueCompare(values[I], pivot^) < 0 do
          Inc(I);
        while valueCompare(values[J], pivot^) > 0 do
          Dec(J);
        if I <= J then
        begin
          if I <> J then
          begin
            if names <> nil then
              ExchgPointer(@names[I], @names[J]);
            ExchgVariant(@values[I], @values[J]);
          end;
          if P = I then
            P := J
          else if P = J then
            P := I;
          inc(I);
          dec(J);
        end;
      until I > J;
      if J - L < R - I then
      begin // use recursion only for smaller range
        if L < J then
          SortByValue(L, J);
        L := I;
      end
      else
      begin
        if I < R then
          SortByValue(I, R);
        R := J;
      end;
    until L >= R;
end;

procedure TDocVariantData.SortByName(Compare: TUTF8Compare);
var
  qs: TQuickSortDocVariant;
begin
  if not (dvoIsObject in VOptions) or (VCount <= 0) then
    exit;
  if Assigned(Compare) then
    qs.nameCompare := Compare
  else
    qs.nameCompare := @StrIComp;
  qs.names := pointer(VName);
  qs.values := pointer(VValue);
  qs.SortByName(0, VCount - 1);
end;

procedure TDocVariantData.SortByValue(Compare: TVariantCompare);
var
  qs: TQuickSortDocVariant;
begin
  if VCount <= 0 then
    exit;
  if Assigned(Compare) then
    qs.valueCompare := Compare
  else
    qs.valueCompare := @VariantCompare;
  qs.names := pointer(VName);
  qs.values := pointer(VValue);
  qs.SortByValue(0, VCount - 1);
end;

type
  {$ifdef USERECORDWITHMETHODS}
  TQuickSortDocVariantValuesByField = record
  {$else}
  TQuickSortDocVariantValuesByField = object
  {$endif USERECORDWITHMETHODS}
    Lookup: array of PVariant;
    Compare: TVariantCompare;
    Doc: PDocVariantData;
    Reverse: boolean;
    procedure Sort(L, R: PtrInt);
  end;

procedure TQuickSortDocVariantValuesByField.Sort(L, R: PtrInt);
var
  I, J, P: PtrInt;
  pivot: PVariant;
begin
  if L < R then
    repeat
      I := L;
      J := R;
      P := (L + R) shr 1;
      repeat
        pivot := Lookup[P];
        if Reverse then
        begin
          while Compare(Lookup[I]^, pivot^) < 0 do
            Inc(I);
          while Compare(Lookup[J]^, pivot^) > 0 do
            Dec(J);
        end
        else
        begin
          while Compare(Lookup[I]^, pivot^) > 0 do
            Inc(I);
          while Compare(Lookup[J]^, pivot^) < 0 do
            Dec(J);
        end;
        if I <= J then
        begin
          if I <> J then
          begin
            if Doc.VName <> nil then
              ExchgPointer(@Doc.VName[I], @Doc.VName[J]);
            ExchgVariant(@Doc.VValue[I], @Doc.VValue[J]);
            pivot := Lookup[I];
            Lookup[I] := Lookup[J];
            Lookup[J] := pivot;
          end;
          if P = I then
            P := J
          else if P = J then
            P := I;
          inc(I);
          dec(J);
        end;
      until I > J;
      if J - L < R - I then
      begin // use recursion only for smaller range
        if L < J then
          Sort(L, J);
        L := I;
      end
      else
      begin
        if I < R then
          Sort(I, R);
        R := J;
      end;
    until L >= R;
end;

procedure TDocVariantData.SortArrayByField(const aItemPropName: RawUTF8;
  aValueCompare: TVariantCompare; aValueCompareReverse: boolean;
  aNameSortedCompare: TUTF8Compare);
var
  QS: TQuickSortDocVariantValuesByField;
  p: pointer;
  row: PtrInt;
begin
  if (VCount <= 0) or (aItemPropName = '') or not (dvoIsArray in VOptions) then
    exit;
  if not Assigned(aValueCompare) then
    QS.Compare := VariantCompare
  else
    QS.Compare := aValueCompare;
  QS.Reverse := aValueCompareReverse;
  SetLength(QS.Lookup, VCount);
  for row := 0 to VCount - 1 do
  begin // resolve GetPVariantByName(aIdemPropName) once
    p := _Safe(VValue[row])^.GetVarData(aItemPropName, aNameSortedCompare);
    if p = nil then
      p := @NullVarData;
    QS.Lookup[row] := p;
  end;
  QS.Doc := @self;
  QS.Sort(0, VCount - 1);
end;

function TDocVariantData.Reduce(const aPropNames: array of RawUTF8;
  aCaseSensitive, aDoNotAddVoidProp: boolean): variant;
begin
  VarClear(result{%H-});
  Reduce(aPropNames, aCaseSensitive, PDocVariantData(@result)^, aDoNotAddVoidProp);
end;

procedure TDocVariantData.Reduce(const aPropNames: array of RawUTF8;
  aCaseSensitive: boolean; out result: TDocVariantData; aDoNotAddVoidProp: boolean);
var
  ndx, j: PtrInt;
  reduced: TDocVariantData;
begin
  result.InitFast;
  if (VCount = 0) or (high(aPropNames) < 0) then
    exit;
  if dvoIsObject in VOptions then
  begin
    if aCaseSensitive then
    begin
      for j := 0 to high(aPropNames) do
        for ndx := 0 to VCount - 1 do
          if VName[ndx] = aPropNames[j] then
          begin
            if not aDoNotAddVoidProp or not VarIsVoid(VValue[ndx]) then
              result.AddValue(VName[ndx], VValue[ndx]);
            break;
          end;
    end
    else
      for j := 0 to high(aPropNames) do
        for ndx := 0 to VCount - 1 do
          if IdemPropNameU(VName[ndx], aPropNames[j]) then
          begin
            if not aDoNotAddVoidProp or not VarIsVoid(VValue[ndx]) then
              result.AddValue(VName[ndx], VValue[ndx]);
            break;
          end;
  end
  else if dvoIsArray in VOptions then
    for ndx := 0 to VCount - 1 do
    begin
      _Safe(VValue[ndx])^.Reduce(aPropNames, aCaseSensitive, reduced, aDoNotAddVoidProp);
      if dvoIsObject in reduced.VOptions then
        result.AddItem(variant(reduced));
    end;
end;

function TDocVariantData.ReduceAsArray(const aPropName: RawUTF8;
  OnReduce: TOnReducePerItem): variant;
begin
  VarClear(result{%H-});
  ReduceAsArray(aPropName, PDocVariantData(@result)^, OnReduce);
end;

procedure TDocVariantData.ReduceAsArray(const aPropName: RawUTF8;
  out result: TDocVariantData; OnReduce: TOnReducePerItem);
var
  ndx, j: PtrInt;
  item: PDocVariantData;
begin
  result.InitFast;
  if (VCount = 0) or (aPropName = '') or not (dvoIsArray in VOptions) then
    exit;
  for ndx := 0 to VCount - 1 do
  begin
    item := _Safe(VValue[ndx]);
    j := item^.GetValueIndex(aPropName);
    if j >= 0 then
      if not Assigned(OnReduce) or OnReduce(item) then
        result.AddItem(item^.VValue[j]);
  end;
end;

function TDocVariantData.ReduceAsArray(const aPropName: RawUTF8;
  OnReduce: TOnReducePerValue): variant;
begin
  VarClear(result{%H-});
  ReduceAsArray(aPropName, PDocVariantData(@result)^, OnReduce);
end;

procedure TDocVariantData.ReduceAsArray(const aPropName: RawUTF8;
  out result: TDocVariantData; OnReduce: TOnReducePerValue);
var
  ndx, j: PtrInt;
  item: PDocVariantData;
  v: PVariant;
begin
  result.InitFast;
  if (VCount = 0) or (aPropName = '') or not (dvoIsArray in VOptions) then
    exit;
  for ndx := 0 to VCount - 1 do
  begin
    item := _Safe(VValue[ndx]);
    j := item^.GetValueIndex(aPropName);
    if j >= 0 then
    begin
      v := @item^.VValue[j];
      if not Assigned(OnReduce) or OnReduce(v^) then
        result.AddItem(v^);
    end;
  end;
end;

function TDocVariantData.Rename(const aFromPropName, aToPropName: TRawUTF8DynArray): integer;
var
  n, p, ndx: PtrInt;
begin
  result := 0;
  n := length(aFromPropName);
  if length(aToPropName) = n then
    for p := 0 to n - 1 do
    begin
      ndx := GetValueIndex(aFromPropName[p]);
      if ndx >= 0 then
      begin
        VName[ndx] := aToPropName[p];
        inc(result);
      end;
    end;
end;

function TDocVariantData.FlattenAsNestedObject(const aObjectPropName: RawUTF8): boolean;
var
  ndx, len: PtrInt;
  Up: array[byte] of AnsiChar;
  nested: TDocVariantData;
begin // {"p.a1":5,"p.a2":"dfasdfa"} -> {"p":{"a1":5,"a2":"dfasdfa"}}
  result := false;
  if (VCount = 0) or (aObjectPropName = '') or not (dvoIsObject in VOptions) then
    exit;
  PWord(UpperCopy255(Up{%H-}, aObjectPropName))^ := ord('.'); // e.g. 'P.'
  for ndx := 0 to Count - 1 do
    if not IdemPChar(pointer(VName[ndx]), Up) then
      exit; // all fields should match "p.####"
  len := length(aObjectPropName) + 1;
  for ndx := 0 to Count - 1 do
    system.delete(VName[ndx], 1, len);
  nested := self;
  Clear;
  InitObject([aObjectPropName, variant(nested)]);
  result := true;
end;

function TDocVariantData.Delete(Index: integer): boolean;
begin
  if cardinal(Index) >= cardinal(VCount) then
    result := false
  else
  begin
    dec(VCount);
    if VName <> nil then
    begin
      if PRefCnt(PAnsiChar(pointer(VName)) - _DAREFCNT)^ > 1 then
        VName := copy(VName); // make unique
      VName[Index] := '';
    end;
    if PRefCnt(PAnsiChar(pointer(VValue)) - _DAREFCNT)^ > 1 then
      VValue := copy(VValue); // make unique
    VarClear(VValue[Index]);
    if Index < VCount then
    begin
      if VName <> nil then
      begin
        MoveFast(VName[Index + 1], VName[Index], (VCount - Index) * SizeOf(pointer));
        PtrUInt(VName[VCount]) := 0; // avoid GPF
      end;
      MoveFast(VValue[Index + 1], VValue[Index], (VCount - Index) * SizeOf(variant));
      TVarData(VValue[VCount]).VType := varEmpty; // avoid GPF
    end;
    result := true;
  end;
end;

function TDocVariantData.Delete(const aName: RawUTF8): boolean;
begin
  result := Delete(GetValueIndex(aName));
end;

function TDocVariantData.DeleteByProp(const aPropName, aPropValue: RawUTF8;
  aPropValueCaseSensitive: boolean): boolean;
var
  ndx: integer;
begin
  ndx := SearchItemByProp(aPropName, aPropValue, aPropValueCaseSensitive);
  if ndx < 0 then
    result := false
  else
    result := Delete(ndx);
end;

function TDocVariantData.DeleteByValue(const aValue: Variant;
  CaseInsensitive: boolean): integer;
var
  ndx: PtrInt;
begin
  result := 0;
  if VarIsEmptyOrNull(aValue) then
  begin
    for ndx := VCount - 1 downto 0 do
      if VarDataIsEmptyOrNull(@VValue[ndx]) then
      begin
        Delete(ndx);
        inc(result);
      end;
  end
  else
    for ndx := VCount - 1 downto 0 do
      if _SortDynArrayVariantComp(
         TVarData(VValue[ndx]), TVarData(aValue), CaseInsensitive) = 0 then
      begin
        Delete(ndx);
        inc(result);
      end;
end;

function TDocVariantData.DeleteByStartName(aStartName: PUTF8Char; aStartNameLen: integer): integer;
var
  ndx: integer;
  upname: array[byte] of AnsiChar;
begin
  result := 0;
  if aStartNameLen = 0 then
    aStartNameLen := StrLen(aStartName);
  if (VCount = 0) or not (dvoIsObject in VOptions) or (aStartNameLen = 0) then
    exit;
  UpperCopy255Buf(upname{%H-}, aStartName, aStartNameLen)^ := #0;
  for ndx := Count - 1 downto 0 do
    if IdemPChar(pointer(names[ndx]), upname) then
    begin
      Delete(ndx);
      inc(result);
    end;
end;

function FindNonVoidRawUTF8(n: PPtrInt; name: PUTF8Char; len: TStrLen; count: PtrInt): PtrInt;
begin // FPC does proper inlining in this loop
  for result := 0 to count - 1 do // all VName[]<>'' so n^<>0
    if (PStrLen(n^ - _STRLEN)^ = len) and CompareMemFixed(pointer(n^), name, len) then
      exit
    else
      inc(n);
  result := -1;
end;

function FindNonVoidRawUTF8I(n: PPtrInt; name: PUTF8Char; len: TStrLen; count: PtrInt): PtrInt;
begin
  for result := 0 to count - 1 do
    if (PStrLen(n^ - _STRLEN)^ = len) and IdemPropNameUSameLen(pointer(n^), name, len) then
      exit
    else
      inc(n);
  result := -1;
end;

function TDocVariantData.GetValueIndex(aName: PUTF8Char; aNameLen: PtrInt;
  aCaseSensitive: boolean): integer;
var
  err: integer;
begin
  if (cardinal(VType) = DocVariantVType) and (VCount > 0) then
    if dvoIsArray in VOptions then
    begin // try index text in array document
      result := GetInteger(aName, err);
      if (err <> 0) or (cardinal(result) >= cardinal(VCount)) then
        result := -1;
    end
    else // O(n) lookup for name -> efficient brute force sub-functions
    if aCaseSensitive then
      result := FindNonVoidRawUTF8(pointer(VName), aName, aNameLen, VCount)
    else
      result := FindNonVoidRawUTF8I(pointer(VName), aName, aNameLen, VCount)
  else
    result := -1;
end;

function TDocVariantData.GetValueOrRaiseException(const aName: RawUTF8): variant;
begin
  RetrieveValueOrRaiseException(pointer(aName), length(aName),
    dvoNameCaseSensitive in VOptions, result, false);
end;

function TDocVariantData.GetValueOrDefault(const aName: RawUTF8;
  const aDefault: variant): variant;
var
  ndx: PtrInt;
begin
  if (cardinal(VType) <> DocVariantVType) or not (dvoIsObject in VOptions) then
    result := aDefault
  else
  begin
    ndx := GetValueIndex(aName);
    if ndx >= 0 then
      result := VValue[ndx]
    else
      result := aDefault;
  end;
end;

function TDocVariantData.GetValueOrNull(const aName: RawUTF8): variant;
var
  ndx: PtrInt;
begin
  if (cardinal(VType) <> DocVariantVType) or not (dvoIsObject in VOptions) then
    SetVariantNull(result{%H-})
  else
  begin
    ndx := GetValueIndex(aName);
    if ndx >= 0 then
      result := VValue[ndx]
    else
      SetVariantNull(result);
  end;
end;

function TDocVariantData.GetValueOrEmpty(const aName: RawUTF8): variant;
var
  ndx: PtrInt;
begin
  VarClear(result{%H-});
  if (cardinal(VType) = DocVariantVType) and (dvoIsObject in VOptions) then
  begin
    ndx := GetValueIndex(aName);
    if ndx >= 0 then
      result := VValue[ndx];
  end;
end;

function TDocVariantData.GetAsBoolean(const aName: RawUTF8; out aValue: boolean;
  aSortedCompare: TUTF8Compare): Boolean;
var
  found: PVarData;
begin
  found := GetVarData(aName, aSortedCompare);
  if found = nil then
    result := false
  else
    result := VariantToBoolean(PVariant(found)^, aValue)
end;

function TDocVariantData.GetAsInteger(const aName: RawUTF8; out aValue: integer;
  aSortedCompare: TUTF8Compare): Boolean;
var
  found: PVarData;
begin
  found := GetVarData(aName, aSortedCompare);
  if found = nil then
    result := false
  else
    result := VariantToInteger(PVariant(found)^, aValue);
end;

function TDocVariantData.GetAsInt64(const aName: RawUTF8; out aValue: Int64;
  aSortedCompare: TUTF8Compare): Boolean;
var
  found: PVarData;
begin
  found := GetVarData(aName, aSortedCompare);
  if found = nil then
    result := false
  else
    result := VariantToInt64(PVariant(found)^, aValue)
end;

function TDocVariantData.GetAsDouble(const aName: RawUTF8; out aValue: double;
  aSortedCompare: TUTF8Compare): Boolean;
var
  found: PVarData;
begin
  found := GetVarData(aName, aSortedCompare);
  if found = nil then
    result := false
  else
    result := VariantToDouble(PVariant(found)^, aValue);
end;

function TDocVariantData.GetAsRawUTF8(const aName: RawUTF8; out aValue: RawUTF8;
  aSortedCompare: TUTF8Compare): Boolean;
var
  found: PVarData;
  wasString: boolean;
begin
  found := GetVarData(aName, aSortedCompare);
  if found = nil then
    result := false
  else
  begin
    if cardinal(found^.VType) > varNull then // default VariantToUTF8(null)='null'
      VariantToUTF8(PVariant(found)^, aValue, wasString);
    result := true;
  end;
end;

function TDocVariantData.GetValueEnumerate(const aName: RawUTF8; aTypeInfo: pointer;
  out aValue; aDeleteFoundEntry: boolean): boolean;
var
  text: RawUTF8;
  ndx, ord: integer;
begin
  result := false;
  ndx := GetValueIndex(aName);
  if ndx < 0 then
    exit;
  VariantToUTF8(Values[ndx], text);
  ord := GetEnumNameValue(aTypeInfo, text, true);
  if ord < 0 then
    exit;
  byte(aValue) := ord;
  if aDeleteFoundEntry then
    Delete(ndx);
  result := true;
end;

function TDocVariantData.GetAsDocVariant(const aName: RawUTF8;
  out aValue: PDocVariantData; aSortedCompare: TUTF8Compare): boolean;
var
  found: PVarData;
begin
  found := GetVarData(aName, aSortedCompare);
  if found = nil then
    result := false
  else
  begin
    aValue := _Safe(PVariant(found)^);
    result := aValue <> @DocVariantDataFake;
  end;
end;

function TDocVariantData.GetAsDocVariantSafe(const aName: RawUTF8;
  aSortedCompare: TUTF8Compare): PDocVariantData;
var
  found: PVarData;
begin
  found := GetVarData(aName, aSortedCompare);
  if found = nil then
    result := @DocVariantDataFake
  else
    result := _Safe(PVariant(found)^);
end;

function TDocVariantData.GetAsPVariant(const aName: RawUTF8;
  out aValue: PVariant; aSortedCompare: TUTF8Compare): boolean;
begin
  aValue := pointer(GetVarData(aName, aSortedCompare));
  result := aValue <> nil;
end;

function TDocVariantData.GetAsPVariant(aName: PUTF8Char; aNameLen: PtrInt): PVariant;
var
  ndx: integer;
begin
  ndx := GetValueIndex(aName, aNameLen, dvoNameCaseSensitive in VOptions);
  if ndx >= 0 then
    result := @VValue[ndx]
  else
    result := nil;
end;

function TDocVariantData.GetVarData(const aName: RawUTF8; aSortedCompare: TUTF8Compare): PVarData;
var
  ndx: integer;
begin
  if (cardinal(VType) <> DocVariantVType) or not (dvoIsObject in VOptions) or
     (VCount = 0) or (aName = '') then
    result := nil
  else
  begin
    if Assigned(aSortedCompare) then
      if @aSortedCompare = @StrComp then // use branchless asm for StrComp()
        ndx := FastFindPUTF8CharSorted(pointer(VName), VCount - 1, pointer(aName))
      else
        ndx := FastFindPUTF8CharSorted(pointer(VName), VCount - 1, pointer(aName), aSortedCompare)
    else if dvoNameCaseSensitive in VOptions then
      ndx := FindNonVoidRawUTF8(pointer(VName), pointer(aName), length(aName), VCount)
    else
      ndx := FindNonVoidRawUTF8I(pointer(VName), pointer(aName), length(aName), VCount);
    if ndx >= 0 then
      result := @VValue[ndx]
    else
      result := nil;
  end;
end;

function TDocVariantData.GetVarData(const aName: RawUTF8; var aValue: TVarData;
  aSortedCompare: TUTF8Compare): boolean;
var
  found: PVarData;
begin
  found := GetVarData(aName, aSortedCompare);
  if found = nil then
    result := false
  else
  begin
    aValue := found^;
    result := true;
  end;
end;

function TDocVariantData.GetValueByPath(const aPath: RawUTF8): variant;
var
  Dest: TVarData;
begin
  VarClear(result{%H-});
  if (cardinal(VType) <> DocVariantVType) or not (dvoIsObject in VOptions) then
    exit;
  DocVariantType.Lookup(Dest, TVarData(self), pointer(aPath));
  if cardinal(Dest.VType) >= varNull then
    result := variant(Dest); // copy
end;

function TDocVariantData.GetValueByPath(const aPath: RawUTF8; out aValue: variant): boolean;
var
  Dest: TVarData;
begin
  result := false;
  if (cardinal(VType) <> DocVariantVType) or not (dvoIsObject in VOptions) then
    exit;
  DocVariantType.Lookup(Dest, TVarData(self), pointer(aPath));
  if Dest.VType = varEmpty then
    exit;
  aValue := variant(Dest); // copy
  result := true;
end;

function TDocVariantData.GetPVariantByPath(const aPath: RawUTF8): PVariant;
var
  p: PUTF8Char;
  item: RawUTF8;
  par: PVariant;
begin
  result := nil;
  if (cardinal(VType) <> DocVariantVType) or (aPath = '') or
     not (dvoIsObject in VOptions) or (count = 0) then
    exit;
  par := @self;
  p := pointer(aPath);
  repeat
    GetNextItem(p, '.', item);
    if _Safe(par^).GetAsPVariant(item, result) then
      par := result
    else
    begin
      result := nil;
      exit;
    end;
  until p = nil;
  // if we reached here, we have par=result=found item
end;

function TDocVariantData.GetDocVariantByPath(const aPath: RawUTF8;
  out aValue: PDocVariantData): boolean;
var
  v: PVariant;
begin
  v := GetPVariantByPath(aPath);
  if v <> nil then
  begin
    aValue := _Safe(v^);
    result := cardinal(aValue^.VType) > varNull;
  end
  else
    result := false;
end;

function TDocVariantData.GetValueByPath(const aDocVariantPath: array of RawUTF8): variant;
var
  found, res: PVarData;
  vt: cardinal;
  P: integer;
begin
  VarClear(result{%H-});
  if (cardinal(VType) <> DocVariantVType) or not (dvoIsObject in VOptions) or
     (high(aDocVariantPath) < 0) then
    exit;
  found := @self;
  P := 0;
  repeat
    found := PDocVariantData(found).GetVarData(aDocVariantPath[P]);
    if found = nil then
      exit;
    if P = high(aDocVariantPath) then
      break; // we found the item!
    inc(P);
    // if we reached here, we should try for the next scope within Dest
    repeat
      vt := found^.VType;
      if vt <> varByRef or varVariant then
        break;
      found := found^.VPointer;
    until false;
    if vt = VType then
      continue;
    exit;
  until false;
  res := found;
  while cardinal(res^.VType) = varByRef or varVariant do
    res := res^.VPointer;
  if (cardinal(res^.VType) = VType) and (PDocVariantData(res)^.VCount = 0) then
    // return void TDocVariant as null
    TVarData(result).VType := varNull
  else    // copy found value
    result := PVariant(found)^;
end;

function TDocVariantData.GetItemByProp(const aPropName, aPropValue: RawUTF8;
  aPropValueCaseSensitive: boolean; var Dest: variant; DestByRef: boolean): boolean;
var
  ndx: integer;
begin
  result := false;
  if not (dvoIsArray in VOptions) then
    exit;
  ndx := SearchItemByProp(aPropName, aPropValue, aPropValueCaseSensitive);
  if ndx < 0 then
    exit;
  RetrieveValueOrRaiseException(ndx, Dest, DestByRef);
  result := true;
end;

function TDocVariantData.GetDocVariantByProp(const aPropName, aPropValue: RawUTF8;
  aPropValueCaseSensitive: boolean; out Dest: PDocVariantData): boolean;
var
  ndx: PtrInt;
begin
  result := false;
  if not (dvoIsArray in VOptions) then
    exit;
  ndx := SearchItemByProp(aPropName, aPropValue, aPropValueCaseSensitive);
  if ndx < 0 then
    exit;
  Dest := _Safe(VValue[ndx]);
  result := Dest^.VType > varNull;
end;

function TDocVariantData.GetJsonByStartName(const aStartName: RawUTF8): RawUTF8;
var
  Up: array[byte] of AnsiChar;
  temp: TTextWriterStackBuffer;
  ndx: integer;
  W: TTextWriter;
begin
  if not (dvoIsObject in VOptions) or (VCount = 0) then
  begin
    result := NULL_STR_VAR;
    exit;
  end;
  UpperCopy255(Up, aStartName)^ := #0;
  W := DefaultTextWriterSerializer.CreateOwnedStream(temp) as TTextWriter;
  try
    W.Add('{');
    for ndx := 0 to VCount - 1 do
      if IdemPChar(Pointer(VName[ndx]), Up) then
      begin
        if (dvoSerializeAsExtendedJson in VOptions) and
           JsonPropNameValid(pointer(VName[ndx])) then
        begin
          W.AddNoJSONEscape(pointer(VName[ndx]), Length(VName[ndx]));
        end
        else
        begin
          W.Add('"');
          W.AddJSONEscape(pointer(VName[ndx]));
          W.Add('"');
        end;
        W.Add(':');
        W.AddVariant(VValue[ndx], twJSONEscape);
        W.Add(',');
      end;
    W.CancelLastComma;
    W.Add('}');
    W.SetText(result);
  finally
    W.Free;
  end;
end;

function TDocVariantData.GetValuesByStartName(const aStartName: RawUTF8;
  TrimLeftStartName: boolean): variant;
var
  Up: array[byte] of AnsiChar;
  ndx: integer;
  name: RawUTF8;
begin
  if aStartName = '' then
  begin
    result := Variant(self);
    exit;
  end;
  if not (dvoIsObject in VOptions) or (VCount = 0) then
  begin
    SetVariantNull(result{%H-});
    exit;
  end;
  TDocVariant.NewFast(result);
  UpperCopy255(Up{%H-}, aStartName)^ := #0;
  for ndx := 0 to VCount - 1 do
    if IdemPChar(Pointer(VName[ndx]), Up) then
    begin
      name := VName[ndx];
      if TrimLeftStartName then
        system.delete(name, 1, length(aStartName));
      TDocVariantData(result).AddValue(name, VValue[ndx]);
    end;
end;

procedure TDocVariantData.SetValueOrRaiseException(Index: integer; const NewValue: variant);
begin
  if cardinal(Index) >= cardinal(VCount) then
    raise EDocVariant.CreateUTF8('Out of range Values[%] (count=%)', [Index, VCount])
  else
    VValue[Index] := NewValue;
end;

procedure TDocVariantData.RetrieveNameOrRaiseException(Index: integer; var Dest: RawUTF8);
begin
  if (cardinal(Index) >= cardinal(VCount)) or (VName = nil) then
    if dvoReturnNullForUnknownProperty in VOptions then
      Dest := ''
    else
      raise EDocVariant.CreateUTF8('Out of range Names[%] (count=%)', [Index, VCount])
  else
    Dest := VName[Index];
end;

procedure TDocVariantData.RetrieveValueOrRaiseException(Index: integer;
  var Dest: variant; DestByRef: boolean);
var
  Source: PVariant;
begin
  if cardinal(Index) >= cardinal(VCount) then
    if dvoReturnNullForUnknownProperty in VOptions then
      SetVariantNull(Dest)
    else
      raise EDocVariant.CreateUTF8('Out of range Values[%] (count=%)', [Index, VCount])
  else if DestByRef then
    SetVariantByRef(VValue[Index], Dest)
  else
  begin
    Source := @VValue[Index];
    while PVarData(Source)^.VType = varVariant or varByRef do
      Source := PVarData(Source)^.VPointer;
    Dest := Source^;
  end;
end;

function TDocVariantData.RetrieveValueOrRaiseException(aName: PUTF8Char;
  aNameLen: integer; aCaseSensitive: boolean; var Dest: variant; DestByRef: boolean): boolean;
var
  ndx: Integer;
begin
  ndx := GetValueIndex(aName, aNameLen, aCaseSensitive);
  if ndx < 0 then
    if dvoReturnNullForUnknownProperty in VOptions then
      SetVariantNull(Dest)
    else
      raise EDocVariant.CreateUTF8('[%] property not found', [aName])
  else
    RetrieveValueOrRaiseException(ndx, Dest, DestByRef);
  result := ndx >= 0;
end;

function TDocVariantData.GetValueOrItem(const aNameOrIndex: variant): variant;
var
  wasString: boolean;
  Name: RawUTF8;
begin
  if dvoIsArray in VOptions then // fast index lookup e.g. for Value[1]
    RetrieveValueOrRaiseException(VariantToIntegerDef(aNameOrIndex, -1), result, true)
  else
  begin
    VariantToUTF8(aNameOrIndex, Name, wasString); // by name lookup e.g. for Value['abc']
    if wasString then
      RetrieveValueOrRaiseException(pointer(Name), length(Name),
        dvoNameCaseSensitive in VOptions, result, true)
    else
      RetrieveValueOrRaiseException(GetIntegerDef(pointer(Name), -1), result, true);
  end;
end;

procedure TDocVariantData.SetValueOrItem(const aNameOrIndex, aValue: variant);
var
  wasString: boolean;
  ndx: integer;
  Name: RawUTF8;
begin
  if dvoIsArray in VOptions then // fast index lookup e.g. for Value[1]
    SetValueOrRaiseException(VariantToIntegerDef(aNameOrIndex, -1), aValue)
  else
  begin
    VariantToUTF8(aNameOrIndex, Name, wasString); // by name lookup e.g. for Value['abc']
    if wasString then
    begin
      ndx := GetValueIndex(Name);
      if ndx < 0 then
        ndx := InternalAdd(Name);
      SetVariantByValue(aValue, VValue[ndx]);
      if dvoInternValues in VOptions then
        DocVariantType.InternValues.UniqueVariant(VValue[ndx]);
    end
    else
      SetValueOrRaiseException(VariantToIntegerDef(aNameOrIndex, -1), aValue);
  end;
end;

function TDocVariantData.AddOrUpdateValue(const aName: RawUTF8;
  const aValue: variant; wasAdded: PBoolean; OnlyAddMissing: boolean): integer;
begin
  if dvoIsArray in VOptions then
    raise EDocVariant.CreateUTF8('AddOrUpdateValue("%") on an array', [aName]);
  result := GetValueIndex(aName);
  if result < 0 then
  begin
    result := InternalAdd(aName);
    if wasAdded <> nil then
      wasAdded^ := true;
  end
  else
  begin
    if wasAdded <> nil then
      wasAdded^ := false;
    if OnlyAddMissing then
      exit;
  end;
  SetVariantByValue(aValue, VValue[result]);
  if dvoInternValues in VOptions then
    DocVariantType.InternValues.UniqueVariant(VValue[result]);
end;

function TDocVariantData.ToJSON(const Prefix, Suffix: RawUTF8;
  Format: TTextWriterJSONFormat): RawUTF8;
var
  W: TTextWriter;
  temp: TTextWriterStackBuffer;
begin
  if (cardinal(VType) <> DocVariantVType) and (VType > varNull) then
  begin
    result := ''; // null -> 'null'
    exit;
  end;
  W := DefaultTextWriterSerializer.CreateOwnedStream(temp) as TTextWriter;
  try
    W.AddString(Prefix);
    DocVariantType.ToJSON(W, variant(self), twJSONEscape);
    W.AddString(Suffix);
    W.SetText(result, Format);
  finally
    W.Free;
  end;
end;

function TDocVariantData.ToNonExpandedJSON: RawUTF8;
var
  fields: TRawUTF8DynArray;
  fieldsCount: integer;
  W: TTextWriter;
  r, f: integer;
  row: PDocVariantData;
  temp: TTextWriterStackBuffer;
begin
  fields := nil; // to please Kylix
  fieldsCount := 0;
  if not (dvoIsArray in VOptions) then
  begin
    result := '';
    exit;
  end;
  if VCount = 0 then
  begin
    result := '[]';
    exit;
  end;
  with _Safe(VValue[0])^ do
    if dvoIsObject in VOptions then
    begin
      fields := VName;
      fieldsCount := VCount;
    end;
  if fieldsCount = 0 then
    raise EDocVariant.Create('ToNonExpandedJSON: Value[0] is not an object');
  W := DefaultTextWriterSerializer.CreateOwnedStream(temp) as TTextWriter;
  try
    W.Add('{"fieldCount":%,"rowCount":%,"values":[', [fieldsCount, VCount]);
    for f := 0 to fieldsCount - 1 do
    begin
      W.Add('"');
      W.AddJSONEscape(pointer(fields[f]));
      W.Add('"', ',');
    end;
    for r := 0 to VCount - 1 do
    begin
      row := _Safe(VValue[r]);
      if (r > 0) and (not (dvoIsObject in row^.VOptions) or (row^.VCount <> fieldsCount)) then
        raise EDocVariant.CreateUTF8('ToNonExpandedJSON: Value[%] not expected object', [r]);
      for f := 0 to fieldsCount - 1 do
        if (r > 0) and not IdemPropNameU(row^.VName[f], fields[f]) then
          raise EDocVariant.CreateUTF8('ToNonExpandedJSON: Value[%] field=% expected=%',
            [r, row^.VName[f], fields[f]])
        else
        begin
          W.AddVariant(row^.VValue[f], twJSONEscape);
          W.Add(',');
        end;
    end;
    W.CancelLastComma;
    W.Add(']', '}');
    W.SetText(result);
  finally
    W.Free;
  end;
end;

procedure TDocVariantData.ToRawUTF8DynArray(out Result: TRawUTF8DynArray);
var
  ndx: integer;
  wasString: boolean;
begin
  if dvoIsObject in VOptions then
    raise EDocVariant.Create('ToRawUTF8DynArray expects a dvArray');
  if dvoIsArray in VOptions then
  begin
    SetLength(Result, VCount);
    for ndx := 0 to VCount - 1 do
      VariantToUTF8(VValue[ndx], Result[ndx], wasString);
  end;
end;

function TDocVariantData.ToRawUTF8DynArray: TRawUTF8DynArray;
begin
  ToRawUTF8DynArray(result);
end;

function TDocVariantData.ToCSV(const Separator: RawUTF8): RawUTF8;
var
  tmp: TRawUTF8DynArray; // fast enough in practice
begin
  ToRawUTF8DynArray(tmp);
  result := RawUTF8ArrayToCSV(tmp, Separator);
end;

procedure TDocVariantData.ToTextPairsVar(out result: RawUTF8;
  const NameValueSep, ItemSep: RawUTF8; escape: TTextWriterKind);
var
  ndx: integer;
  temp: TTextWriterStackBuffer;
begin
  if dvoIsArray in VOptions then
    raise EDocVariant.Create('ToTextPairs expects a dvObject');
  if (VCount > 0) and (dvoIsObject in VOptions) then
    with DefaultTextWriterSerializer.CreateOwnedStream(temp) do
    try
      ndx := 0;
      repeat
        AddString(VName[ndx]);
        AddString(NameValueSep);
        AddVariant(VValue[ndx], escape);
        inc(ndx);
        if ndx = VCount then
          break;
        AddString(ItemSep);
      until false;
      SetText(result);
    finally
      Free;
    end;
end;

function TDocVariantData.ToTextPairs(const NameValueSep: RawUTF8;
  const ItemSep: RawUTF8; Escape: TTextWriterKind): RawUTF8;
begin
  ToTextPairsVar(result, NameValueSep, ItemSep, Escape);
end;

procedure TDocVariantData.ToArrayOfConst(out Result: TTVarRecDynArray);
var
  ndx: integer;
begin
  if dvoIsObject in VOptions then
    raise EDocVariant.Create('ToArrayOfConst expects a dvArray');
  if dvoIsArray in VOptions then
  begin
    SetLength(Result, VCount);
    for ndx := 0 to VCount - 1 do
    begin
      Result[ndx].VType := vtVariant;
      Result[ndx].VVariant := @VValue[ndx];
    end;
  end;
end;

function TDocVariantData.ToArrayOfConst: TTVarRecDynArray;
begin
  ToArrayOfConst(result);
end;

function TDocVariantData.ToUrlEncode(const UriRoot: RawUTF8): RawUTF8;
var
  json: RawUTF8; // temporary in-place modified buffer
begin
  VariantSaveJSON(variant(self), twJSONEscape, json);
  result := UrlEncodeJsonObject(UriRoot, Pointer(json), []);
end;

function TDocVariantData.GetOrAddIndexByName(const aName: RawUTF8): integer;
begin
  result := GetValueIndex(aName);
  if result < 0 then
    result := InternalAdd(aName);
end;

function TDocVariantData.GetOrAddPVariantByName(const aName: RawUTF8): PVariant;
var
  ndx: PtrInt;
begin
  ndx := GetValueIndex(aName);
  if ndx < 0 then
    ndx := InternalAdd(aName);
  result := @VValue[ndx];
end;

function TDocVariantData.GetPVariantByName(const aName: RawUTF8): PVariant;
var
  ndx: PtrInt;
begin
  ndx := GetValueIndex(aName);
  if ndx < 0 then
    if dvoReturnNullForUnknownProperty in VOptions then
      result := @DocVariantDataFake
    else
      raise EDocVariant.CreateUTF8('[%] property not found', [aName])
  else
    result := @VValue[ndx];
end;

function TDocVariantData.GetInt64ByName(const aName: RawUTF8): Int64;
begin
  if not VariantToInt64(GetPVariantByName(aName)^, result) then
    result := 0;
end;

function TDocVariantData.GetRawUTF8ByName(const aName: RawUTF8): RawUTF8;
var
  wasString: boolean;
  v: PVariant;
begin
  v := GetPVariantByName(aName);
  if PVarData(v)^.VType <= varNull then // default VariantToUTF8(null)='null'
    result := ''
  else
    VariantToUTF8(v^, result, wasString);
end;

function TDocVariantData.GetStringByName(const aName: RawUTF8): string;
begin
  result := VariantToString(GetPVariantByName(aName)^);
end;

procedure TDocVariantData.SetInt64ByName(const aName: RawUTF8; const aValue: Int64);
begin
  GetOrAddPVariantByName(aName)^ := aValue;
end;

procedure TDocVariantData.SetRawUTF8ByName(const aName, aValue: RawUTF8);
begin
  RawUTF8ToVariant(aValue, GetOrAddPVariantByName(aName)^);
end;

procedure TDocVariantData.SetStringByName(const aName: RawUTF8; const aValue: string);
begin
  RawUTF8ToVariant(StringToUTF8(aValue), GetOrAddPVariantByName(aName)^);
end;

function TDocVariantData.GetBooleanByName(const aName: RawUTF8): Boolean;
begin
  if not VariantToBoolean(GetPVariantByName(aName)^, result) then
    result := false;
end;

procedure TDocVariantData.SetBooleanByName(const aName: RawUTF8; aValue: Boolean);
begin
  GetOrAddPVariantByName(aName)^ := aValue;
end;

function TDocVariantData.GetDoubleByName(const aName: RawUTF8): Double;
begin
  if not VariantToDouble(GetPVariantByName(aName)^, result) then
    result := 0;
end;

procedure TDocVariantData.SetDoubleByName(const aName: RawUTF8; const aValue: Double);
begin
  GetOrAddPVariantByName(aName)^ := aValue;
end;

function TDocVariantData.GetDocVariantExistingByName(const aName: RawUTF8;
  aNotMatchingKind: TDocVariantKind): PDocVariantData;
begin
  result := GetAsDocVariantSafe(aName);
  if result^.Kind = aNotMatchingKind then
    result := @DocVariantDataFake;
end;

function TDocVariantData.GetDocVariantOrAddByName(const aName: RawUTF8;
  aKind: TDocVariantKind): PDocVariantData;
var
  ndx: integer;
begin
  ndx := GetOrAddIndexByName(aName);
  result := _Safe(VValue[ndx]);
  if result^.Kind <> aKind then
  begin
    result := @VValue[ndx];
    VarClear(PVariant(result)^);
    result^.Init(JSON_OPTIONS_FAST, aKind);
  end;
end;

function TDocVariantData.GetObjectExistingByName(const aName: RawUTF8): PDocVariantData;
begin
  result := GetDocVariantExistingByName(aName, dvArray);
end;

function TDocVariantData.GetObjectOrAddByName(const aName: RawUTF8): PDocVariantData;
begin
  result := GetDocVariantOrAddByName(aName, dvObject);
end;

function TDocVariantData.GetArrayExistingByName(const aName: RawUTF8): PDocVariantData;
begin
  result := GetDocVariantExistingByName(aName, dvObject);
end;

function TDocVariantData.GetArrayOrAddByName(const aName: RawUTF8): PDocVariantData;
begin
  result := GetDocVariantOrAddByName(aName, dvArray);
end;

function TDocVariantData.GetAsDocVariantByIndex(aIndex: integer): PDocVariantData;
begin
  if cardinal(aIndex) < cardinal(VCount) then
    result := _Safe(VValue[aIndex])
  else if dvoReturnNullForUnknownProperty in VOptions then
    result := @DocVariantDataFake
  else
    raise EDocVariant.CreateUTF8('Out of range _[%] (count=%)', [aIndex, VCount]);
end;

function ToText(kind: TDocVariantKind): PShortString;
begin
  result := GetEnumName(TypeInfo(TDocVariantKind), ord(kind));
end;

function _Obj(const NameValuePairs: array of const; Options: TDocVariantOptions): variant;
begin
  VarClear(result{%H-});
  TDocVariantData(result).InitObject(NameValuePairs, Options);
end;

function _Arr(const Items: array of const; Options: TDocVariantOptions): variant;
begin
  VarClear(result{%H-});
  TDocVariantData(result).InitArray(Items, Options);
end;

procedure _ObjAddProps(const NameValuePairs: array of const; var Obj: variant);
var
  o: PDocVariantData;
begin
  o := _Safe(Obj);
  if not (dvoIsObject in o^.VOptions) then
  begin // create new object
    VarClear(Obj);
    TDocVariantData(Obj).InitObject(NameValuePairs, JSON_OPTIONS_FAST);
  end
  else
  begin // append new names/values to existing object
    TVarData(Obj) := PVarData(o)^; // ensure not stored by reference
    o^.AddNameValuesToObject(NameValuePairs);
  end;
end;

procedure _ObjAddProps(const Document: variant; var Obj: variant);
var
  ndx: integer;
  d, o: PDocVariantData;
begin
  d := _Safe(Document);
  o := _Safe(Obj);
  if dvoIsObject in d.VOptions then
    if not (dvoIsObject in o.VOptions) then
      Obj := Document
    else
      for ndx := 0 to d^.VCount - 1 do
        o^.AddOrUpdateValue(d^.VName[ndx], d^.VValue[ndx]);
end;

function _ObjFast(const NameValuePairs: array of const): variant;
begin
  VarClear(result{%H-});
  TDocVariantData(result).InitObject(NameValuePairs, JSON_OPTIONS_FAST);
end;

function _ObjFast(aObject: TObject; aOptions: TTextWriterWriteObjectOptions): variant;
begin
  ObjectToVariant(aObject, result, aOptions);
end;

function _ArrFast(const Items: array of const): variant;
begin
  VarClear(result{%H-});
  TDocVariantData(result).InitArray(Items, JSON_OPTIONS_FAST);
end;

function _Json(const JSON: RawUTF8; Options: TDocVariantOptions): variant;
begin
  _Json(JSON, result, Options);
end;

function _JsonFast(const JSON: RawUTF8): variant;
begin
  _Json(JSON, result, JSON_OPTIONS_FAST);
end;

function _JsonFastExt(const JSON: RawUTF8): variant;
begin
  _Json(JSON, result, JSON_OPTIONS_FAST_EXTENDED);
end;

function _JsonFmt(const Format: RawUTF8; const Args, Params: array of const;
  Options: TDocVariantOptions): variant;
begin
  _JsonFmt(Format, Args, Params, Options, result);
end;

procedure _JsonFmt(const Format: RawUTF8; const Args, Params: array of const;
  Options: TDocVariantOptions; out result: variant);
var
  temp: RawUTF8;
begin
  temp := FormatUTF8(Format, Args, Params, true);
  if TDocVariantData(result).InitJSONInPlace(pointer(temp), Options) = nil then
    TDocVariantData(result).Clear;
end;

function _JsonFastFmt(const Format: RawUTF8; const Args, Params: array of const): variant;
begin
  _JsonFmt(Format, Args, Params, JSON_OPTIONS_FAST, result);
end;

function _Json(const JSON: RawUTF8; var Value: variant; Options: TDocVariantOptions): boolean;
begin
  VarClear(Value);
  if not TDocVariantData(Value).InitJSON(JSON, Options) then
  begin
    VarClear(Value);
    result := false;
  end
  else
    result := true;
end;

procedure _Unique(var DocVariant: variant);
begin // TDocVariantData(DocVariant): InitCopy() will check the DocVariant type
  TDocVariantData(DocVariant).InitCopy(DocVariant, JSON_OPTIONS[false]);
end;

procedure _UniqueFast(var DocVariant: variant);
begin // TDocVariantData(DocVariant): InitCopy() will check the DocVariant type
  TDocVariantData(DocVariant).InitCopy(DocVariant, JSON_OPTIONS_FAST);
end;

function _Copy(const DocVariant: variant): variant;
begin
  result := TDocVariant.NewUnique(DocVariant, JSON_OPTIONS[false]);
end;

function _CopyFast(const DocVariant: variant): variant;
begin
  result := TDocVariant.NewUnique(DocVariant, JSON_OPTIONS_FAST);
end;

function _ByRef(const DocVariant: variant; Options: TDocVariantOptions): variant;
begin
  VarClear(result{%H-});
  TDocVariantData(result) := _Safe(DocVariant)^; // fast byref copy
  TDocVariantData(result).SetOptions(Options);
end;

procedure _ByRef(const DocVariant: variant; out Dest: variant; Options: TDocVariantOptions);
begin
  TDocVariantData(Dest) := _Safe(DocVariant)^; // fast byref copy
  TDocVariantData(Dest).SetOptions(Options);
end;



{ TLockedDocVariant }

constructor TLockedDocVariant.Create;
begin
  Create(JSON_OPTIONS_FAST);
end;

constructor TLockedDocVariant.Create(FastStorage: boolean);
begin
  Create(JSON_OPTIONS[FastStorage]);
end;

constructor TLockedDocVariant.Create(options: TDocVariantOptions);
begin
  fLock := TAutoLocker.Create;
  fValue.Init(options);
end;

destructor TLockedDocVariant.Destroy;
begin
  inherited;
  fLock.Free;
end;

function TLockedDocVariant.Exists(const Name: RawUTF8; out Value: Variant): boolean;
var
  i: integer;
begin
  fLock.Enter;
  try
    i := fValue.GetValueIndex(Name);
    if i < 0 then
      result := false
    else
    begin
      Value := fValue.Values[i];
      result := true;
    end;
  finally
    fLock.Leave;
  end;
end;

function TLockedDocVariant.ExistsOrLock(const Name: RawUTF8;
  out Value: Variant): boolean;
var
  i: integer;
begin
  result := true;
  fLock.Enter;
  try
    i := fValue.GetValueIndex(Name);
    if i < 0 then
      result := false
    else
      Value := fValue.Values[i];
  finally
    if result then
      fLock.Leave;
  end;
end;

procedure TLockedDocVariant.ReplaceAndUnlock(
  const Name: RawUTF8; const Value: Variant; out LocalValue: Variant);
begin // caller made fLock.Enter
  try
    SetValue(Name, Value);
    LocalValue := Value;
  finally
    fLock.Leave;
  end;
end;

function TLockedDocVariant.AddExistingPropOrLock(const Name: RawUTF8;
  var Obj: variant): boolean;
var i: integer;
begin
  result := true;
  fLock.Enter;
  try
    i := fValue.GetValueIndex(Name);
    if i < 0 then
      result := false
    else
      _ObjAddProps([Name,fValue.Values[i]], Obj);
  finally
    if result then
      fLock.Leave;
  end;
end;

procedure TLockedDocVariant.AddNewPropAndUnlock(const Name: RawUTF8;
  const Value: variant; var Obj: variant);
begin // caller made fLock.Enter
  try
    SetValue(Name,Value);
    _ObjAddProps([Name,Value], Obj);
  finally
    fLock.Leave;
  end;
end;

function TLockedDocVariant.AddExistingProp(const Name: RawUTF8;
  var Obj: variant): boolean;
var
  i: integer;
begin
  result := true;
  fLock.Enter;
  try
    i := fValue.GetValueIndex(Name);
    if i < 0 then
      result := false
    else
      _ObjAddProps([Name,fValue.Values[i]], Obj);
  finally
    fLock.Leave;
  end;
end;

procedure TLockedDocVariant.AddNewProp(const Name: RawUTF8;
  const Value: variant; var Obj: variant);
begin
  fLock.Enter;
  try
    SetValue(Name, Value);
    _ObjAddProps([Name, Value], Obj);
  finally
    fLock.Leave;
  end;
end;

function TLockedDocVariant.GetValue(const Name: RawUTF8): Variant;
begin
  fLock.Enter;
  try
    fValue.RetrieveValueOrRaiseException(pointer(Name), length(Name),
      dvoNameCaseSensitive in fValue.Options, result, false);
  finally
    fLock.Leave;
  end;
end;

procedure TLockedDocVariant.SetValue(const Name: RawUTF8;
  const Value: Variant);
begin
  fLock.Enter;
  try
    fValue.AddOrUpdateValue(Name, Value);
  finally
    fLock.Leave;
  end;
end;

procedure TLockedDocVariant.AddItem(const Value: variant);
begin
  fLock.Enter;
  try
    fValue.AddItem(Value);
  finally
    fLock.Leave;
  end;
end;

function TLockedDocVariant.Copy: variant;
begin
  VarClear(result);
  fLock.Enter;
  try
    TDocVariantData(result).InitCopy(variant(fValue), JSON_OPTIONS_FAST);
  finally
    fLock.Leave;
  end;
end;

procedure TLockedDocVariant.Clear;
var
  opt: TDocVariantOptions;
begin
  fLock.Enter;
  try
    opt := fValue.Options;
    fValue.Clear;
    fValue.Init(opt);
  finally
    fLock.Leave;
  end;
end;

function TLockedDocVariant.ToJSON(HumanReadable: boolean): RawUTF8;
var
  tmp: RawUTF8;
begin
  fLock.Enter;
  try
    VariantSaveJSON(variant(fValue), twJSONEscape, tmp);
  finally
    fLock.Leave;
  end;
  if HumanReadable then
    JSONBufferReformat(pointer(tmp), result)
  else
    result := tmp;
end;


{ ************** JSON Parsing into Variant }

// internal method used by VariantLoadJSON(), GetVariantFromJSON() and
// TDocVariantData.InitJSON()
procedure GetJSONToAnyVariant(var Value: variant; var JSON: PUTF8Char;
  EndOfObject: PUTF8Char; Options: PDocVariantOptions; AllowDouble: boolean);

  procedure ProcessField;
  var
    val: PUTF8Char;
    wasString: boolean;
  begin
    val := GetJSONField(JSON, JSON, @wasString, EndOfObject);
    GetVariantFromJSON(val, wasString, Value, nil, AllowDouble);
  end;

var
  i: integer;
  t: ^TSynInvokeableVariantType;
  ToBeParsed: PUTF8Char;
  wasParsedWithinString: boolean;
  wasString: boolean;
begin
  VarClear(Value);
  if (Options <> nil) and (dvoAllowDoubleValue in Options^) then
    AllowDouble := true; // for ProcessField() above
  if EndOfObject <> nil then
    EndOfObject^ := ' ';
  while (JSON^ <= ' ') and (JSON^ <> #0) do
    inc(JSON);
  if (Options = nil) or (JSON^ in ['-', '0'..'9']) or
     (PInteger(JSON)^ = NULL_LOW) or (PInteger(JSON)^ = TRUE_LOW) or
     (PInteger(JSON)^ = FALSE_LOW) then
  begin
    ProcessField; // obvious simple type
    exit;
  end;
  wasParsedWithinString := false;
  if JSON^ = '"' then
    if dvoJSONObjectParseWithinString in Options^ then
    begin
      ToBeParsed := GetJSONField(JSON, JSON, @wasString, EndOfObject);
      EndOfObject := nil; // already set just above
      wasParsedWithinString := true;
    end
    else
    begin
      ProcessField;
      exit;
    end
  else
    ToBeParsed := JSON;
  t := pointer(SynVariantTypes);
  if (t <> nil) and not (dvoJSONParseDoNotTryCustomVariants in Options^) then
    for i := 1 to length(SynVariantTypes) do
      if t^.TryJSONToVariant(ToBeParsed, Value, EndOfObject) then
      begin
        if not wasParsedWithinString then
          JSON := ToBeParsed;
        exit;
      end
      else
        inc(t);
  if ToBeParsed^ in ['[', '{'] then
  begin
    // default JSON parsing and conversion to TDocVariant instance
    ToBeParsed := TDocVariantData(Value).
      InitJSONInPlace(ToBeParsed, Options^, EndOfObject);
    if ToBeParsed = nil then
    begin
      TDocVariantData(Value).Clear;
      exit; // eror parsing
    end;
    if not wasParsedWithinString then
      JSON := ToBeParsed;
  end
  else // back to simple variant types
  if wasParsedWithinString then
    GetVariantFromJSON(ToBeParsed, wasString{%H-}, Value, nil, AllowDouble)
  else
    ProcessField;
end;

function TextToVariantNumberTypeNoDouble(json: PUTF8Char): cardinal;
var
  start: PUTF8Char;
  c: AnsiChar;
begin
  result := varString;
  c := json[0];
  if (jcDigitFirstChar in JSON_CHARS[c]) and // ['-', '0'..'9']
     (((c >= '1') and (c <= '9')) or // is first char numeric?
     ((c = '0') and ((json[1] = '.') or (json[1] = #0))) or // '012' not JSON
     ((c = '-') and (json[1] >= '0') and (json[1] <= '9'))) then
  begin
    start := json;
    repeat
      inc(json)
    until (json^ < '0') or (json^ > '9'); // check digits
    case json^ of
      #0:
        if json - start <= 19 then // signed Int64 precision
          result := varInt64;
      '.':
        if (json[1] >= '0') and (json[1] <= '9') and
           (json[2] in [#0, '0'..'9']) then
          if (json[2] = #0) or (json[3] = #0) or
             ((json[3] >= '0') and (json[3] <= '9') and (json[4] = #0) or
              ((json[4] >= '0') and (json[4] <= '9') and (json[5] = #0))) then
            result := varCurrency; // currency ###.1234 number
    end;
  end;
end;

function TextToVariantNumberType(json: PUTF8Char): cardinal;
var
  start: PUTF8Char;
  exp: PtrInt;
  c: AnsiChar;
label
  exponent;
begin
  result := varString;
  c := json[0];
  if (jcDigitFirstChar in JSON_CHARS[c]) and // ['-', '0'..'9']
     (((c >= '1') and (c <= '9')) or // is first char numeric?
     ((c = '0') and ((json[1] = '.') or (json[1] = #0))) or // '012' not JSON
     ((c = '-') and (json[1] >= '0') and (json[1] <= '9'))) then
  begin
    start := json;
    repeat
      inc(json)
    until (json^ < '0') or (json^ > '9'); // check digits
    case json^ of
      #0:
        if json - start <= 19 then // signed Int64 precision
          result := varInt64
        else
          result := varDouble; // we may lost precision, but still a number
      '.':
        if (json[1] >= '0') and (json[1] <= '9') and
           (json[2] in [#0, 'e', 'E', '0'..'9']) then
          if (json[2] = #0) or (json[3] = #0) or
             ((json[3] >= '0') and (json[3] <= '9') and (json[4] = #0) or
             ((json[4] >= '0') and (json[4] <= '9') and (json[5] = #0))) then
            result := varCurrency // currency ###.1234 number
          else
          begin
            repeat // more than 4 decimals
              inc(json)
            until (json^ < '0') or (json^ > '9');
            case json^ of
              #0:
                result := varDouble;
              'e', 'E':
                begin
exponent:         inc(json); // inlined custom GetInteger()
                  start := json;
                  c := json^;
                  if (c = '-') or (c = '+') then
                  begin
                    inc(json);
                    c := json^;
                  end;
                  inc(json);
                  dec(c, 48);
                  if c > #9 then
                    exit;
                  exp := ord(c);
                  c := json^;
                  dec(c, 48);
                  if c <= #9 then
                  begin
                    inc(json);
                    exp := exp * 10 + ord(c);
                    c := json^;
                    dec(c, 48);
                    if c <= #9 then
                    begin
                      inc(json);
                      exp := exp * 10 + ord(c);
                    end;
                  end;
                  if json^ <> #0 then
                    exit;
                  if start^ = '-' then
                    exp := -exp;
                  if (exp > -324) and (exp < 308) then
                    result := varDouble; // 5.0 x 10^-324 .. 1.7 x 10^308
                end;
            end;
          end;
      'e', 'E':
        goto exponent;
    end;
  end;
end;

function GetNumericVariantFromJSON(JSON: PUTF8Char; var Value: TVarData;
  AllowVarDouble: boolean): boolean;
var
  err: integer;
  typ: cardinal;
label
  dbl;
begin
  if JSON <> nil then
  begin
    if AllowVarDouble then
      typ := TextToVariantNumberType(JSON)
    else
      typ := TextToVariantNumberTypeNoDouble(JSON);
    with Value do
      case typ of
        varInt64:
          begin
            VInt64 := GetInt64(JSON, err);
            if err <> 0 then // overflow? -> try floating point
              if AllowVarDouble then
                goto dbl
              else
              begin
                result := false;
                exit;
              end;
            if (VInt64 <= high(integer)) and (VInt64 >= low(integer)) then
              VType := varInteger
            else
              VType := varInt64;
            result := true;
            exit;
          end;
        varCurrency:
          begin
            VInt64 := StrToCurr64(JSON);
            VType := varCurrency;
            result := true;
            exit;
          end;
        varDouble:
          begin
dbl:        VDouble := GetExtended(JSON, err);
            if err = 0 then
            begin
              VType := varDouble;
              result := true;
              exit;
            end;
          end;
      end;
  end;
  result := false;
end;

procedure UniqueVariant(Interning: TRawUTF8Interning; var aResult: variant;
  aText: PUTF8Char; aTextLen: PtrInt; aAllowVarDouble: boolean);
var
  tmp: RawUTF8;
begin
  if not GetNumericVariantFromJSON(aText, TVarData(aResult), aAllowVarDouble) then
  begin
    FastSetString(tmp, aText, aTextLen);
    if Interning = nil then
      RawUTF8ToVariant(tmp, aResult)
    else
      Interning.UniqueVariant(aResult, tmp);
  end;
end;

procedure JSONToVariantInPlace(var Value: variant; JSON: PUTF8Char;
  Options: TDocVariantOptions; AllowDouble: boolean);
begin
  if (JSON <> nil) and (JSON^ <> #0) then
    GetJSONToAnyVariant(Value, JSON, nil, @Options, AllowDouble)
  else
    VarClear(Value);
end;

function JSONToVariant(const JSON: RawUTF8; Options: TDocVariantOptions;
  AllowDouble: boolean): variant;
var
  tmp: TSynTempBuffer;
begin
  tmp.Init(JSON); // temp copy before in-place decoding
  try
    JSONToVariantInPlace(result, tmp.buf, Options, AllowDouble);
  finally
    tmp.Done;
  end;
end;

procedure TextToVariant(const aValue: RawUTF8; AllowVarDouble: boolean;
  out aDest: variant);
begin
  if not GetNumericVariantFromJSON(pointer(aValue), TVarData(aDest), AllowVarDouble) then
    RawUTF8ToVariant(aValue, aDest);
end;

function GetNextItemToVariant(var P: PUTF8Char; out Value: Variant;
  Sep: AnsiChar; AllowDouble: boolean): boolean;
var
  temp: RawUTF8;
begin
  if P = nil then
    result := false
  else
  begin
    GetNextItem(P, Sep, temp);
    if not GetNumericVariantFromJSON(pointer(temp), TVarData(Value), AllowDouble) then
      RawUTF8ToVariant(temp, Value);
    result := true;
  end;
end;

function GetVariantFromNotStringJSON(JSON: PUTF8Char; var Value: TVarData;
  AllowDouble: boolean): boolean;
begin
  if JSON <> nil then
    while (JSON^ <= ' ') and (JSON^ <> #0) do
      inc(JSON);
  if (JSON = nil) or
     ((PInteger(JSON)^ = NULL_LOW) and
      (jcEndOfJSONValueField in JSON_CHARS[JSON[4]])) then
    Value.VType := varNull
  else if (PInteger(JSON)^ = FALSE_LOW) and (JSON[4] = 'e') and
          (jcEndOfJSONValueField in JSON_CHARS[JSON[5]]) then
  begin
    Value.VType := varBoolean;
    Value.VBoolean := false;
  end
  else if (PInteger(JSON)^ = TRUE_LOW) and
          (jcEndOfJSONValueField in JSON_CHARS[JSON[4]]) then
  begin
    Value.VType := varBoolean;
    Value.VBoolean := true;
  end
  else if not GetNumericVariantFromJSON(JSON, Value, AllowDouble) then
  begin
    result := false;
    exit;
  end;
  result := true;
end;

procedure GetVariantFromJSON(JSON: PUTF8Char; wasString: Boolean;
  var Value: variant; TryCustomVariants: PDocVariantOptions; AllowDouble: boolean);
begin
  // first handle any strict-JSON syntax objects or arrays into custom variants
  // (e.g. when called directly from TSQLPropInfoRTTIVariant.SetValue)
  if (TryCustomVariants <> nil) and (JSON <> nil) then
    if (GotoNextNotSpace(JSON)^ in ['{', '[']) and not wasString then
    begin
      GetJSONToAnyVariant(Value, JSON, nil, TryCustomVariants, AllowDouble);
      exit;
    end
    else
      AllowDouble := dvoAllowDoubleValue in TryCustomVariants^;
  // handle simple text or numerical values
  VarClear(Value);
  if not wasString and GetVariantFromNotStringJSON(JSON, TVarData(Value), AllowDouble) then
    exit;
  with TVarData(Value) do
  begin
    // found no numerical value -> return a string in the expected format
    VType := varString;
    VString := nil; // avoid GPF below when assigning a string variable to VAny
    FastSetString(RawUTF8(VString), JSON, StrLen(JSON));
  end;
end;

procedure _BinaryVariantLoadAsJSON(var Value: variant; JSON: PUTF8Char;
  TryCustomVariant: pointer);
begin
  if TryCustomVariant = nil then
    TryCustomVariant := @JSON_OPTIONS[true];
  GetJSONToAnyVariant(Value, JSON, nil, TryCustomVariant, {double=}true);
end;

function VariantLoadJSON(var Value: variant; JSON, EndOfObject: PUTF8Char;
  TryCustomVariants: PDocVariantOptions; AllowDouble: boolean): PUTF8Char;
var
  wasString: boolean;
  Val: PUTF8Char;
begin
  result := JSON;
  if JSON = nil then
    exit;
  if TryCustomVariants <> nil then
  begin
    if dvoAllowDoubleValue in TryCustomVariants^ then
      AllowDouble := true;
    if dvoJSONObjectParseWithinString in TryCustomVariants^ then
    begin
      JSON := GotoNextNotSpace(JSON);
      if JSON^ = '"' then
      begin
        Val := GetJSONField(result, result, @wasString, EndOfObject);
        GetJSONToAnyVariant(Value, Val, EndOfObject, TryCustomVariants, AllowDouble);
      end
      else
        GetJSONToAnyVariant(Value, result, EndOfObject, TryCustomVariants, AllowDouble);
    end
    else
      GetJSONToAnyVariant(Value, result, EndOfObject, TryCustomVariants, AllowDouble);
  end
  else
  begin
    Val := GetJSONField(result, result, @wasString, EndOfObject);
    GetVariantFromJSON(Val, wasString, Value, nil, AllowDouble);
  end;
  if result = nil then
    result := @NULCHAR; // reached end, but not invalid input
end;

procedure VariantLoadJSON(var Value: Variant; const JSON: RawUTF8;
  TryCustomVariants: PDocVariantOptions; AllowDouble: boolean);
var
  tmp: TSynTempBuffer;
begin
  tmp.Init(JSON); // temp copy before in-place decoding
  try
    VariantLoadJSON(Value, tmp.buf, nil, TryCustomVariants, AllowDouble);
  finally
    tmp.Done;
  end;
end;

function VariantLoadJSON(const JSON: RawUTF8; TryCustomVariants: PDocVariantOptions;
  AllowDouble: boolean): variant;
var
  tmp: TSynTempBuffer;
begin
  tmp.Init(JSON);
  try
    VariantLoadJSON(result, tmp.buf, nil, TryCustomVariants, AllowDouble);
  finally
    tmp.Done;
  end;
end;


initialization
  BinaryVariantLoadAsJSON := _BinaryVariantLoadAsJSON;
  VariantClearSeveral := _VariantClearSeveral;
  SortDynArrayVariantComp := _SortDynArrayVariantComp;

end.

