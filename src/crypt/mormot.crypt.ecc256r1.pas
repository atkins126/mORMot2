/// Framework Core Public-Key Cryptography with secp256r1/NISTP-256 ECC Curves
// - this unit is a part of the Open Source Synopse mORMot framework 2,
// licensed under a MPL/GPL/LGPL three license - see LICENSE.md
unit mormot.crypt.ecc256r1;

{
  *****************************************************************************

   High-Performance secp256r1/NISTP-256/prime256v1 Elliptic-Curve Cryptography
    - Low-Level ECC secp256r1 ECDSA and ECDH Functions
    - Middle-Level Certificate-based Public Key Cryptography

   If mormot.crypt.openssl.RegisterOpenSsl is called, uses faster OpenSSL.

  *****************************************************************************

}

interface

{$I ..\mormot.defines.inc}

uses
  classes,
  sysutils,
  mormot.core.base,
  mormot.core.os,
  mormot.core.rtti,
  mormot.core.text,
  mormot.core.buffers, // for base-64 and baudot encoding
  mormot.core.datetime,
  mormot.crypt.core;



{ ***************** Low-Level ECC secp256r1 ECDSA and ECDH Functions }

const
  /// the size of the 256-bit memory structure used for secp256r1
  // - map 32 bytes of memory
  ECC_BYTES = SizeOf(THash256);

type
  /// store a public key for ECC secp256r1 cryptography
  // - use Ecc256r1MakeKey() to generate such a key
  // - stored in compressed form with its standard byte header, i.e. each
  // public key consumes 33 bytes of memory
  TEccPublicKey = array[0..ECC_BYTES] of byte;

  /// store a public key for ECC secp256r1 cryptography
  // - use ecc_uncompress_key_pas() to compute such a key from a TEccPublicKey
  // - stored in uncompressed form, consuming 64 bytes of memory
  TEccPublicKeyUncompressed = array[0..(ECC_BYTES * 2) - 1] of byte;

  /// store a private key for ECC secp256r1 cryptography
  // - use Ecc256r1MakeKey() to generate such a key
  // - stored in compressed form, i.e. each private key consumes 32 bytes of memory
  TEccPrivateKey = array[0..ECC_BYTES - 1] of byte;

  /// store a 256-bit hash, as expected by ECC secp256r1 cryptography
  // - see e.g. Ecc256r1Sign() and Ecc256r1Verify() functions
  TEccHash = THash256;

  /// store a signature, as generated by ECC secp256r1 cryptography
  // - see e.g. Ecc256r1Sign() and Ecc256r1Verify() functions
  // - contains ECDSA's R and S integers
  // - each ECC signature consumes 64 bytes of memory
  TEccSignature = array[0..(ECC_BYTES * 2) - 1] of byte;

  /// store a signature, in the DER format
  // - statically allocated buffer as returned by EccSignToDer()
  TEccSignatureDer = array[0..(ECC_BYTES * 2) + 7] of byte;

  /// store an encryption key, as generated by ECC secp256r1 cryptography
  // - use Ecc256r1SharedSecret() to compute such a key from public/private keys
  // - 256-bit / 32 bytes derivation from secp256r1 ECDH is expected to have at
  // least 247-bit of entropy so could better be derivated via a KDF before used
  // as encryption secret - see @http://crypto.stackexchange.com/a/9428/40200
  TEccSecretKey = THash256;

  PEccPublicKey = ^TEccPublicKey;
  PEccPrivateKey = ^TEccPrivateKey;
  PEccHash = ^TEccHash;
  PEccSignature = ^TEccSignature;
  PEccSecretKey = ^TEccSecretKey;

var
  /// create a public/private key pair
  // - using secp256r1 curve, i.e. NIST P-256, or OpenSSL prime256v1
  // - direct low-level access to the our pascal version, or OpenSSL wrappers
  // - returns true if the key pair was generated successfully in pub/priv
  // - returns false if an error occurred
  // - this function is thread-safe and does not perform any memory allocation
  Ecc256r1MakeKey: function(out pub: TEccPublicKey; out priv: TEccPrivateKey): boolean;

  /// compute a shared secret given your secret key and someone else's public key
  // - using secp256r1 curve, i.e. NIST P-256, or OpenSSL prime256v1
  // - direct low-level access to the our pascal version, or OpenSSL wrappers
  // - note: it is recommended that you hash the result of Ecc256r1SharedSecret
  // before using it for symmetric encryption or HMAC (via an intermediate KDF)
  // - returns true if the shared secret was generated successfully in secret
  // - returns false if an error occurred
  // - this function is thread-safe and does not perform any memory allocation
  Ecc256r1SharedSecret: function(const pub: TEccPublicKey; const priv: TEccPrivateKey;
    out secret: TEccSecretKey): boolean;

  /// generate an ECDSA signature for a given hash value
  // - using secp256r1 curve, i.e. NIST P-256, or OpenSSL prime256v1
  // - direct low-level access to the our pascal version, or OpenSSL wrappers
  // - returns true if the signature was successfully generated in sign
  // - returns false if an error occurred
  // - this function is thread-safe and does not perform any memory allocation
  Ecc256r1Sign: function(const priv: TEccPrivateKey; const hash: TEccHash;
    out sign: TEccSignature): boolean;

  /// verify an ECDSA signature
  // - using secp256r1 curve, i.e. NIST P-256, or OpenSSL prime256v1
  // - direct low-level access to the our pascal version, or OpenSSL wrappers
  // - returns true if the supplied signature is valid
  // - returns false if an error occurred
  // - this function is thread-safe and does not perform any memory allocation
  Ecc256r1Verify: function(const pub: TEccPublicKey; const hash: TEccHash;
    const sign: TEccSignature): boolean;


/// pascal function to create a secp256r1 public/private key pair
function ecc_make_key_pas(out PublicKey: TEccPublicKey;
  out PrivateKey: TEccPrivateKey): boolean;

/// pascal function to compute a secp256r1 shared secret given your secret key
// and someone else's public key (in compressed format)
function ecdh_shared_secret_pas(const PublicKey: TEccPublicKey;
  const PrivateKey: TEccPrivateKey; out Secret: TEccSecretKey): boolean;

/// pascal function to compute a secp256r1 shared secret given your secret key
// and someone else's public key (in uncompressed/flat format)
// - this overloaded function is slightly faster than the one using TEccPublicKey,
// since public key doesn't need to be uncompressed
function ecdh_shared_secret_uncompressed_pas(const PublicPoint: TEccPublicKeyUncompressed;
  const PrivateKey: TEccPrivateKey; out Secret: TEccSecretKey): boolean;

/// pascal function to generate an ECDSA secp256r1 signature for a given hash value
function ecdsa_sign_pas(const PrivateKey: TEccPrivateKey; const Hash: TEccHash;
  out Signature: TEccSignature): boolean;

/// pascal function to verify an ECDSA secp256r1 signature from someone else's
// public key (in compressed format)
function ecdsa_verify_pas(const PublicKey: TEccPublicKey; const Hash: TEccHash;
  const Signature: TEccSignature): boolean;

/// pascal function to verify an ECDSA secp256r1 signature from someone else's
// public key (in uncompressed/flat format)
// - this overloaded function is slightly faster than the one using TEccPublicKey,
// since public key doesn't need to be uncompressed
function ecdsa_verify_uncompressed_pas(const PublicKey: TEccPublicKeyUncompressed;
  const Hash: TEccHash; const Signature: TEccSignature): boolean;

/// uncompress a public key for ECC secp256r1 cryptography
// - convert from its compressed form with its standard byte header
// (33 bytes of memory) into uncompressed/flat form (64 bytes of memory)
procedure ecc_uncompress_key_pas(const Compressed: TEccPublicKey; out
  Uncompressed: TEccPublicKeyUncompressed);



{ ***************** Middle-Level Certificate-based Public Key Cryptography }

type
  /// used to identify a TEccCertificate
  // - could be generated by TAesPrng.Fill() method
  TEccCertificateID = type THash128;

  /// used to identify a TEccCertificate issuer
  // - could be generated by AsciiToBaudot(), with truncation to 16 bytes
  // (up to 25 Ascii-7 characters)
  TEccCertificateIssuer = type THash128;

  /// used to store a date in a TEccCertificate
  // - i.e. 16-bit number of days since 1 August 2016
  // - use NowEccDate, EccDate(), EccToDateTime() or EccText() functions
  TEccDate = word;

  PEccCertificateID = ^TEccCertificateID;
  PEccCertificateIssuer = ^TEccCertificateIssuer;
  PEccDate = ^TEccDate;

  /// the certification information of a TEccCertificate
  // - as stored in TEccCertificateContent.Signed
  // - defined in a separate record, to be digitaly signed in the Signature field
  // - map TEccCertificate.Version 1 of the binary format
  // - "self-signed" certificates may be used as "root" certificates in the
  // TEccCertificateChain list
  TEccCertificateSigned = packed record
    /// when this certificate was generated
    IssueDate: TEccDate;
    /// certificate valid not before
    ValidityStart: TEccDate;
    /// certificate valid not after
    ValidityEnd: TEccDate;
    /// a genuine identifier for this certificate
    // - is used later on to validate other certificates in chain
    Serial: TEccCertificateID;
    /// identify the certificate issuer
    // - is either geniune random bytes, or some Baudot-encoded text
    Issuer: TEccCertificateIssuer;
    /// genuine identifier of the authority certificate used for signing
    // - should be used to retrieve the associated PublicKey used to compute
    // the Signature field
    // - may equal Serial, if was self-signed
    AuthoritySerial: TEccCertificateID;
    /// identify the authoritify issuer used for signing
    // - is either geniune random bytes, or some Baudot-encoded text
    // - may equal Issuer, if was self-signed
    AuthorityIssuer: TEccCertificateIssuer;
    /// the ECDSA secp256r1 public key of this certificate
    // - may be used later on for signing or key derivation
    PublicKey: TEccPublicKey;
  end;

  /// points to certification information of a TEccCertificate
  PEccCertificateSigned = ^TEccCertificateSigned;

  /// store a TEccCertificate binary buffer for ECC secp256r1 cryptography
  // - i.e. a certificate public key, with its ECDSA signature
  // - would be stored in 173 bytes
  TEccCertificateContent = packed record
    /// the TEccCertificate format version
    Version: word;
    /// the certification information, digitaly signed in the Signature field
    Signed: TEccCertificateSigned;
    /// SHA-256 + ECDSA secp256r1 signature of the Certificate record
    Signature: TEccSignature;
    /// FNV-1a checksum of all previous fields
    // - we use fnv32 and not crc32c here to avoid colision with crc64c hashing
    // - avoiding to compute slow ECDSA verification in case of corruption,
    // due e.g. to unexpected transmission/bug/fuzzing/dosattack
    // - should be the very last field in the record
    CRC: cardinal;
  end;

  /// points to a TEccCertificate binary buffer for ECC secp256r1 cryptography
  PEccCertificateContent = ^TEccCertificateContent;

  /// store a TEccSignatureCertified binary buffer for ECDSA secp256r1 signature
  // - i.e. the digital signature of some content
  TEccSignatureCertifiedContent = packed record
    /// the TEccSignatureCertificated format version
    Version: word;
    /// when this signature was generated
    Date: TEccDate;
    /// genuine identifier of the authority certificate used for signing
    // - should be used to retrieve the associated PublicKey used to compute
    // the Signature field
    AuthoritySerial: TEccCertificateID;
    /// identify the authoritify issuer used for signing
    // - is either geniune random bytes, or some Baudot-encoded text
    AuthorityIssuer: TEccCertificateIssuer;
    /// SHA-256 + ECDSA secp256r1 digital signature of the content
    Signature: TEccSignature;
  end;

  /// points to a TEccSignatureCertified buffer for ECDSA secp256r1 signature
  PEccSignatureCertifiedContent = ^TEccSignatureCertifiedContent;

  /// indicate the validity state of a ECDSA signature against a certificate
  // - as returned by low-level EccVerify() function, and
  // TEccSignatureCertified.Verify, TEccCertificateChain.IsValid or
  // TEccCertificateChain.IsSigned methods
  // - see also ECC_VALIDSIGN constant
  TEccValidity = (
    ecvUnknown,
    ecvValidSigned,
    ecvValidSelfSigned,
    ecvNotSupported,
    ecvBadParameter,
    ecvCorrupted,
    ecvInvalidDate,
    ecvUnknownAuthority,
    ecvDeprecatedAuthority,
    ecvInvalidSignature);

  /// the error codes returned by TEccCertificateSecret.Decrypt()
  // - see also ECC_VALIDDECRYPT constant
  TEccDecrypt = (
    ecdDecrypted,
    ecdDecryptedWithSignature,
    ecdNoContent,
    ecdCorrupted,
    ecdInvalidSerial,
    ecdNoPrivateKey,
    ecdInvalidMAC,
    ecdDecryptError,
    ecdWriteFileError);

const
  /// TEccValidity results indicating a valid digital signature
  ECC_VALIDSIGN =
    [ecvValidSigned, ecvValidSelfSigned];

  /// TEccDecrypt results indicating a valid decryption process
  ECC_VALIDDECRYPT =
    [ecdDecrypted, ecdDecryptedWithSignature];

function ToText(val: TEccValidity): PShortString; overload;
function ToText(res: TEccDecrypt): PShortString; overload;

/// fill all bytes of this ECC private key buffer with zero
// - may be used to cleanup stack-allocated content
// ! ... finally FillZero(PrivateKey); end;
procedure FillZero(out Priv: TEccPrivateKey); overload;

/// returns the current UTC date, as a TEccDate integer value
// - i.e. 16-bit number of days since 1 August 2016
function NowEccDate: TEccDate;
  {$ifdef HASINLINE}inline;{$endif}

/// convert a supplied TDateTime value into a TEccDate integer value
// - i.e. 16-bit number of days since 1 August 2016
// - returns 0 if the supplied value is invalid, i.e. out of range
function EccDate(const DateTime: TDateTime): TEccDate;

/// convert a supplied a TEccDate integer value into a TDateTime value
// - i.e. 16-bit number of days since 1 August 2016
function EccToDateTime(EccDate: TEccDate): TDateTime;
  {$ifdef HASINLINE}inline;{$endif}

/// convert a supplied a TEccDate integer value into a ISO-8601 text value
// - i.e. 16-bit number of days since 1 August 2016
function EccText(EccDate: TEccDate; Expanded: boolean = true): RawUtf8; overload;
  {$ifdef HASINLINE}inline;{$endif}

/// compare two TEccCertificateIssuer binary buffer values
function IsEqual(const issuer1, issuer2: TEccCertificateIssuer): boolean; overload;
  {$ifdef HASINLINE}inline;{$endif}

/// compare two TEccCertificateID binary buffer values
function IsEqual(const id1, id2: TEccCertificateID): boolean; overload;
  {$ifdef HASINLINE}inline;{$endif}

/// ensure a TEccCertificateIssuer binary buffer is not void, i.e. filled with 0

function IsZero(const issuer: TEccCertificateIssuer): boolean; overload;
  {$ifdef HASINLINE}inline;{$endif}

/// ensure a TEccCertificateID binary buffer is not void, i.e. filled with 0
function IsZero(const id: TEccCertificateID): boolean; overload;
  {$ifdef HASINLINE}inline;{$endif}

/// convert a supplied TEccCertificateIssuer binary buffer into proper text
// - returns Ascii-7 text if was stored using Baudot encoding
// - or returns hexadecimal values, if it was 16 bytes of random binary
function EccText(const Issuer: TEccCertificateIssuer): RawUtf8; overload;

/// convert some Ascii-7 text into a TEccCertificateIssuer binary buffer
// - using Emile Baudot encoding
// - returns TRUE on Text truncation to fit into the 16 bytes
function EccIssuer(const Text: RawUtf8; out Issuer: TEccCertificateIssuer): boolean;

/// convert a supplied TEccCertificateID binary buffer into proper text
// - returns hexadecimal values, or '' if the ID is filled with zeros
function EccText(const ID: TEccCertificateID): RawUtf8; overload;

/// convert a supplied hexadecimal buffer into a TEccCertificateID binary buffer
// - returns TRUE if the supplied Text was a valid hexadecimal buffer
function EccID(const Text: RawUtf8; out ID: TEccCertificateID): boolean;

/// fast check of the binary buffer storage of a certificate
// - ensure content.CRC has the expected value, using FNV-1a checksum
// - does not validate the certificate against the certificates chain, nor
// perform any ECC signature: use TEccCertificateChain.IsValid instead
function EccCheck(const content: TEccCertificateContent): boolean; overload;

/// fast check of the dates stored in a certificate binary buffer
// - could be validated against EccCheck()
function EccCheckDate(const content: TEccCertificateContent): boolean;

/// fast check if the binary buffer storage of a certificate was self-signed
// - a self-signed certificate will have its AuthoritySerial/AuthorityIssuer
// fields matching Serial/Issuer
function EccSelfSigned(const content: TEccCertificateContent): boolean;

/// fast check of the binary buffer storage of a signature
// - just check that the date and authority are set
function EccCheck(const content: TEccSignatureCertifiedContent): boolean; overload;

/// convert a supplied base-64 text into a TEccSignatureCertifiedContent binary buffer
function EccSign(const base64: RawUtf8;
  out content: TEccSignatureCertifiedContent): boolean;

/// convert a raw signature into a DER compatible content
// - returns the number of bytes encoded into der[] buffer
function EccSignToDer(const sign: TEccSignature; out der: TEccSignatureDer): integer;

/// convert a DER compatible content into a raw signature
function DerToEccSign(const der: TEccSignatureDer; out sign: TEccSignature): boolean;

/// convert a supplied TEccSignatureCertifiedContent binary buffer into proper text
// - returns base-64 encoded text, or '' if the signature was filled with zeros
function EccText(const sign: TEccSignatureCertifiedContent): RawUtf8; overload;

/// convert a supplied TEccSignature binary buffer into proper text
// - returns base-64 encoded text, or '' if the signature was filled with zeros
function EccText(const sign: TEccSignature): RawUtf8; overload;

/// low-level verification of a TEccSignatureCertifiedContent binary buffer
// - will verify all internal signature fields according to a supplied authority,
// then will perform the ECDSA verification of the supplied 256-bit hash with
// the authority public key
// - as used by TEccSignatureCertified.Verify and TEccCertificateChain.IsValid
function EccVerify(const sign: TEccSignatureCertifiedContent;
  const hash: THash256; const auth: TEccCertificateContent): TEccValidity;



implementation


{ ***************** Low-Level ECC secp256r1 ECDSA and ECDH Functions }

{
  Optimized pascal adaptation of "simple and secure ECDH and ECDSA library"
   https://github.com/kmackay/micro-ecc
  Copyright (c) 2014, Kenneth MacKay - BSD 2-Clause "Simplified" License

 Notes:
 - our branchless pascal/asm version is faster than the original micro-ecc code
 - so we don't need nor publish .o / .obj static files any more
 - mormot.crypt.openssl.RegisterOpenSsl activates the much faster OpenSSL asm

 Some Numbers on Win32 Delphi:
 - mORMot  50 Ecc256r1MakeKey in 47.49ms i.e. 1K/s, aver. 949us
 - mORMot  50 Ecc256r1Sign in 48.38ms i.e. 1K/s, aver. 967us
 - mORMot  50 Ecc256r1Verify in 60.64ms i.e. 824/s, aver. 1.21ms
 - mORMot  98 Ecc256r1SharedSecret in 101.17ms i.e. 0.9K/s, aver. 1.03ms

 As historical reference, Win32 statically linked .obj with gcc -O2:
 - mORMot .obj  50 Ecc256r1MakeKey in 95.35ms i.e. 524/s, aver. 1.90ms
 - mORMot .obj  50 Ecc256r1Sign in 96.84ms i.e. 516/s, aver. 1.93ms
 - mORMot .obj  50 Ecc256r1Verify in 117.36ms i.e. 426/s, aver. 2.34ms
 - mORMot .obj  98 Ecc256r1SharedSecret in 201.53ms i.e. 486/s, aver. 2.05ms

 Some Numbers on Linux x86_64:
 - mORMot  300 Ecc256r1MakeKey in 86.18ms i.e. 3.4K/s, aver. 287us
 - mORMot  300 Ecc256r1Sign in 90.92ms i.e. 3.2K/s, aver. 303us
 - mORMot  300 Ecc256r1Verify in 110.59ms i.e. 2.6K/s, aver. 368us
 - mORMot  598 Ecc256r1SharedSecret in 180.78ms i.e. 3.2K/s, aver. 302us

 - OpenSSL 300 Ecc256r1MakeKey in   5.09ms i.e. 57.5K/s, aver. 16us
 - OpenSSL 300 Ecc256r1Sign in   7.97ms i.e. 36.7K/s, aver. 26us
 - OpenSSL 300 Ecc256r1Verify in  28.66ms i.e. 10.2K/s, aver. 95us
 - OpenSSL 598 Ecc256r1SharedSecret in  44.75ms i.e. 13K/s, aver. 74us

 Some Numbers on Linux AARCH64 (Oracle Cloud VM) :
 - mORMot  300 Ecc256r1MakeKey in 243.31ms i.e. 1.2K/s, aver. 811us
 - mORMot  300 Ecc256r1Sign in 250.06ms i.e. 1.1K/s, aver. 833us
 - mORMot  300 Ecc256r1Verify in 304.56ms i.e. 0.9K/s, aver. 1.01ms
 - mORMot  598 Ecc256r1SharedSecret in 523.25ms i.e. 1.1K/s, aver. 875us

 - OpenSSL 300 Ecc256r1MakeKey in 8.72ms i.e. 33.5K/s, aver. 29us
 - OpenSSL 300 Ecc256r1Sign in 13.92ms i.e. 21K/s, aver. 46us
 - OpenSSL 300 Ecc256r1Verify in 56.14ms i.e. 5.2K/s, aver. 187us
 - OpenSSL 598 Ecc256r1SharedSecret in 90.75ms i.e. 6.4K/s, aver. 151us
}

const
  NUM_ECC_DIGITS = ECC_BYTES div 8; // = compute with 4 x 64-bit blocks

type
  // we use UInt64 instead of QWord
  TVLI = array[0..NUM_ECC_DIGITS - 1] of UInt64;
  PVLI = ^TVLI;

  TVLIDUAL = record
    case integer of
    0: (
      L,
      H: TVLI);
    1: (
      Lo,
      Hi: THash256Rec);
    2: (
      U64: array[0..(2 * NUM_ECC_DIGITS) - 1] of UInt64);
  end;

  TEccPoint = record
    x, y: TVLI;
  end;
  PEccPoint = ^TEccPoint;

const
  MAX_TRIES = 16;

  Curve_P_32: TVLI = (
    UInt64($FFFFFFFFFFFFFFFF),
    UInt64($00000000FFFFFFFF),
    UInt64($0000000000000000),
    UInt64($FFFFFFFF00000001));

  Curve_B_32: TVLI = (
    UInt64($3BCE3C3E27D2604B),
    UInt64($651D06B0CC53B0F6),
    UInt64($B3EBBD55769886BC),
    UInt64($5AC635D8AA3A93E7));

  Curve_G_32: TEccPoint = (
    x: (UInt64($F4A13945D898C296),
        UInt64($77037D812DEB33A0),
        UInt64($F8BCE6E563A440F2),
        UInt64($6B17D1F2E12C4247));
    y: (UInt64($CBB6406837BF51F5),
        UInt64($2BCE33576B315ECE),
        UInt64($8EE7EB4A7C0F9E16),
        UInt64($4FE342E2FE1A7F9B)));

  Curve_N_32: TVLI = (
    UInt64($F3B9CAC2FC632551),
    UInt64($BCE6FAADA7179E84),
    UInt64($FFFFFFFFFFFFFFFF),
    UInt64($FFFFFFFF00000000));

  _1: TVLI = (1,
              0,
              0,
              0);

  _3: TVLI = (3,
              0,
              0,
              0);

  _11: TVLI = (UInt64($0101010101010101),
               UInt64($0101010101010101),
               UInt64($0101010101010101),
               UInt64($0101010101010101));

procedure _clear(out VLI: TVLI);
  {$ifdef HASINLINE}inline;{$endif}
begin
  VLI[0] := 0;
  VLI[1] := 0;
  VLI[2] := 0;
  VLI[3] := 0;
end;

function _isZero(const VLI: TVLI): boolean;
  {$ifdef HASINLINE}inline;{$endif}
begin
  result := (VLI[0] = 0) and
            (VLI[1] = 0) and
            (VLI[2] = 0) and
            (VLI[3] = 0);
end;

function _equals(const Left, Right: TVLI): boolean;
  {$ifdef HASINLINE}inline;{$endif}
begin
  result := (Left[0] = Right[0]) and
            (Left[1] = Right[1]) and
            (Left[2] = Right[2]) and
            (Left[3] = Right[3]);
end;

// counts the number of bits required for VLI
function _numBits(const VLI: TVLI): integer;
  {$ifdef CPU64}inline;{$endif}
var
  digit: UInt64;
begin
  result := 3 * 64;
  digit := VLI[3];
  if digit = 0 then
  begin
    if VLI[2] <> 0 then
      result := 2
    else if VLI[1] <> 0 then
      result := 1
    else
    begin
      result := 0;
      if VLI[0] = 0 then
        exit;
    end;
    digit := VLI[result];
    result := result shl 6;
  end;
  repeat
    inc(result);
    digit := digit shr 1;
  until digit = 0;
end;

// returns sign of Left - Right
function _cmp(const Left, Right: TVLI): integer;
  {$ifdef HASINLINE}inline;{$endif}
var
  l, r: UInt64;
begin
  l := Left[3];
  r := Right[3];
  result := ord(l > r) - ord(l < r);
  if result <> 0 then
    exit;
  l := Left[2];
  r := Right[2];
  result := ord(l > r) - ord(l < r);
  if result <> 0 then
    exit;
  l := Left[1];
  r := Right[1];
  result := ord(l > r) - ord(l < r);
  if result <> 0 then
    exit;
  l := Left[0];
  r := Right[0];
  result := ord(l > r) - ord(l < r);
end;

// computes Output = Input shl Shift, returning carry
// can modify in place (if Output == Input). 0 < Shift < 64
function _lshift(var Output: TVLI; const Input: TVLI; Shift: integer): UInt64;
var
  temp: UInt64;
  rev: integer;
begin
  rev := 64 - Shift;
  result := Input[0] shr rev;
  Output[0] := Input[0] shl Shift;
  temp := Input[1];
  Output[1] := (temp shl Shift) or result;
  result := temp shr rev;
  temp := Input[2];
  Output[2] := (temp shl Shift) or result;
  result := temp shr rev;
  temp := Input[3];
  Output[3] := (temp shl Shift) or result;
  result := temp shr rev;
end;

{$ifdef CPU32}

procedure _rshift1(var VLI64: TVLI);
var
  VLI: TCardinalArray absolute VLI64;
  carry, temp: cardinal;
begin
  carry := VLI[7] shl 31;
  VLI[7] := VLI[7] shr 1;
  temp := VLI[6];
  VLI[6] := (temp shr 1) or carry;
  carry := temp shl 31;
  temp := VLI[5];
  VLI[5] := (temp shr 1) or carry;
  carry := temp shl 31;
  temp := VLI[4];
  VLI[4] := (temp shr 1) or carry;
  carry := temp shl 31;
  temp := VLI[3];
  VLI[3] := (temp shr 1) or carry;
  carry := temp shl 31;
  temp := VLI[2];
  VLI[2] := (temp shr 1) or carry;
  carry := temp shl 31;
  temp := VLI[1];
  VLI[1] := (temp shr 1) or carry;
  carry := temp shl 31;
  temp := VLI[0];
  VLI[0] := (temp shr 1) or carry;
end;

function _lshift1(var VLI64: TVLI): cardinal;
var
  VLI: TCardinalArray absolute VLI64;
  temp: cardinal;
begin
  result := VLI[0] shr 31;
  VLI[0] := VLI[0] shl 1;
  temp := VLI[1];
  VLI[1] := (temp shl 1) or result;
  result := temp shr 31;
  temp := VLI[2];
  VLI[2] := (temp shl 1) or result;
  result := temp shr 31;
  temp := VLI[3];
  VLI[3] := (temp shl 1) or result;
  result := temp shr 31;
  temp := VLI[4];
  VLI[4] := (temp shl 1) or result;
  result := temp shr 31;
  temp := VLI[5];
  VLI[5] := (temp shl 1) or result;
  result := temp shr 31;
  temp := VLI[6];
  VLI[6] := (temp shl 1) or result;
  result := temp shr 31;
  temp := VLI[7];
  VLI[7] := (temp shl 1) or result;
  result := temp shr 31;
end;

{$else}

procedure _rshift1(var VLI: TVLI);
  {$ifdef HASINLINE}inline;{$endif}
var
  carry, temp: UInt64;
begin
  carry := VLI[3] shl 63;
  VLI[3] := VLI[3] shr 1;
  temp := VLI[2];
  VLI[2] := (temp shr 1) or carry;
  carry := temp shl 63;
  temp := VLI[1];
  VLI[1] := (temp shr 1) or carry;
  carry := temp shl 63;
  temp := VLI[0];
  VLI[0] := (temp shr 1) or carry;
end;

function _lshift1(var VLI: TVLI): UInt64;
  {$ifdef HASINLINE}inline;{$endif}
var
  temp: UInt64;
begin
  result := VLI[0] shr 63;
  VLI[0] := VLI[0] shl 1;
  temp := VLI[1];
  VLI[1] := (temp shl 1) or result;
  result := temp shr 63;
  temp := VLI[2];
  VLI[2] := (temp shl 1) or result;
  result := temp shr 63;
  temp := VLI[3];
  VLI[3] := (temp shl 1) or result;
  result := temp shr 63;
end;

{$endif CPU32}

{$define ECC_ORIGINALMULT}
// original mult() is slightly faster than our unrolled version on most CPUs

{$ifdef CPUINTEL}
  {$undef ECC_ORIGINALMULT}
  // on i386/x64, our new unrolled mult() with asm faster - especially on FPC
{$endif CPUINTEL}

// Intel/AMD asm is located in mormot.crypt.core.pas and .inc associated files
{$ifndef CPUINTEL}

type
  TVLIHALF = array[byte] of {$ifdef CPU32} word {$else} cardinal {$endif};

const
  TVLIHALFSHIFTADD = SizeOf(pointer) * 4;      // 32 or 16
  TVLIHALFSHIFTSUB = SizeOf(pointer) * 8 - 1;  // 63 or 31

// computes Output = Left + Right, returning carry. Can modify in place
function _add256(out Output: TVLI; const Left, Right: TVLI): PtrUInt;
  {$ifdef CPU64} inline; {$endif CPU64}
var
  l: TVLIHALF absolute Left; // branchless operation over half registers
  r: TVLIHALF absolute Right;
  o: TVLIHALF absolute Output;
begin
  result := PtrUInt(l[0]) + r[0];
  o[0] := result;
  result := PtrUInt(l[1]) + r[1] + (result shr TVLIHALFSHIFTADD);
  o[1] := result;
  result := PtrUInt(l[2]) + r[2] + (result shr TVLIHALFSHIFTADD);
  o[2] := result;
  result := PtrUInt(l[3]) + r[3] + (result shr TVLIHALFSHIFTADD);
  o[3] := result;
  result := PtrUInt(l[4]) + r[4] + (result shr TVLIHALFSHIFTADD);
  o[4] := result;
  result := PtrUInt(l[5]) + r[5] + (result shr TVLIHALFSHIFTADD);
  o[5] := result;
  result := PtrUInt(l[6]) + r[6] + (result shr TVLIHALFSHIFTADD);
  o[6] := result;
  result := PtrUInt(l[7]) + r[7] + (result shr TVLIHALFSHIFTADD);
  o[7] := result;
  {$ifdef CPU32}
  result := PtrUInt(l[8]) + r[8] + (result shr TVLIHALFSHIFTADD);
  o[8] := result;
  result := PtrUInt(l[9]) + r[9] + (result shr TVLIHALFSHIFTADD);
  o[9] := result;
  result := PtrUInt(l[10]) + r[10] + (result shr TVLIHALFSHIFTADD);
  o[10] := result;
  result := PtrUInt(l[11]) + r[11] + (result shr TVLIHALFSHIFTADD);
  o[11] := result;
  result := PtrUInt(l[12]) + r[12] + (result shr TVLIHALFSHIFTADD);
  o[12] := result;
  result := PtrUInt(l[13]) + r[13] + (result shr TVLIHALFSHIFTADD);
  o[13] := result;
  result := PtrUInt(l[14]) + r[14] + (result shr TVLIHALFSHIFTADD);
  o[14] := result;
  result := PtrUInt(l[15]) + r[15] + (result shr TVLIHALFSHIFTADD);
  o[15] := result;
  {$endif CPU32}
  result := result shr TVLIHALFSHIFTADD;
end;

// computes Output = Left - Right, returning borrow. Can modify in place.
function _sub256(out Output: TVLI; const Left, Right: TVLI): PtrUInt;
  {$ifdef CPU64} inline; {$endif CPU64}
var
  l: TVLIHALF absolute Left; // branchless operation over half registers
  r: TVLIHALF absolute Right;
  o: TVLIHALF absolute Output;
begin
  result := PtrUInt(l[0]) - r[0];
  o[0] := result;
  result := PtrUInt(l[1]) - r[1] - (result shr TVLIHALFSHIFTSUB);
  o[1] := result;
  result := PtrUInt(l[2]) - r[2] - (result shr TVLIHALFSHIFTSUB);
  o[2] := result;
  result := PtrUInt(l[3]) - r[3] - (result shr TVLIHALFSHIFTSUB);
  o[3] := result;
  result := PtrUInt(l[4]) - r[4] - (result shr TVLIHALFSHIFTSUB);
  o[4] := result;
  result := PtrUInt(l[5]) - r[5] - (result shr TVLIHALFSHIFTSUB);
  o[5] := result;
  result := PtrUInt(l[6]) - r[6] - (result shr TVLIHALFSHIFTSUB);
  o[6] := result;
  result := PtrUInt(l[7]) - r[7] - (result shr TVLIHALFSHIFTSUB);
  o[7] := result;
  {$ifdef CPU32}
  result := PtrUInt(l[8]) - r[8] - (result shr TVLIHALFSHIFTSUB);
  o[8] := result;
  result := PtrUInt(l[9]) - r[9] - (result shr TVLIHALFSHIFTSUB);
  o[9] := result;
  result := PtrUInt(l[10]) - r[10] - (result shr TVLIHALFSHIFTSUB);
  o[10] := result;
  result := PtrUInt(l[11]) - r[11] - (result shr TVLIHALFSHIFTSUB);
  o[11] := result;
  result := PtrUInt(l[12]) - r[12] - (result shr TVLIHALFSHIFTSUB);
  o[12] := result;
  result := PtrUInt(l[13]) - r[13] - (result shr TVLIHALFSHIFTSUB);
  o[13] := result;
  result := PtrUInt(l[14]) - r[14] - (result shr TVLIHALFSHIFTSUB);
  o[14] := result;
  result := PtrUInt(l[15]) - r[15] - (result shr TVLIHALFSHIFTSUB);
  o[15] := result;
  {$endif CPU32}
  result := result shr TVLIHALFSHIFTSUB;
end;

{$ifndef ECC_ORIGINALMULT}

procedure _inc64(var Value: THash128Rec; var Added: QWord);
  {$ifdef CPU64} inline; {$else} unsupported {$endif CPU64}
var
  r: TVLIHALF absolute Added; // branchless operation over half registers
  o: TVLIHALF absolute Value;
  c: PtrUInt;
begin
  c := PtrUInt(o[0]) + r[0];
  o[0] := c;
  c := PtrUInt(o[1]) + r[1] + (c shr TVLIHALFSHIFTADD);
  o[1] := c;
  c := PtrUInt(o[2]) + (c shr TVLIHALFSHIFTADD);
  o[2] := c;
  c := PtrUInt(o[3]) + (c shr TVLIHALFSHIFTADD);
  o[3] := c;
end;

procedure _inc128(var Value: THash256Rec; var Added: THash128Rec);
  {$ifdef CPU64} inline; {$else} unsupported {$endif CPU64}
var
  r: TVLIHALF absolute Added; // branchless operation over half registers
  o: TVLIHALF absolute Value;
  c: PtrUInt;
begin
  c := PtrUInt(o[0]) + r[0];
  o[0] := c;
  c := PtrUInt(o[1]) + r[1] + (c shr TVLIHALFSHIFTADD);
  o[1] := c;
  c := PtrUInt(o[2]) + r[2] + (c shr TVLIHALFSHIFTADD);
  o[2] := c;
  c := PtrUInt(o[3]) + r[3] + (c shr TVLIHALFSHIFTADD);
  o[3] := c;
  c := PtrUInt(o[4]) + (c shr TVLIHALFSHIFTADD);
  o[4] := c;
  c := PtrUInt(o[5]) + (c shr TVLIHALFSHIFTADD);
  o[5] := c;
  c := PtrUInt(o[6]) + (c shr TVLIHALFSHIFTADD);
  o[6] := c;
  c := PtrUInt(o[7]) + (c shr TVLIHALFSHIFTADD);
  o[7] := c;
end;

{$endif ECC_ORIGINALMULT}

{$endif CPUINTEL}


{$ifdef ECC_ORIGINALMULT}

// original 256-bit rolled multiplication as proposed in micro-ecc

procedure _mult(out Output: TVLIDUAL; const Left, Right: TVLI);
var
  i, k, min: PtrInt;
  product: THash128Rec;
  carry, prev, rlo, rhi: UInt64;
  l, r: ^UInt64;
begin
  rlo := 0;
  rhi := 0;
  min := 0;
  // Compute each digit of Output in sequence, maintaining the carries
  for k := 0 to 2 * NUM_ECC_DIGITS - 2 do
  begin
    carry := 0;
    if k >= NUM_ECC_DIGITS then
    begin
      i := k + (1 - NUM_ECC_DIGITS);
      l := @Left[i];
      r := @Right[k - i];
      min := i;
    end
    else
    begin
      l := @Left[0];
      r := @Right[k];
    end;
    for i := min to k do
    begin
      if i >= NUM_ECC_DIGITS then
        break;
      mul64x64(l^, r^, product);
      prev := rlo;
      inc(rlo, product.L);
      inc(rhi, product.H);
      inc(rhi, ord(rlo < prev));
      inc(carry, ord(rhi < product.H));
      inc(l);
      dec(r);
    end;
    Output.U64[k] := rlo;
    rlo := rhi;
    rhi := carry;
  end;
  Output.U64[NUM_ECC_DIGITS * 2 - 1] := rlo;
end;

procedure _square(out Output: TVLIDUAL; const Left: TVLI);
var
  i, j, k, min: PtrInt;
  product: THash128Rec;
  carry, prev, rlo, rhi: UInt64;
begin
  rlo := 0;
  rhi := 0;
  min := 0;
  for k := 0 to 2 * NUM_ECC_DIGITS - 2 do
  begin
    carry := 0;
    if k >= NUM_ECC_DIGITS then
      min := k + (1 - NUM_ECC_DIGITS);
    for i := min to k do
    begin
      j := k - i;
      if i > j then
        break;
      mul64x64(Left[i], Left[j], product);
      if i < j then
      begin
        inc(carry, product.H shr 63);
        product.H := (product.H shl 1) or (product.L shr 63);
        product.L := product.L shl 1;
      end;
      prev := rlo;
      inc(rlo, product.L);
      inc(rhi, product.H);
      inc(rhi, ord(rlo < prev));
      inc(carry, ord(rhi < product.H));
    end;
    Output.U64[k] := rlo;
    rlo := rhi;
    rhi := carry;
  end;
  Output.U64[NUM_ECC_DIGITS * 2 - 1] := rlo;
end;

{$else}

// our CPU-neutral 256-bit unrolled version, mapping mul64x64() pattern
// - in practice, only faster (and enabled) on i386 and x86_64

{$ifndef CPUX64} // mormot.crytp.core.asmx64.inc offers faster _mult128() asm

{$ifdef FPC} // Delphi is not good at inlining and computing this function

procedure _mult64(l, r: PQWordRec; out product: THash128Rec); inline;
var
  t1, t2, t3: TQWordRec;
begin
  t1.V := QWord(l.L) * r.L;
  t2.V := QWord(l.H) * r.L + t1.H;
  t3.V := QWord(l.L) * r.H + t2.L;
  product.H := QWord(l.H) * r.H + t2.H + t3.H;
  product.L := t3.V shl 32 or t1.L;
end;

{$else} // we better use mormot.core.base asm on Delphi

procedure _mult64(left, right: PQWord; out product: THash128Rec);
  {$ifdef HASINLINE}inline;{$endif}
begin
  mul64x64(left^, right^, product);
end;

{$endif FPC}

procedure _mult128(const l, r: THash128Rec; out product: THash256Rec);
  {$ifdef HASINLINE}inline;{$endif}
var
  t1, t2, t3: THash128Rec;
begin
  _mult64(@l.L, @r.L, t1);  // t1.V := l.L * r.L;
  _mult64(@l.H, @r.L, t2);
  _inc64(t2, t1.H);         // t2.V := l.H * r.L + t1.H;
  _mult64(@l.L, @r.H, t3);
  _inc64(t3, t2.L);         // t3.V := l.L * r.H + t2.L;
  _mult64(@l.H, @r.H, product.h);
  _inc64(product.H, t2.H);
  _inc64(product.H, t3.H);  // product.H := l.H * r.H + t2.H + t3.H;
  product.L.L := t1.L;
  product.L.H := t3.L;      // product.L := t3.V shl 64 or t1.L;
end;

{$endif CPUX64}

procedure _mult(out Output: TVLIDUAL; const Left, Right: TVLI);
var
  t1, t2, t3: THash256Rec;
  l: THash256Rec absolute Left;
  r: THash256Rec absolute Right;
begin
  _mult128(l.L, r.L, t1);   // t1.V := l.L * r.L;
  _mult128(l.H, r.L, t2);
  _inc128(t2, t1.H);        // t2.V := l.H * r.L + t1.H;
  _mult128(l.L, r.H, t3);
  _inc128(t3, t2.L);        // t3.V := l.L * r.H + t2.L;
  _mult128(l.H, r.H, Output.Hi);
  _inc128(Output.Hi, t2.H);
  _inc128(Output.Hi, t3.H); // Output.H := l.H * r.H + t2.H + t3.H;
  Output.Lo.L := t1.L;
  Output.Lo.H := t3.L;      // product.L := t3.V shl 128 or t1.L;
end;

procedure _square(out Output: TVLIDUAL; const Left: TVLI);
  {$ifdef HASINLINE}inline;{$endif}
begin
  _mult(Output, Left, Left);
end;

{$endif ECC_ORIGINALMULT}


// computes result = (Left + Right) mod Modulo
// assumes that p_left < p_mod and p_right < p_mod, p_result != p_mod
procedure _modAdd(var Output: TVLI; const Left, Right, Modulo: TVLI);
  {$ifdef HASINLINE}inline;{$endif}
begin
  if (_add256(Output, Left, Right) <> 0) or
     (_cmp(Output, Modulo) >= 0) then
    // result > Modulo (result = Modulo + Remainder),
    // so subtract Modulo to get remainder
    _sub256(Output, Output, Modulo);
end;

// computes result = (Left - Right) mod Modulo.
// assumes that Left < Modulo and Right < Modulo, result != Modulo
procedure _modSub(out Output: TVLI; const Left, Right, Modulo: TVLI);
  {$ifdef HASINLINE}inline;{$endif}
begin
  if _sub256(Output, Left, Right) <> 0 then
    // In this case, Output == -diff == (max int) - diff.
    // Since -x mod d == d - x, we can get the correct result
    // from Output + Modulo (with overflow)
    _add256(Output, Output, Modulo);
end;

// computes result = Product mod Curve
// from http://www.nsa.gov/ia/_files/nist-routines.pdf
procedure _mmod_fast(out Output: TVLI; var p_product: TVLIDUAL);
var
  carry: integer;
  tmp: TVLI;
begin
  // t
  Output := p_product.L;
  // s1
  tmp[0] := 0;
  tmp[1] := p_product.U64[5] and $FFFFFFFF00000000;
  tmp[2] := p_product.U64[6];
  tmp[3] := p_product.U64[7];
  carry := _lshift1(tmp);
  inc(carry, _add256(Output, Output, tmp));
  // s2
  tmp[1] := p_product.U64[6] shl 32;
  tmp[2] := (p_product.U64[6] shr 32) or (p_product.U64[7] shl 32);
  tmp[3] := p_product.U64[7] shr 32;
  inc(carry, _lshift1(tmp));
  inc(carry, _add256(Output, Output, tmp));
  // s3
  tmp[0] := p_product.U64[4];
  tmp[1] := p_product.U64[5] and $FFFFFFFF;
  tmp[2] := 0;
  tmp[3] := p_product.U64[7];
  inc(carry, _add256(Output, Output, tmp));
  // s4
  tmp[0] := (p_product.U64[4] shr 32) or (p_product.U64[5] shl 32);
  tmp[1] := (p_product.U64[5] shr 32) or (p_product.U64[6] and $FFFFFFFF00000000);
  tmp[2] := p_product.U64[7];
  tmp[3] := (p_product.U64[6] shr 32) or (p_product.U64[4] shl 32);
  inc(carry, _add256(Output, Output, tmp));
  // d1
  tmp[0] := (p_product.U64[5] shr 32) or (p_product.U64[6] shl 32);
  tmp[1] := (p_product.U64[6] shr 32);
  tmp[2] := 0;
  tmp[3] := (p_product.U64[4] and $FFFFFFFF) or (p_product.U64[5] shl 32);
  dec(carry, _sub256(Output, Output, tmp));
  // d2
  tmp[0] := p_product.U64[6];
  tmp[1] := p_product.U64[7];
  tmp[2] := 0;
  tmp[3] := (p_product.U64[4] shr 32) or (p_product.U64[5] and $FFFFFFFF00000000);
  dec(carry, _sub256(Output, Output, tmp));
  // d3
  tmp[0] := (p_product.U64[6] shr 32) or (p_product.U64[7] shl 32);
  tmp[1] := (p_product.U64[7] shr 32) or (p_product.U64[4] shl 32);
  tmp[2] := (p_product.U64[4] shr 32) or (p_product.U64[5] shl 32);
  tmp[3] := (p_product.U64[6] shl 32);
  dec(carry, _sub256(Output, Output, tmp));
  // d4
  tmp[0] := p_product.U64[7];
  tmp[1] := p_product.U64[4] and $FFFFFFFF00000000;
  tmp[2] := p_product.U64[5];
  tmp[3] := p_product.U64[6] and $FFFFFFFF00000000;
  dec(carry, _sub256(Output, Output, tmp));
  if carry < 0 then
    repeat
      inc(carry, _add256(Output, Output, Curve_P_32));
    until carry >= 0
  else
    while (carry <> 0) or
          (_cmp(Curve_P_32, Output) <= 0) do
      dec(carry, _sub256(Output, Output, Curve_P_32));
end;

// computes result = (Left * Right) mod Curve
procedure _modMult_fast(out Output: TVLI; const Left, Right: TVLI);
  {$ifdef HASINLINE}inline;{$endif}
var
  product: TVLIDUAL;
begin
  _mult(product, Left, Right);
  _mmod_fast(Output, product);
end;

// computes result = Left^2 mod Curve
procedure _modSquare_fast(out Output: TVLI; const Left: TVLI);
  {$ifdef HASINLINE}inline;{$endif}
var
  product: TVLIDUAL;
begin
  _square(product, Left);
  _mmod_fast(Output, product);
end;

// computes result = (1 / p_input) mod Modulo. All VLIs are the same size
// See "From Euclid's GCD to Montgomery Multiplication to the Great Divide"
// https://labs.oracle.com/techrep/2001/smli_tr-2001-95.pdf
procedure _modInv(out Output: TVLI; const Input, Modulo: TVLI);
var
  a, b, u, v: TVLI;
  carry: PtrUInt;
  cmp: integer;
begin
  if _isZero(Input) then
  begin
    _clear(Output);
    exit;
  end;
  a := Input;
  b := Modulo;
  u := _1;
  _clear(v);
  while true do
  begin
    cmp := _cmp(a, b);
    if cmp = 0 then
      break;
    carry := 0;
    if (byte(a[0]) and 1) = 0 then
    begin
      _rshift1(a);
      if (byte(u[0]) and 1) = 1 then
        carry := _add256(u, u, Modulo);
      _rshift1(u);
      if carry <> 0 then
        THash256(u)[ECC_BYTES - 1] := THash256(u)[ECC_BYTES - 1] or $80;
    end
    else if (byte(b[0]) and 1) = 0 then
    begin
      _rshift1(b);
      if (byte(v[0]) and 1) = 1 then
        carry := _add256(v, v, Modulo);
      _rshift1(v);
      if carry <> 0 then
        THash256(v)[ECC_BYTES - 1] := THash256(v)[ECC_BYTES - 1] or $80;
    end
    else if cmp > 0 then
    begin
      _sub256(a, a, b);
      _rshift1(a);
      if _cmp(u, v) < 0 then
        _add256(u, u, Modulo);
      _sub256(u, u, v);
      if (byte(u[0]) and 1) = 1 then
        carry := _add256(u, u, Modulo);
      _rshift1(u);
      if carry <> 0 then
        THash256(u)[ECC_BYTES - 1] := THash256(u)[ECC_BYTES - 1] or $80;
    end
    else
    begin
      _sub256(b, b, a);
      _rshift1(b);
      if _cmp(v, u) < 0 then
        _add256(v, v, Modulo);
      _sub256(v, v, u);
      if (byte(v[0]) and 1) = 1 then
        carry := _add256(v, v, Modulo);
      _rshift1(v);
      if carry > 0 then
        THash256(v)[ECC_BYTES - 1] := THash256(v)[ECC_BYTES - 1] or $80;
    end;
  end;
  Output := u;
end;

// Point multiplication algorithm using Montgomery's ladder with co-Z coordinates.
// From http://eprint.iacr.org/2011/338.pdf

// Double in place
procedure EccPointDoubleJacobian(var X1, Y1, Z1: TVLI);
var
  carry: UInt64;
  t4, t5: TVLI;
begin
  // t1 = X, t2 = Y, t3 = Z
  if _isZero(Z1) then
    exit;
  _modSquare_fast(t4, Y1);         // t4 = y1^2
  _modMult_fast(t5, X1, t4);       // t5 = x1*y1^2 = A
  _modSquare_fast(t4, t4);         // t4 = y1^4
  _modMult_fast(Y1, Y1, Z1);       // t2 = y1*z1 = z3
  _modSquare_fast(Z1, Z1);         // t3 = z1^2
  _modAdd(X1, X1, Z1, Curve_P_32); // t1 = x1 + z1^2
  _modAdd(Z1, Z1, Z1, Curve_P_32); // t3 = 2*z1^2
  _modSub(Z1, X1, Z1, Curve_P_32); // t3 = x1 - z1^2
  _modMult_fast(X1, X1, Z1);       // t1 = x1^2 - z1^4
  _modAdd(Z1, X1, X1, Curve_P_32); // t3 = 2*(x1^2 - z1^4)
  _modAdd(X1, X1, Z1, Curve_P_32); // t1 = 3*(x1^2 - z1^4)
  if GetBitPtr(@X1, 0) then
  begin
    carry := _add256(X1, X1, Curve_P_32);
    _rshift1(X1);
    X1[NUM_ECC_DIGITS - 1] := X1[NUM_ECC_DIGITS - 1] or (carry shl 63);
  end
  else
    _rshift1(X1);
  // t1 = 3/2*(x1^2 - z1^4) = B
  _modSquare_fast(Z1, X1);         // t3 = B^2
  _modSub(Z1, Z1, t5, Curve_P_32); // t3 = B^2 - A
  _modSub(Z1, Z1, t5, Curve_P_32); // t3 = B^2 - 2A = x3
  _modSub(t5, t5, Z1, Curve_P_32); // t5 = A - x3
  _modMult_fast(X1, X1, t5);       // t1 = B * (A - x3)
  _modSub(t4, X1, t4, Curve_P_32); // t4 = B * (A - x3) - y1^4 = y3
  X1 := Z1;
  Z1 := Y1;
  Y1 := t4;
end;

// Modify (x1, y1) => (x1 * z^2, y1 * z^3)
procedure _apply_z(var X1, Y1, Z: TVLI);
var
  t1: TVLI;
begin
  _modSquare_fast(t1, Z);        // z^2
  _modMult_fast(X1, X1, t1);     // x1 * z^2
  _modMult_fast(t1, t1, Z);      // z^3
  _modMult_fast(Y1, Y1, t1);     // y1 * z^3
end;

// P = (x1, y1) => 2P, (x2, y2) => P'
procedure _XYcZ_initial_double(var X1, Y1, X2, Y2: TVLI; InitialZ: PVLI);
var
  z: TVLI;
begin
  X2 := X1;
  Y2 := Y1;
  if InitialZ <> nil then
    z := InitialZ^
  else
    z := _1;
  _apply_z(X1, Y1, z);
  EccPointDoubleJacobian(X1, Y1, z);
  _apply_z(X2, Y2, z);
end;

// Input P = (x1, y1, Z), Q = (x2, y2, Z)
// Output P' = (x1', y1', Z3), P + Q = (x3, y3, Z3)
// or P => P', Q => P + Q
procedure _XYcZ_add(var X1, Y1, X2, Y2: TVLI);
var
  t5: TVLI;
begin
  // t1 = X1, t2 = Y1, t3 = X2, t4 = Y2
  _modSub(t5, X2, X1, Curve_P_32); // t5 = x2 - x1
  _modSquare_fast(t5, t5);         // t5 = (x2 - x1)^2 = A
  _modMult_fast(X1, X1, t5);       // t1 = x1*A = B
  _modMult_fast(X2, X2, t5);       // t3 = x2*A = C
  _modSub(Y2, Y2, Y1, Curve_P_32); // t4 = y2 - y1
  _modSquare_fast(t5, Y2);         // t5 = (y2 - y1)^2 = D
  _modSub(t5, t5, X1, Curve_P_32); // t5 = D - B
  _modSub(t5, t5, X2, Curve_P_32); // t5 = D - B - C = x3
  _modSub(X2, X2, X1, Curve_P_32); // t3 = C - B
  _modMult_fast(Y1, Y1, X2);       // t2 = y1*(C - B)
  _modSub(X2, X1, t5, Curve_P_32); // t3 = B - x3
  _modMult_fast(Y2, Y2, X2);       // t4 = (y2 - y1)*(B - x3)
  _modSub(Y2, Y2, Y1, Curve_P_32); // t4 = y3
  X2 := t5;
end;

// Input P = (x1, y1, Z), Q = (x2, y2, Z)
//  Output P + Q = (x3, y3, Z3), P - Q = (x3', y3', Z3)
//  or P => P - Q, Q => P + Q
procedure _XYcZ_addC(var X1, Y1, X2, Y2: TVLI);
var
  t5, t6, t7: TVLI;
begin
  // t1 = X1, t2 = Y1, t3 = X2, t4 = Y2
  _modSub(t5, X2, X1, Curve_P_32); // t5 = x2 - x1
  _modSquare_fast(t5, t5);         // t5 = (x2 - x1)^2 = A
  _modMult_fast(X1, X1, t5);       // t1 = x1*A = B
  _modMult_fast(X2, X2, t5);       // t3 = x2*A = C
  _modAdd(t5, Y2, Y1, Curve_P_32); // t4 = y2 + y1
  _modSub(Y2, Y2, Y1, Curve_P_32); // t4 = y2 - y1
  _modSub(t6, X2, X1, Curve_P_32); // t6 = C - B
  _modMult_fast(Y1, Y1, t6);       // t2 = y1 * (C - B)
  _modAdd(t6, X1, X2, Curve_P_32); // t6 = B + C
  _modSquare_fast(X2, Y2);         // t3 = (y2 - y1)^2
  _modSub(X2, X2, t6, Curve_P_32); // t3 = x3
  _modSub(t7, X1, X2, Curve_P_32); // t7 = B - x3
  _modMult_fast(Y2, Y2, t7);       // t4 = (y2 - y1)*(B - x3)
  _modSub(Y2, Y2, Y1, Curve_P_32); // t4 = y3
  _modSquare_fast(t7, t5);         // t7 = (y2 + y1)^2 = F
  _modSub(t7, t7, t6, Curve_P_32); // t7 = x3'
  _modSub(t6, t7, X1, Curve_P_32); // t6 = x3' - B
  _modMult_fast(t6, t6, t5);       // t6 = (y2 + y1)*(x3' - B)
  _modSub(Y1, t6, Y1, Curve_P_32); // t2 = y3'
  X1 := t7;
end;

procedure EccPointMult(out Output: TEccPoint; const Point: TEccPoint;
  const Scalar: TVLI; InitialZ: PVLI);
var
  Rx, Ry: array[0..1] of TVLI;
  z: TVLI;
  i, nb: PtrInt;
begin
  // R0 and R1
  Rx[1] := Point.x;
  Ry[1] := Point.y;
  _XYcZ_initial_double(Rx[1], Ry[1], Rx[0], Ry[0], InitialZ);
  for i := _numBits(Scalar) - 2 downto 1 do
  begin
    nb := ord(not GetBitPtr(@Scalar, i));
    _XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb]);
    _XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb]);
  end;
  nb := ord(not GetBitPtr(@Scalar, 0));
  _XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb]);
  // Find final 1/Z value
  _modSub(z, Rx[1], Rx[0], Curve_P_32);  // X1 - X0
  _modMult_fast(z, z, Ry[1 - nb]);       // Yb * (X1 - X0)
  _modMult_fast(z, z, Point.x);          // xP * Yb * (X1 - X0)
  _modInv(z, z, Curve_P_32);             // 1 / (xP * Yb * (X1 - X0))
  _modMult_fast(z, z, Point.y);          // yP / (xP * Yb * (X1 - X0))
  _modMult_fast(z, z, Rx[1 - nb]);       // Xb * yP / (xP * Yb * (X1 - X0))
  // End 1/Z calculation
  _XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb]);
  _apply_z(Rx[0], Ry[0], z);
  Output.x := Rx[0];
  Output.y := Ry[0];
end;

// Compute a = sqrt(a) (mod curve_p)
procedure ModSqrt(var a: TVLI);
var
  i: integer;
  p1, result: TVLI;
begin
  result := _1;
  // Since curve_p == 3 (mod 4) for all supported curves, we can compute
  // sqrt(a) = a^((curve_p + 1) / 4) (mod curve_p)
  _add256(p1, Curve_P_32, _1); // p1 = curve_p + 1
  for i := _numBits(p1) - 1 downto 2 do
  begin
    _modSquare_fast(result, result);
    if GetBitPtr(@p1, i) then
      _modMult_fast(result, result, a);
  end;
  a := result;
end;

procedure _bswap256(dest, source: PQWordArray);
begin
  // warning: our code requires dest <> source
  dest[0] := bswap64(source[3]);
  dest[1] := bswap64(source[2]);
  dest[2] := bswap64(source[1]);
  dest[3] := bswap64(source[0]);
end;

procedure EccPointDecompress(out Point: TEccPoint; Compressed: PByteArray);
begin
  _bswap256(@Point.x, @Compressed[1]);
  _modSquare_fast(Point.y, Point.x);                  // y = x^2
  _modSub(Point.y, Point.y, _3, Curve_P_32);          // y = x^2 - 3
  _modMult_fast(Point.y, Point.y, Point.x);           // y = x^3 - 3x
  _modAdd(Point.y, Point.y, Curve_B_32, Curve_P_32);  // y = x^3 - 3x + b
  ModSqrt(Point.y);
  if (Point.y[0] and $01) <> (Compressed[0] and $01) then
    _sub256(Point.y, Curve_P_32, Point.y);
end;

function ecc_make_key_pas(out PublicKey: TEccPublicKey;
  out PrivateKey: TEccPrivateKey): boolean;
var
  priv: TVLI;
  pub: TEccPoint;
  tries: integer;
begin
  result := false;
  tries := 0;
  repeat
    inc(tries);
    TAesPrng.Fill(THash256(priv));
    if tries >= MAX_TRIES then
      exit;
    if _isZero(priv) or
       _equals(priv, _1) or
       _equals(priv, _11) then
      continue;
    // Make sure the private key is in the range [1, n - 1]
    // For the supported curves, n is always large enough that we only need
    // to subtract once at most
    if _cmp(Curve_N_32, priv) <= 0 then
      _sub256(priv, priv, Curve_N_32);
    EccPointMult(pub, Curve_G_32, priv, nil);
  until not (_isZero({%H-}pub.x) and _isZero(pub.y));
  _bswap256(@PrivateKey, @priv);
  _bswap256(@PublicKey[1], @pub.x);
  PublicKey[0] := 2 + (pub.y[0] and $01);
  result := true;
  _clear(priv); // erase sensitive information from stack
  _clear(pub.x);
  _clear(pub.y);
end;

function ecdh_shared_secret_uncompressed_pas(const PublicPoint: TEccPublicKeyUncompressed;
  const PrivateKey: TEccPrivateKey; out Secret: TEccSecretKey): boolean;
var
  pric: TVLI;
  product: TEccPoint;
  rnd: TVLI;
begin
  TAesPrng.Fill(THash256(rnd));
  _bswap256(@pric, @PrivateKey);
  EccPointMult(product, TEccPoint(PublicPoint), pric, @rnd);
  _bswap256(@Secret, @product.x);
  result := not (_isZero(product.x) and _isZero(product.y));
  _clear(product.x); // erase sensitive information from stack
  _clear(product.y);
  _clear(pric);
  _clear(rnd);
end;

procedure ecc_uncompress_key_pas(const Compressed: TEccPublicKey;
  out Uncompressed: TEccPublicKeyUncompressed);
begin
  EccPointDecompress(TEccPoint(Uncompressed), @Compressed);
end;

function ecdh_shared_secret_pas(const PublicKey: TEccPublicKey;
  const PrivateKey: TEccPrivateKey; out Secret: TEccSecretKey): boolean;
var
  pub: TEccPublicKeyUncompressed;
begin
  EccPointDecompress(TEccPoint(pub), @PublicKey);
  result := ecdh_shared_secret_uncompressed_pas(pub, PrivateKey, Secret);
end;

// computes result = (Left * Right) mod Modulo
procedure _modMult(out Output: TVLI; const Left, Right, Modulo: TVLI);
var
  carry: UInt64;
  cmp: integer;
  modbig, product: TVLIDUAL;
  digits, bits, prodbits, modbits: integer;
  v: PVLI;
begin
  modbits := _numBits(Modulo);
  _mult(product, Left, Right);
  prodbits := _numBits(product.H);
  if prodbits <> 0 then
    inc(prodbits, NUM_ECC_DIGITS * 64)
  else
    prodbits := _numBits(product.L);
  if prodbits < modbits then
  begin
    // l_product < p_mod
    Output := product.L;
    exit;
  end;
  // Shift p_mod by (LeftBits - modbits). This multiplies p_mod by the largest
  // power of two possible while still resulting in a number less than p_left
  _clear(modbig.L);
  _clear(modbig.H);
  digits := (prodbits - modbits) shr 6;
  bits   := (prodbits - modbits) and 63;
  v := @modbig.U64[digits];
  if bits > 0 then
    modbig.U64[digits + NUM_ECC_DIGITS] := _lshift(v^, Modulo, bits)
  else
    v^ := Modulo;
  // Subtract all multiples of Modulo to get the remainder
  while (prodbits > NUM_ECC_DIGITS * 64) or
        (_cmp(modbig.L, Modulo) >= 0) do
  begin
    cmp := _cmp(modbig.H, product.H);
    if (cmp < 0) or
       ((cmp = 0) and
        (_cmp(modbig.L, product.L) <= 0)) then
    begin
      if _sub256(product.L, product.L, modbig.L) <> 0 then
        _sub256(product.H, product.H, _1); // borrow
      _sub256(product.H, product.H, modbig.H);
    end;
    carry := (modbig.U64[NUM_ECC_DIGITS] and $01) shl 63;
    _rshift1(modbig.H);
    _rshift1(modbig.L);
    if carry <> 0 then
      modbig.U64[NUM_ECC_DIGITS - 1] := modbig.U64[NUM_ECC_DIGITS - 1] or carry;
    dec(prodbits);
  end;
  Output := product.L;
end;

function ecdsa_sign_pas(const PrivateKey: TEccPrivateKey; const Hash: TEccHash;
  out Signature: TEccSignature): boolean;
var
  k, temp, S: TVLI;
  P: TEccPoint;
  tries: integer;
begin
  result := false;
  tries := 0;
  repeat
    inc(tries);
    TAesPrng.Fill(THash256(k));
    if tries >= MAX_TRIES then
      exit; // the random generator seems broken
    if _isZero(k) or
       _equals(k, _1) or
       _equals(k, _11) then
      continue;
    if _cmp(Curve_N_32, k) <= 0 then
      _sub256(k, k, Curve_N_32);
    // temp = k * G
    EccPointMult(P, Curve_G_32, k, nil);
    // r = x1 (mod n)
    if _cmp(Curve_N_32, P.x) <= 0 then
      _sub256(P.x, P.x, Curve_N_32);
  until not _isZero({%H-}P.x);
  _bswap256(@Signature, @P.x);
  _bswap256(@temp, @PrivateKey);
  _modMult(S, P.x, temp, Curve_N_32); // s = r*d
  _bswap256(@temp, @Hash);
  _modAdd(S, temp, S, Curve_N_32);    // s = e + r*d
  _modInv(k, k, Curve_N_32);          // k = 1 / k
  _modMult(S, S, k, Curve_N_32);      // s = (e + r*d) / k
  _bswap256(@Signature[ECC_BYTES], @S);
  result := true;
end;

function ecdsa_verify_uncompressed_pas(const PublicKey: TEccPublicKeyUncompressed;
  const Hash: TEccHash; const Signature: TEccSignature): boolean;
var
  i, index, numbits: integer;
  pub: TEccPoint absolute PublicKey;
  sumpt: TEccPoint;
  pt: PEccPoint;
  pts: array[0..3] of PEccPoint;
  rx, ry, tx, ty, tz, l_r, l_s, u1, u2, z: TVLI;
begin
  result := false;
  _bswap256(@l_r, @Signature);
  _bswap256(@l_s, @Signature[ECC_BYTES]);
  if _isZero(l_r) or
     _isZero(l_s) or
     (_cmp(Curve_N_32, l_r) <= 0) or
     (_cmp(Curve_N_32, l_s) <= 0) then
    exit; // r, s must be <> 0 and < n
  // calculate u1 and u2
  _modInv(z, l_s, Curve_N_32);      // Z = s^-1
  _bswap256(@u1, @Hash);
  _modMult(u1, u1, z, Curve_N_32);  // u1 = e/s
  _modMult(u2, l_r, z, Curve_N_32); // u2 = r/s
  // calculate l_sum = G + Q
  sumpt.x := pub.x;
  sumpt.y := pub.y;
  tx := Curve_G_32.x;
  ty := Curve_G_32.y;
  _modSub(z, sumpt.x, tx, Curve_P_32);    // Z = x2 - x1
  _XYcZ_add(tx, ty, sumpt.x, sumpt.y);
  _modInv(z, z, Curve_P_32);              // Z = 1/Z
  _apply_z(sumpt.x, sumpt.y, z);
  // use Shamir's trick to calculate u1*G + u2*Q
  pts[0] := nil;
  pts[1] := @Curve_G_32;
  pts[2] := @pub;
  pts[3] := @sumpt;
  numbits := _numBits(u1);
  index := _numBits(u2);
  if index > numbits then
    numbits := index;
  index := ord(GetBitPtr(@u1, numbits - 1)) +
           ord(GetBitPtr(@u2, numbits - 1)) * 2;
  pt := pts[index];
  rx := pt.x;
  ry := pt.y;
  z := _1;
  for i := numbits - 2 downto 0 do
  begin
    EccPointDoubleJacobian(rx, ry, z);
    index := ord(GetBitPtr(@u1, i)) +
             ord(GetBitPtr(@u2, i)) * 2;
    pt := pts[index];
    if pt <> nil then
    begin
      tx := pt.x;
      ty := pt.y;
      _apply_z(tx, ty, z);
      _modSub(tz, rx, tx, Curve_P_32); // Z = x2 - x1
      _XYcZ_add(tx, ty, rx, ry);
      _modMult_fast(z, z, tz);
    end;
  end;
  _modInv(z, z, Curve_P_32); // Z = 1/Z
  _apply_z(rx, ry, z);
  // v = x1 (mod n)
  if _cmp(Curve_N_32, rx) <= 0 then
    _sub256(rx, rx, Curve_N_32);
  result := IsEqual(THash256(rx), THash256(l_r)); // Accept only if v == r
end;

function ecdsa_verify_pas(const PublicKey: TEccPublicKey; const Hash: TEccHash;
  const Signature: TEccSignature): boolean;
var
  pub: TEccPublicKeyUncompressed;
begin
  EccPointDecompress(TEccPoint(pub), @PublicKey);
  result := ecdsa_verify_uncompressed_pas(pub, Hash, Signature);
end;



{ ***************** Middle-Level Certificate-based Public Key Cryptography }

function ToText(val: TEccValidity): PShortString;
begin
  result := GetEnumName(TypeInfo(TEccValidity), ord(val));
end;

function ToText(res: TEccDecrypt): PShortString;
begin
  result := GetEnumName(TypeInfo(TEccDecrypt), ord(res));
end;

procedure FillZero(out Priv: TEccPrivateKey);
begin
  PInt64Array(@Priv)^[0] := 0;
  PInt64Array(@Priv)^[1] := 0;
  PInt64Array(@Priv)^[2] := 0;
  PInt64Array(@Priv)^[3] := 0;
end;

function IsEqual(const issuer1, issuer2: TEccCertificateIssuer): boolean;
var
  a: TPtrIntArray absolute issuer1;
  b: TPtrIntArray absolute issuer2;
begin
  result := (a[0] = b[0]) and
            (a[1] = b[1])
            {$ifdef CPU32} and
            (a[2] = b[2]) and
            (a[3] = b[3])
            {$endif CPU32};
end;

function IsEqual(const id1, id2: TEccCertificateID): boolean;
var
  a: TPtrIntArray absolute id1;
  b: TPtrIntArray absolute id2;
begin
  result := (a[0] = b[0]) and
            (a[1] = b[1])
            {$ifdef CPU32} and
            (a[2] = b[2]) and
            (a[3] = b[3])
            {$endif CPU32};
end;

function IsZero(const issuer: TEccCertificateIssuer): boolean;
var
  a: TPtrIntArray absolute issuer;
begin
  result := (a[0] = 0) and
            (a[1] = 0)
            {$ifdef CPU32} and
            (a[2] = 0) and
            (a [3] = 0)
            {$endif CPU32};
end;

function IsZero(const id: TEccCertificateID): boolean;
var
  a: TPtrIntArray absolute id;
begin
  result := (a[0] = 0) and
            (a[1] = 0)
            {$ifdef CPU32} and
            (a[2] = 0) and
            (a [3] = 0)
            {$endif CPU32};
end;

const
  // Mon, 01 Aug 2016 encoded as COM/TDateTime value
  ECC_DELTA = 42583;

function NowEccDate: TEccDate;
begin
  result := Trunc(NowUtc) - ECC_DELTA;
end;

function EccDate(const DateTime: TDateTime): TEccDate;
var
  now: integer;
begin
  if DateTime = 0 then
    result := 0
  else
  begin
    now := Trunc(DateTime) - ECC_DELTA;
    if cardinal(now) > high(TEccDate) then
      result := 0
    else
      result := now;
  end;
end;

function EccToDateTime(EccDate: TEccDate): TDateTime;
begin
  if EccDate = 0 then
    result := 0
  else
    result := EccDate + ECC_DELTA;
end;

function EccText(EccDate: TEccDate; Expanded: boolean): RawUtf8;
begin
  if EccDate = 0 then
    result := ''
  else
    result := DateToIso8601(EccDate + ECC_DELTA, Expanded);
end;

function EccText(const Issuer: TEccCertificateIssuer): RawUtf8;
var
  tmp: array[0..1] of TEccCertificateIssuer;
begin
  if IsZero(Issuer) then
    result := ''
  else
  begin
    tmp[0] := Issuer;
    tmp[1][0] := 0; // add a trailing #0 as expected for trailing bits
    result := BaudotToAscii(@tmp, SizeOf(Issuer));
    if result = '' then
      result := mormot.core.text.BinToHex(@Issuer, SizeOf(Issuer));
  end;
end;

function EccIssuer(const Text: RawUtf8; out Issuer: TEccCertificateIssuer): boolean;
var
  baudot: RawByteString;
  len: integer;
begin
  FillZero(THash128(Issuer));
  baudot := AsciiToBaudot(Text);
  len := length(baudot);
  result := len > SizeOf(Issuer);
  if result then // truncated
    len := SizeOf(Issuer);
  MoveFast(pointer(baudot)^, Issuer, len);
end;

function EccText(const ID: TEccCertificateID): RawUtf8;
begin
  if IsZero(ID) then
    result := ''
  else
    result := AesBlockToString(TAesBlock(ID));
end;

function EccID(const Text: RawUtf8; out ID: TEccCertificateID): boolean;
begin
  if length(Text) <> SizeOf(ID) * 2 then
    result := false
  else
    result := mormot.core.text.HexToBin(pointer(Text), @ID, SizeOf(ID));
end;

function EccCheck(const content: TEccCertificateContent): boolean;
begin
  with content.Signed do
    if (IssueDate = 0) or
       (IssueDate = 65535) or
       IsZero(Serial) or
       IsZero(Issuer) or
       IsZero(AuthoritySerial) or
       IsZero(AuthorityIssuer) or
       IsZero(@PublicKey, SizeOf(PublicKey)) or
       IsZero(@content.Signature, SizeOf(content.Signature)) then
      result := false
    else
      result := (content.Version in [1]) and
        (fnv32(0, @content, SizeOf(content) - 4) = content.CRC);
end;

function EccCheckDate(const content: TEccCertificateContent): boolean;
var
  now: TEccDate;
begin
  now := NowEccDate;
  with content.Signed do
    result := (IssueDate <= now) and
              ((ValidityStart = 0) or
               (ValidityStart <= now)) and
              ((ValidityEnd = 0) or
               (ValidityEnd >= now));
end;

function EccSelfSigned(const content: TEccCertificateContent): boolean;
begin
  with content.Signed do
    result := IsEqual(AuthoritySerial, Serial) and
              not IsZero(Serial) and
              IsEqual(AuthorityIssuer, Issuer);
end;

function EccCheck(const content: TEccSignatureCertifiedContent): boolean;
begin
  result := (content.Version in [1]) and
            (content.Date <> 0) and
            not IsZero(content.AuthoritySerial) and
            not IsZero(content.AuthorityIssuer) and
            not IsZero(@content.Signature, SizeOf(content.Signature));
end;

function EccSign(const base64: RawUtf8;
  out content: TEccSignatureCertifiedContent): boolean;
begin
  result := Base64ToBin(
    pointer(base64), @content, length(base64), SizeOf(content));
end;

const
  DER_SEQUENCE = $30;
  DER_INTEGER  = #$02;

function DerAppend(P: PAnsiChar; vli: PByteArray): PAnsiChar;
var
  pos, prefix: PtrUInt;
begin
  pos := 0;
  while vli[pos] = 0 do
    // ignore trailing zeros
    inc(pos);
  prefix := vli[pos] shr 7; // two's complement?
  P[0] := DER_INTEGER;
  P[1] := AnsiChar(ECC_BYTES - pos + prefix);
  P[2] := #$00; // prepend 0 for negative number (if prefix=1)
  inc(P, 2 + prefix);
  MoveSmall(@vli[pos], P, ECC_BYTES - pos);
  result := P + ECC_BYTES - pos;
end;

function EccSignToDer(const sign: TEccSignature;
  out der: TEccSignatureDer): integer;
begin
  if _isZero(PVLI(@sign[0])^) or
     _isZero(PVLI(@sign[ECC_BYTES])^) then
    result := 0
  else
  begin
    result := DerAppend(DerAppend(
      @der[2], @sign[0]), @sign[ECC_BYTES]) - PAnsiChar(@der);
    der[0] := DER_SEQUENCE;
    der[1] := result - 2;
  end;
end;

function DerParse(P: PAnsiChar; sig: PByteArray): PAnsiChar;
var
  pos: PtrUInt;
begin
  result := nil;
  _clear(PVLI(sig)^);
  if (P = nil) or
     (P[0] <> DER_INTEGER) then
    exit;
  pos := ECC_BYTES - ord(P[1]);
  inc(P, 2);
  if P^ = #0 then
  begin
    inc(P); // negative number appended
    inc(pos);
  end;
  if pos > ECC_BYTES then
    exit;
  MoveSmall(P, @sig[pos], ECC_BYTES - pos);
  result := P + ECC_BYTES - pos;
end;

function DerToEccSign(const der: TEccSignatureDer; out sign: TEccSignature): boolean;
begin
  if (der[0] <> DER_SEQUENCE) or
     (der[1] < 50) then
    result := false
  else
    result := DerParse(DerParse(@der[2], @sign[0]), @sign[ECC_BYTES]) =
      PAnsiChar(@der[der[1] + 2]);
end;

function EccText(const sign: TEccSignatureCertifiedContent): RawUtf8;
begin
  if EccCheck(sign) then
    result := BinToBase64(@sign, SizeOf(sign))
  else
    result := '';
end;

function EccText(const sign: TEccSignature): RawUtf8;
begin
  if IsZero(@sign, SizeOf(sign)) then
    result := ''
  else
    result := BinToBase64(@sign, SizeOf(sign));
end;

function EccVerify(const sign: TEccSignatureCertifiedContent;
  const hash: THash256; const auth: TEccCertificateContent): TEccValidity;
begin
  if IsZero(hash) then
    result := ecvBadParameter
  else if not EccCheck(sign) then
    result := ecvCorrupted
  else if sign.Date > NowEccDate then
    result := ecvInvalidDate
  else if not EccCheck(auth) then
    result := ecvUnknownAuthority
  else if not EccCheckDate(auth) then
    result := ecvDeprecatedAuthority
  else if not Ecc256r1Verify(auth.Signed.PublicKey, hash, sign.Signature) then
    result := ecvInvalidSignature
  else if EccSelfSigned(auth) then
    result := ecvValidSelfSigned
  else
    result := ecvValidSigned;
end;


initialization
  assert(NUM_ECC_DIGITS = 4);
  assert(SizeOf(TVLIDUAL) = SizeOf(TVLI) * 2);
  assert(SizeOf(TEccCertificateContent) = 173); // on all platforms/compilers
  // register our branchless pascal code by default
  @Ecc256r1MakeKey := @ecc_make_key_pas;
  @Ecc256r1SharedSecret := @ecdh_shared_secret_pas;
  @Ecc256r1Sign := @ecdsa_sign_pas;
  @Ecc256r1Verify := @ecdsa_verify_pas;

end.

